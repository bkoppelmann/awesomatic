@p typesetter = tex

% Sectioning
\def\fwseca#1#2{\section{#2}}
\def\fwsecb#1#2{\subsection{#2}}
\def\fwsecc#1#2{\subsubsection{#2}}
\def\fwsecd#1#2{\paragraph{#2}}
\def\fwsece#1#2{\subparagraph{#2}}


% The "new_page" pragma.
\def\fwnewpage{\newpage}

% The "vskip Nmm" pragma.
\def\fwvskip#1{\vspace #1mm}

\documentstyle[twoside]{article}

\setlength{\marginparwidth}{0pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\marginparsep}{0pt}
\setlength{\topmargin}{0pt}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}

\begin{document}

\title{Eli Specification of the SUIF Interface}
\author{W. M. Waite}
\maketitle

\begin{abstract}
This document is an Eli specification of the interface to SUIF.
It can be used as a ``back end'' for any translator intended to emit SUIF.
Only the SUIF emission task
(emitting an encoding of a SUIF representation of the program)
is covered in this document.
\end{abstract}

\newpage
\tableofcontents
\newpage

@A@<Introduction@>

Eli-generated code consists of a collection of modules written in C and
C++.
These modules can be combined with C or C++ source modules, and/or linked
with libraries compatible with the code generated by the compiler used to
translate them.
Operations implemented by additional source modules and libraries can be
invoked from within the Eli-generated code.
The invocations are written as part of some specification, and must
therefore conform to the notation used in that specification.

Several different problem-oriented languages are used in specifying
different subtasks of a translation to Eli, but those that permit
invocation of external operations all follow the same general conventions:
C identifiers, literals and comments are allowed, and all data types are
denoted by identifiers.
Arbitrary C or C++ compound statements may appear in certain contexts.

The most common point of interaction with external operations is in the
specification of the computations to be carried out over the source
program's abstract syntax tree.
These computations are described by code written in LIDO, a language whose
only mechanism for forming expressions is function application.
Thus all external operations must be expressible as function application
and all external types must be expressible as identifiers.

This document is a specification module that provides a set of definitions
to make SUIF library types and operations available within Eli
specifications.
It follows the SUIF library manual insofar as possible, and should be read
in conjunction with that document.
No interface specifications for the operations are available in either this
document or the SUIF library manual; the reader must obtain that
information from the system header files as referenced in the library
manual.
Although this presentation is somewhat inconvenient, it guarantees that 
there are no transcription errors and that the interface specification is
always up-to-date.

Many of the data types made available by the SUIF library are pointer
types without individual names.
This document declares identifiers to represent such types.
If possible, the declared identifier is constructed from the name of the
pointer's base type by capitalizing the first letter, and replacing each
sequence of an underscore followed by a lower-case letter by the upper-case
version of that letter.
Thus the identifier @{TypeNode@} is used to represent the type
@{type_node *@}.
Each pointer type will be be provided with a null value of that type,
denoted by an identifier consisting of @{No@} prefixed to the type name.
Thus the null value of type @{TypeNode@} is @{NoTypeNode@}, and is defined
as @{((TypeNode)0)@}.

Three C++ constructs that are very common in interactions with the SUIF
library are constructors of the form @{new c(x,y)@}, component accesses
of the form @{c->f(x,y)@} and casts of the form @{(t *)e@}.
These three constructs can be represented in functional form
by the following macros:

@$@<Functional representations of operations@>==@{
#define NEW(c) (new c)
#define MEMBER(c,m) ((c)->m)
#define CASTP(t,e) ((t *)(e))
@}

@A

Generally speaking, a front-end specification will deal with one file at a
time and will not need access to most methods of the @{file_set@} class.
The exception is @{add_file@}, which it will need to create output files.
Use of this method in the context of a front end is most conveniently
packaged as a special operation, @{NewFile@}:

@$@<Representation of Source Files@>==@{
typedef file_set *FileSet;
typedef file_set_entry *FileSetEntry;
#define NoFileSetEntry ((FileSetEntry)0)
#define NewFile(n) (fileset->add_file((char *)0,(n)))
@}

@{NewFile@} yields a file set entry.
The two arguments of @{add_file@} are strings naming the input and output
files holding the data for that file set entry.
@{NewFile@} omits the first argument because its intent is to create an
output file from text that is not SUIF data.

@A

Tree nodes and tree node lists are used to represent the control flow of
the program.
When the source language guarantees that certain operations are carried out
in sequence, that fact is embodied in the SUIF code by making those
operations tree nodes and connecting them in the guaranteed order to form a
tree node list.
Structured control flow is indicated by special tree nodes that have tree
node lists as children.

The @{tree_node@} class is not particularly useful for a front end, because
in most cases the front end deals with objects of one of the subclasses of
@{tree_node@}.
Also, tree node lists are more usual as general intermediate results.
Nevertheless, @{TreeNode@} and @{NoTreeNode@} are provided for
completeness.

@$@<Abstract Syntax Trees@>+=@{
typedef tree_node *TreeNode;
#define NoTreeNode ((TreeNode)0)

typedef tree_node_list *TreeNodeList;
#define NoTreeNodeList ((TreeNodeList)0)
@}

The @{append@} operation is provided by the class @{dlist@}, from which
@{tree_node_list@} is derived.
It appends an element to its list, and returns the element.
Unfortunately this is not the most appropriate behavior in the context of a
front end specification based on function application.
For such specifications, the operation should return the list:

@$@<Abstract Syntax Trees@>+=@{
#define AppendTreeNode(l,e) ((void)((l)->append(e)),l)
@}

Individual tree nodes are usually created and appended immediately to the
current tree node list.
In some cases, however, it is appropriate to save an object and either
append it somewhere else or clone it for insertion in various contexts.
Identifiers for the individual node types and their empty objects are
therefore included for completeness.

@$@<Abstract Syntax Trees@>+=@{
typedef tree_instr *TreeInstr;
#define NoTreeInstr ((TreeInstr)0)

typedef tree_if *TreeIf;
#define NoTreeIf ((TreeIf)0)

typedef tree_loop *TreeLoop;
#define NoTreeLoop ((TreeLoop)0)

typedef tree_for *TreeFor;
#define NoTreeFor ((TreeFor)0)

typedef tree_block *TreeBlock;
#define NoTreeBlock ((TreeBlock)0)

typedef tree_proc *TreeProc;
#define NoTreeProc ((TreeProc)0)
@}

@A

The actual operations of a program are represented by instructions and
expression trees.
Order of evaluation within an instruction is determined solely by
descendant relations among the components, and by any special semantics
given for the operations involved.

@$@<Instructions and Expression Trees@>==@{
typedef instruction *Instruction;
#define NoInstruction ((Instruction)0)

@<Three Operand Instructions@>
@<Branch and Jump Instructions@>
@<Load Constant Instructions@>
@<Call Instructions@>
@<Array Instructions@>
@<Multi-Way Branch Instructions@>
@<Label Instructions@>
@}

The subclasses of @{Instruction@} all have names beginning with @{in_@}.
Because of possible confusion with set operations from Eli's library, the
normal conventions will not be used to name these subclasses.
It turns out that in most cases it is inconvenient to use these class names
directly in a front end specification because that leads to verbosity.
Class constructors are usually combined in a stylized way with their
operands, forming idioms that appear over and over again.
Clarity is enhanced by using mnemonic macros for these idioms.

Destination operands can be ignored by a front end unless there is a good
reason for that front end to perform some optimization on its own.
SUIF automatically updates destination operands when it is building an
expression tree, so the front end should simply ensure that when it builds
an instruction the destination operand is @{operand()@}.

A source operand is created by applying @{operand@} to nothing (indicating
the absence of an operand), to a variable symbol (indicating that the
operand is the content of the variable), or to an instruction (indicating
that the operand is the result yielded by the instruction).
It is important to emphasize that application of @{operand@} to a variable
implies a fetch from that variable.
This means that variable symbols cannot be used as source operands in
contexts where the address of the variable is required.
Constant instructions (described below) must be used in such contexts.

@B

All of the computational operators take either one or two operands and
yield a result that will be used as an operand.
Two idioms, @{Monadic@} and @{Dyadic@}, embody these characteristics:

@$@<Three Operand Instructions@>+=@{
#define Monadic(o,t,right) operand(new in_rrr(o,t,operand(),right,operand()))
#define Dyadic(o,t,left,right) operand(new in_rrr(o,t,operand(),left,right))
@}

The @{o@} parameter is the operation code to be used, and the @{t@} parameter
is the type of the result.
It is important to note that the operation code always begins with @{io_@}
(e.g. @{io_add@}); the operation codes in the SUIF Library Manual are
specified without this prefix.
The @{left@} and @{right@} parameter are the values to which the operation
is applied.

The two move operations @{io_str@} and @{io_memcpy@} do not deliver results,
and thus do not fit the @{Dyadic@} idiom.
An instruction containing them will always appear at the top of an
expression tree, and will be the child of a tree instruction.
Although a single idiom could be used to characterize these two
instructions, two idioms would be more compact individually.
Two idioms also underscore the fact that the two instructions are used in
quite different contexts, and enhance the clarity of the code:
@{io_cpy@} can be used as simple as assignment.

@$@<Three Operand Instructions@>+=@{
#define Store(t,v,e) \
  (new tree_instr(new in_rrr(io_str,t,operand(),v,e)))
#define Move(t,v,a) \
  (new tree_instr(new in_rrr(io_memcpy,t,operand(),v,a)))
#define Copy(t, l, r) \
  (new tree_instr(new in_rrr(io_cpy, t, l, r, operand())))
@}

@{Store@} stores a computed value and @{Move@} copies
a value from another memory location.
In each case the first parameter is the SUIF type of the object being
stored and the second is the symbolic address of the destination.
The third parameter of the @{Store@} is the tree representing the computed
value, while the third parameter of the @{Move@} is the symbolic address of
the source.

It is important to note that both the second and third parameters of these
idioms must be operands.
If the corresponding arguments are not already of type @{operand@}, then
@{operand@} must be applied to them as part of the macro invocation.

Both the second and third parameters become @/source@/ operands of an
@{in_rrr@}.
The SUIF library manual states that a variable symbol appearing as a
source operand is interpreted as the @/content@/ of that variable.
Thus an assignment to a simple variable cannot use either of these idioms
with the second argument being @{operand@} applied to a variable symbol.
Instead, the operand must be a load constant instruction yielding the
address of the simple variable.
A variable symbol could be used only if the variable had a pointer value
that was being dereferenced on the left-hand side of the assignment.

@B

A jump instruction is used to transfer control either conditionally or
unconditionally.
It does not yield a result, and must be the child of a tree instruction.
Since there are only two conditional jumps, it is reasonable to provide
three idioms:

@$@<Branch and Jump Instructions@>==@{
#define JumpTrue(l,o) (new tree_instr(new in_bj(io_btrue,l,o)))
#define JumpFalse(l,o) (new tree_instr(new in_bj(io_bfalse,l,o)))
#define Jump(l) (new tree_instr(new in_bj(io_jmp,l,operand())))
@}

All of these idioms specify the target of the jump by the first parameter,
of type @{LabelSym@}.
Conditional jumps have a second parameter, of type @{operand@}, which
defines the condition.

@B

Constants are normally used as operands in expressions, and this use is
supported by the @{ConstVal@} idiom.
In some cases, however, it is useful to be able to use the instruction
itself (@{ConstInstr@}):

@$@<Load Constant Instructions@>==@{
typedef in_ldc *LdAddress;
#define NoLdAddress ((LdAddress)0)
#define ConstVal(type,value) operand(new in_ldc(type,operand(),immed(value)))
#define ConstInstr(type,value) (new in_ldc(type,operand(),immed(value)))
@}

The first parameter gives the type of the constant, while the second
specifies the value.

@B

No idioms are appropriate for call instructions.
It is sometimes useful to create a call instruction for a particular
procedure, storing it as a property of that procedure.
Whenever the procedure is called, the stored instruction can be cloned and
then have the arguments added.

@$@<Call Instructions@>==@{
typedef in_cal *Call;
#define NoCall ((Call)0)
@}

@B

No idioms are appropriate for array instructions.
The important point to remember about array instructions in SUIF is that
they are independent of the underlying type of the array.
Array types are used solely to specify storage requirements.
The array is assumed to be a single, contiguous block of memory referenced
by the base address given in the array instruction.
All that the array instruction does is to evaluate the subscript according
to the rules implied by row-major ordering.
If the source language assumes column-major ordering, the front end simply
reverses the order of the subscripts.

@$@<Array Instructions@>==@{
typedef in_array *Index;
#define NoIndex ((Index)0)
@}

@B

No experience yet with these instructions.

@$@<Multi-Way Branch Instructions@>==@{
@}

@B

A label instruction serves to mark a location in the tree node list as a
(potential) jump target.
Thus an idiom that incorporates it into a tree instruction is appropriate:

@$@<Label Instructions@>==@{
#define LabelDef(l) (new tree_instr(new in_lab(l)))
@}

The parameter, of type @{LabelSym@}, specifies the label being defined.

@A

An idiom clarifies access to the global symbol table:

@$@<Symbol Tables@>==@{
#define GlobalScope (fileset->globals())
typedef file_symtab *FileSymtab;
#define NoFileSymtab ((FileSymtab)0)
@}

Since the global symbol table is provided by the SUIF library, there is no
need for a front-end specification to refer to its type.
This is not true for procedure and block symbol tables, which must often
be stored as attributes or properties.

@B

A procedure scope is created by invoking the @{NewProcSymtab@} operation,
giving the parent scope and a name describing the created scope
as arguments.
Normally the name given is the name of the procedure with which the scope is
associated.
It is important to note that SUIF provides no connection between a
procedure scope and a procedure.
The user may interpret the name as a connection, but any use of that
connection must be provided by user code and is not supported by the SUIF
data structure.

@$@<Procedure scope@>==@{
proc_symtab *
NewProcSymtab(global_symtab *s, char *n)
{ proc_symtab *t = new proc_symtab(n);
  s->add_child(t);
  return t;
}

proc_symtab *
NewProcSymtab(file_symtab *s, char *n)
{ proc_symtab *t = new proc_symtab(n);
  s->add_child(t);
  return t;
}
@}

@$@<Interface procedure prototypes@>+=@{
extern proc_symtab *NewProcSymtab(global_symtab *s, char *n);
extern proc_symtab *NewProcSymtab(file_symtab *s, char *n);
@}

The type @{proc_symtab *@} must be defined as an identifier to make it
acceptable in an Eli specification:

@$@<LIDO representations of C++ types@>+=@{
typedef proc_symtab *ProcSymtab;
#define NoProcSymtab ((ProcSymtab)0)
@}

@B

A block scope is established by invoking the @{NewBlockSymtab@} operation,
giving the parent scope and a name describing the created scope
as arguments.
The name actually used for the block scope will be a unique name created
by appending an integer to the specified string:

@$@<Block scope@>==@{
block_symtab *
NewBlockSymtab(proc_symtab *s, char *n)
{ block_symtab *t = new block_symtab(n);
  s->add_child(t);
  return t;
}

block_symtab *
NewBlockSymtab(block_symtab *s, char *n)
{ block_symtab *t = new block_symtab(n);
  s->add_child(t);
  return t;
}
@}

@$@<Interface procedure prototypes@>+=@{
extern block_symtab *NewBlockSymtab(proc_symtab *s, char *n);
extern block_symtab *NewBlockSymtab(block_symtab *s, char *n);
@}

The type @{block_symtab *@} must be defined as an identifier to make it
acceptable in an Eli specification:

@$@<LIDO representations of C++ types@>+=@{
typedef block_symtab *BlockSymtab;
#define NoBlockSymtab ((BlockSymtab)0)
@}

@A

Symbols can represent procedures, variables or labels.
Each is defined in the symbol table representing its scope.

@$@<Symbols@>==@{
typedef proc_sym *ProcSym;
#define NoProcSym ((ProcSym)0)

typedef var_sym *VarSym;
#define NoVarSym ((VarSym)0)

typedef label_sym *LabelSym;
#define NoLabelSym ((LabelSym)0)

@<Variable Definitions@>

@}

Variable definitions are used to allocate storage for variables that
are not on the stack. The initial data for a static variable can be
specified by attaching annotations to the variable definition.

@$@<Variable Definitions@>==@{
typedef var_def *VarDef;
#define NoVarDef ((VarDef)0)
#define VarDefRepeatInit(def, typ, imm) \
    MEMBER(\
        def,\
        append_annote(\
            k_repeat_init,\
            NEW(immed_list(\
                immed(1),\
                immed(MEMBER(typ, size())),\
                immed(imm)))))
@}

@A

SUIF provides a set of predefined types and a set of type constructors from
which new types can be built.
Individual types are usually created and incorporated into other SUIF
objects immediately, so the type class names are not particularly useful
for front-end specification.
In some cases, however, it is appropriate to save a particular type object
for use in some other context.
Identifiers for the individual type classes and their empty objects are
therefore included for completeness.

@$@<Types@>+=@{
typedef type_node *TypeNode;
#define NoTypeNode ((TypeNode)0)

typedef ptr_type *PtrType;
#define NoPtrType ((PtrType)0)

typedef array_type *ArrayType;
#define NoArrayType ((ArrayType)0)

typedef func_type *FuncType;
#define NoFuncType ((FuncType)0)

typedef struct_type *StructType;
#define NoStructType ((StructType)0)
#define FieldOffset(strtyp, name) \
    MEMBER(strtyp, offset(MEMBER(strtyp, find_field_by_name(name))))

typedef enum_type *EnumType;
#define NoEnumType ((EnumType)0)

typedef modifier_type *ModifierType;
#define NoModifierType ((ModifierType)0)
@}

Since types are constructed in specific contexts on the basis of information
available in that context, it is possible that types with the same structure
will be constructed in many different contexts.
Whether these structurally-equivalent types are actually instances of the
same type or not depends upon the rules of the source language.
This dependence is reflected in the way in which a type is made accessible
within a scope.

After construction, new types are usually entered into the global scope to
ensure that structurally equivalent types are represented by the same
object.
It is possible to install types in a local scope, but this may be rarer.
Thus two idioms are provided:

@$@<Types@>+=@{
#define NewType(t) (GlobalScope->install_type(new t))
#define NewLocalType(t,s) ((s)->install_type(new t))
#define InstallType(t) (GlobalScope->install_type(t))
#define InstallLocalType(t, s) ((s)->install_type(t))
@}

Parameter @{t@} is a type expression in each case.
If the type is to be installed in a local scope, parameter @{s@} specifies
the symbol table for that scope.

@A@<Process Control@>

@B

The SUIF library, and any other libraries used by the translator, must be
initialized before any of the operations discussed in this document are
invoked.
Here is the simplest possible implementation, which uses no libraries other
than the SUIF library:

@$@<Initialization@>@Z+=@{
{ int argc = 0;

  init_suif(argc, (char **)0);
}
@}

If other specifications make use of libraries other than the SUIF library,
those libraries must be registered before @{init_suif@} is invoked.
To register a library, use the @{LIBRARY@} operation:

@$@<Initialization@>+=@{
{ int argc = 0;

  LIBRARY(foo, init_foo),
        ...
  LIBRARY(bar, init_bar),
  init_suif(argc, (char **)0);
}
@}

The first argument of @{LIBRARY@} is the name of the library, the second is
the name of the initialization routine.
By convention, the second argument is usually @{init_@} prefixed to the
first argument.

@A

An immediate value may be an integer constant, string constant,
floating-point constant, SUIF type, symbolic address, expression operand,
or instruction, or it can be undefined.
An immediate list is a list of immediate values.

@$@<Immediate Value and Immediate List@>==@{
typedef immed *Immed;
#define NoImmed ((Immed)0)

typedef immed_list *ImmedList;
#define NoImmedList ((ImmedList)0)
@}

@A@<Specification Files for SUIF Emission@>

This section briefly describes the specification files that implement the
SUIF emission process.

@B

A type-@{head@} file provides the interfaces for abstract data types used
in the tree computations.

@O@<suif_fw.head@>==@{
#include "suif_fw.h"
@}

@B

A type-@{c@} file provides the implementation of the abstract data types
defined by this specification.

@O@<suif_fw.c@>==@{
static char rcsid[] =
  "$Id: Suif.fw,v 1.13 1997/05/19 05:54:20 mah Exp $";

#include "suif_fw.h"

@<Procedure scope@>
@<Block scope@>
@}

@B

A type-@{h@} file provides the interface for the abstract data types
defined by this specification.

@O@<suif_fw.h@>==@{
#ifndef SUIF_FW_H
#define SUIF_FW_H

#undef BITSET_H
#undef MAX
#undef MIN
#include "suif.h"
#undef BITSET_H
#undef MAX
#undef MIN

@<Functional representations of operations@>

@<Representation of Source Files@>
@<Abstract Syntax Trees@>
@<Instructions and Expression Trees@>
@<Symbol Tables@>
@<Symbols@>
@<Types@>
@<Immediate Value and Immediate List@>

@<Interface procedure prototypes@>

@<LIDO representations of C++ types@>

#endif
@}

@B

A type-@{finl@} file provides code to be executed just before the processor
terminates.

@O@<suif_fw.finl@>==@{
exit_suif();
@}

\end{document}
