@p typesetter = tex
@p maximum_input_line_length = infinity

% Sectioning
\def\fwseca#1#2{\section{#2}}
\def\fwsecb#1#2{\subsection{#2}}
\def\fwsecc#1#2{\subsubsection{#2}}
\def\fwsecd#1#2{\paragraph{#2}}
\def\fwsece#1#2{\subparagraph{#2}}


% The "new_page" pragma.
\def\fwnewpage{\newpage}

% The "vskip Nmm" pragma.
\def\fwvskip#1{\vspace #1mm}

\documentstyle[twoside]{article}

\setlength{\marginparwidth}{0pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\marginparsep}{0pt}
\setlength{\topmargin}{0pt}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}

\begin{document}

\title{FORTRAN 77 to SUIF Translation}
\author{W. M. Waite}
\maketitle

\begin{abstract}
This document describes the translation from FORTRAN 77 to SUIF.
It is a part of an Eli specification from which compilers for FORTRAN 77
and FORTRAN 90 can be generated.

Only the translation task
(creating a SUIF target tree from a FORTRAN 77 abstract syntax tree)
is covered in this document.
Modules specifying other FORTRAN 77 translator tasks are also available,
and can be combined with this module to specify a processor that
creates a SUIF target tree from a FORTRAN 77 program.
programs into programs in other languages, or implement extensions.
\end{abstract}

\newpage
\tableofcontents
\newpage

@A@<Introduction@>

This document is a formal specification of the translation task for a
FORTRAN 77-to-SUIF compiler.
In order to provide traceability, the structure of the document mirrors
that of the standard.
File @{Suif/F77Suif.fw@} contains the specification from which this
document was generated.

All of the computations described in this document are carried out on an
abstract syntax tree having the form defined by the phrase structure
definition module for FORTRAN 77.
Eli can generate either a FORTRAN 77 or a FORTRAN 90 scanner/parser from
that specification, depending upon the setting of a @{#define@} directive.
The directive must be set for FORTRAN 77 if the generated scanner/parser is
to be used with the symbol table constructor described here.

The total set of components must include the phrase structure definition
module (file @{Phrase/Phrase.specs@}) with the appropriate @{#define@}
directive,
the symbol table definition (file @{Symbol/Symbol.specs@}),
and the expression analysis module (file @{Expr/Expr.specs@}).
Any arbitrary additional components may be supplied to describe other tasks.

In order to track the source of a SUIF program, the creating program
embodies version information:

@$@<Identification of the creating tool@>==@{
char *prog_who_string = "Eli-generated FORTRAN front end";
char *prog_ver_string = "1.0";
@}

This specification uses only the standard SUIF library,
and passes all information from the command line:

@$@<SUIF library initialization@>==@{
init_suif(argc, argv);
@}

@A

@$@<FORTRAN Terms and Concepts@>==@{
@<Syntactic Items@>
@}

@B

@$@<Syntactic Items@>==@{
@<Symbolic Name Characteristics@>
@<Statement Label Characteristics@>
@}

@C

The Suif characteristics of a symbolic name may be established on the basis
of a specific context or they may be established from general information
about the FORTRAN object.
If a specific context is involved, it is a surrounding context.
In that case, computations in the surrounding context set the appropriate
properties and assert completion via the @{upperdef@} attribute.

Since many symbolic names have no defining occurrence in FORTRAN, and since
the Suif characteristics of a symbolic name must be known before code can
be generated, a computation is carried out in the lower context of every
symbolic name to guarantee that the relevant information is available.
Availability is then asserted by the @{havedef@} attribute.

@$@<Symbolic Name Characteristics@>==@{
SYMBOL SymbolicName COMPUTE
  INH.upperdef=0;
  SYNT.havedef=
    @<Classes of Symbolic Names@>
    <- (
      INCLUDING xProgramUnit.GotAllTgtTypes,
      INCLUDING xProgramUnit.GotAllParVar,
      THIS.codechain,
      THIS.upperdef);
  THIS.codechain=THIS.codechain <- THIS.havedef;
END;

RULE: xArrayDeclarator ::= xVariableName '(' DimensionDeclarators ')'
COMPUTE
  DimensionDeclarators.havedef=xVariableName.havedef;
  DimensionDeclarators.ObjectKey=xVariableName.ObjectKey;
END;

RULE: xEntityDecl ::= xObjectName '(' DimensionDeclarators ')'
COMPUTE
  DimensionDeclarators.havedef=xObjectName.havedef;
  DimensionDeclarators.ObjectKey=xObjectName.ObjectKey;
END;

RULE: xEntityDecl ::= xObjectName '(' DimensionDeclarators ')' '*' xCharLength
COMPUTE
  DimensionDeclarators.havedef=xObjectName.havedef;
  DimensionDeclarators.ObjectKey=xObjectName.ObjectKey;
END;
@}

The Suif characteristics of a symbolic name depend on its FORTRAN
classification and type.
Also, if there are context-dependent characteristics they may or may not
preempt the standard computations and therefore they must be carried out
first.

@$@<Properties of a Symbolic Name@>==@{
Defined: int;
Variable: VarSym;

Procedure: ProcSym;
CallInstr: Call [Clone];
ArrayInstr: Index [Clone];

TYPE Clone(DefTableKey key, ProcSymtab scope, TYPE deflt)
{ if (key == NoKey || !PRESENT) return deflt;
  return (TYPE)VALUE->clone(scope);
}
@}

@C

@$@<Statement Label Characteristics@>==@{
ATTR TgtLabel: LabelSym;

RULE: xLblDef ::=  xLabel
COMPUTE
  .TgtLabel=
    MEMBER(
      INCLUDING xProgramUnit.suifscope,
      new_label(StringTable(xLblDef.Sym)));
  xLblDef.GotTgtLbl=ResetTgtLabel(xLblDef.UnitKey,.TgtLabel);
  xLblDef.codechain=
    IF(xLblDef.Executable,
      AppendTreeNode(xLblDef.codechain,LabelDef(.TgtLabel)),
      xLblDef.codechain);
END;

RULE: xLblDef ::=
COMPUTE
  xLblDef.GotTgtLbl=0;
END;

SYMBOL xProgramUnit COMPUTE
  SYNT.GotAllTgtLbls=CONSTITUENTS xLblDef.GotTgtLbl;
END;
@}

@$@<Properties of a Statement Label@>==@{
TgtLabel: LabelSym;
@}

@B@<Variable@>

@$@<Variable symbol@>@(@1@)@M@{
IF(EQ(GetVariable(@1.ObjectKey,NoVarSym),NoVarSym),
ORDER(message(DEADLY,"No symbol",0,@1.Coord),NoVarSym),
GetVariable(@1.ObjectKey,NoVarSym) <- @1.havedef
)
@}

@B

In order to correctly implement COMMON and EQUIVALENCE, an implementation
of FORTRAN must obey certain size relationships among objects of the
primitive types.
In particular, an integer, real or logical datum occupies one @/numeric
storage unit@/ while a double precision or complex datum occupies two.
A character datum occupies one @/character storage unit@/, and the standard
defines no relationship between numeric and character storage units.

The specification given here uses SUIF portable types, but these should be
checked carefully to ensure that they satisfy FORTRAN's size relationship.
If a change is required, it should be made here:

@$@<Storage@>+=@{
TypeNode FtnInt   = type_signed;
TypeNode FtnReal  = type_float;
TypeNode FtnDble  = type_double;
TypeNode FtnLogic = type_signed;
@}

According to the convention of s2c/sf2c, FORTRAN complex is represented 
by a SUIF structure with two real values as fields. 
The following can be described with C declaration as typedef struct
complex.

@$@<Storage@>+=@{
StructType ComplexStruct = 
    NEW(struct_type(
        TYPE_STRUCT,
        2 * MEMBER(type_float, size()),
        "complex",
        2));
MEMBER(ComplexStruct, set_field_name(0, "_r"));
MEMBER(ComplexStruct, set_field_name(1, "_i"));
MEMBER(ComplexStruct, set_field_type(0, type_float));
MEMBER(ComplexStruct, set_field_type(1, type_float));
MEMBER(ComplexStruct, set_offset(0, 0));
MEMBER(ComplexStruct, set_offset(1, MEMBER(type_float, size())));

TypeNode FtnComplexEle = FtnReal;
TypeNode FtnComplex = InstallType(ComplexStruct);
@}


@$@<Storage@>+=@{
StructType DoubleComplexStruct = 
    NEW(struct_type(
        TYPE_STRUCT,
        2 * MEMBER(type_double, size()),
        "doublecomplex",
        2));
MEMBER(DoubleComplexStruct, set_field_name(0, "_r"));
MEMBER(DoubleComplexStruct, set_field_name(1, "_i"));
MEMBER(DoubleComplexStruct, set_field_type(0, type_double));
MEMBER(DoubleComplexStruct, set_field_type(1, type_double));
MEMBER(DoubleComplexStruct, set_offset(0, 0));
MEMBER(DoubleComplexStruct, set_offset(1, MEMBER(type_double, size())));

TypeNode FtnDbComplexEle = FtnDble;
TypeNode FtnDbComplex = InstallType(DoubleComplexStruct);
@}

@$@<Definition table key for double complex@>==@{
DbComplexType;
@}

FORTRAN character is actually a string of character type.

@$@<Storage@>+=@{
TypeNode FtnCharEle = type_char;
TypeNode FtnChar  = NewType(array_type(
                                  FtnCharEle,
                                  array_bound(0),
                                  array_bound()));
@}

The I/O argument structures for the I77 library used by sf2c and this
specification use types that may vary according according to an option
("-i2" or "-i4").  We define the defaults here.

@$@<f2c type variable definitions@>==@{
TypeNode f2c_flag;
TypeNode f2c_len;
TypeNode f2c_int;
@}

@$@<f2c type variable externs@>==@{
extern TypeNode f2c_flag;
extern TypeNode f2c_len;
extern TypeNode f2c_int;
@}

@$@<f2c type variable initialization@>==@{
f2c_flag = type_signed;
f2c_len = type_signed;
f2c_int = type_signed;
@}

@A@<Characters, Lines, and Execution Sequence@>

@/Normal execution sequence@/ is the execution of executable statements in
the order in which they appear in a program unit.
This order is imposed on the SUIF code by using a chain to pass the tree
node list through the program unit.
Each executable statement will then append the appropriate tree node to the
list embodied in the chain.

@$@<Normal execution sequence@>==@{
CHAIN codechain: TreeNodeList;

SYMBOL xProgramUnit COMPUTE
  CHAINSTART HEAD.codechain=NEW(tree_node_list());
  SYNT.written=
    ORDER(
      MEMBER(
        THIS.suifproc,
        set_block(NEW(tree_proc(TAIL.codechain,THIS.suifscope)))),
      MEMBER(THIS.suifproc,write_proc(INCLUDING xSourceFile.file)));
END;
@}

After the chain has been completed, the resulting tree node list is
embodied in a procedure node, linked appropriately, and written to the
output file.

Suif has conditional an iteration nodes that require the controlled
statements to be subtrees.
FORTRAN, on the other hand, uses labels to provide that structure.
Therefore the current chain must be suspended at certain points and later
restored.
@{OuterCodeStack@} is used for this purpose.

@$@<Instantiate library modules@>+=@{
$/Adt/Stack.gnrc +instance=OuterCode +referto=TreeNodeList :inst
@}

@A@<Data Types and Constants@>

@B@<Data types@>

SUIF data types corresponding to FORTRAN data types are stored as properties
of those data types.
For each FORTRAN data type, SUIF uses three types in various contexts.
@{TgtType@} is the type of a value of the FORTRAN data type,
@{PtrTgtType@} is the type of a parameter of the FORTRAN data type, and
@{PtrArrTgtType@} is the type of a parameter array of the FORTRAN data type:

@$@<Data types@>==@{
TgtType: TypeNode;
PtrTgtType, PtrArrTgtType: TypeNode;
StructTgtType: StructType;
@}

SUIF type values are not available at compile time, so the properties of
the FORTRAN types must be initialized when the translator begins execution:

@$@<Primitive type property initialization@>==@{
{
@<Storage@>

ResetTgtType(IntegerType,FtnInt);
ResetTgtType(RealType,FtnReal);
ResetTgtType(DoublePrecisionType,FtnDble);
ResetTgtType(LogicalType,FtnLogic);

ResetPtrTgtType(IntegerType, NewType(ptr_type(FtnInt)));
ResetPtrTgtType(RealType, NewType(ptr_type(FtnReal)));
ResetPtrTgtType(DoublePrecisionType, NewType(ptr_type(FtnDble)));
ResetPtrTgtType(LogicalType, NewType(ptr_type(FtnLogic)));

ResetPtrArrTgtType(IntegerType, NewType(ptr_type(new array_type(FtnInt))));
ResetPtrArrTgtType(RealType, NewType(ptr_type(new array_type(FtnReal))));
ResetPtrArrTgtType(
  DoublePrecisionType,
  NewType(ptr_type(new array_type(FtnDble))));
ResetPtrArrTgtType(LogicalType, NewType(ptr_type(new array_type(FtnLogic))));

@<Construction of the COMPLEX data type@>
@<Construction of the CHARACTER data type@>
@<Construction of the data type for storage unit kind@>
}
@}

FORTRAN complex is represented by a SUIF array of two real values,
constructed during initialization:

@$@<Element type@>==@{
EleType, ElePtrType: TypeNode;
@}

@$@<Construction of the COMPLEX data type@>==@{
ResetTgtType(ComplexType, FtnComplex);
ResetPtrTgtType(ComplexType, NewType(ptr_type(FtnComplex)));
ResetPtrArrTgtType(ComplexType, NewType(ptr_type(new array_type(FtnComplex))));
ResetEleType(ComplexType, FtnComplexEle);
/*ResetElePtrType(ComplexType, NewType(ptr_type(FtnComplexEle)));*/
ResetElePtrType(ComplexType, GetPtrTgtType(RealType, type_error));
ResetStructTgtType(ComplexType, ComplexStruct);

ResetTgtType(DbComplexType, FtnDbComplex);
ResetPtrTgtType(DbComplexType, NewType(ptr_type(FtnDbComplex)));
ResetPtrArrTgtType(DbComplexType, 
    NewType(ptr_type(new array_type(FtnDbComplex))));
ResetEleType(DbComplexType, FtnDbComplexEle);
ResetElePtrType(DbComplexType, GetPtrTgtType(DoublePrecisionType, type_error));
ResetStructTgtType(DbComplexType, DoubleComplexStruct);
@}

@$@<Construction of the CHARACTER data type@>==@{
ResetTgtType(CharacterType, FtnChar);
ResetPtrTgtType(CharacterType, NewType(ptr_type(FtnChar)));
ResetPtrArrTgtType(CharacterType, NewType(ptr_type(new array_type(FtnChar))));
ResetEleType(CharacterType, FtnCharEle);
ResetElePtrType(CharacterType, NewType(ptr_type(FtnCharEle)));
@}

@$@<Construction of the data type for storage unit kind@>==@{
ResetTgtType(NumericUnitKey, FtnInt);
ResetTgtType(CharacterUnitKey, FtnCharEle);
@}

@C

The @{TgtType@} of a name gives the SUIF type used in the declaration of
the symbol corresponding to that name.
It is accessed via the name's @{ObjectKey@}:

@$@<Data Type of a Name@>+=@{
TgtType: TypeNode [Establish];
@}

There are three kinds of contexts in which @{TgtType@} can be determined:
a CALL statement, an array declarator, and all other occurrences of the
corresponding name.
@{TgtType@} is determined unambiguously in either of the first two, but the
third determines it only if it is the @/only@/ kind of context in which the
name occurs.
All contexts must be examined to ensure that @{TgtType@} has the correct
value:

@$@<Set the data type of a name@>+=@{
SYMBOL xProgramUnit COMPUTE
  SYNT.GotAllTgtTypes=CONSTITUENTS SymbolicName.GotTgtType;
END;
@}

The nonterminal @{xSubroutineNameUse@} represents the context of a symbolic
name in a CALL statement.
In this context the symbolic name must refer either to an external
subroutine or to a dummy parameter whose value is a reference to a
subroutine:

@$@<Set the data type of a name@>+=@{
SYMBOL xSubroutineNameUse COMPUTE
 INH.GotTgtType=
   ResetTgtType(
     THIS.ObjectKey,
     IF(InIS(DummyProcedure,GetKindSet(THIS.UnitKey,NullIS())),
       NewType(ptr_type(NEW(func_type(type_void)))),
       NewType(func_type(type_void))))
   <- (
     INCLUDING xProgramUnit.ClassificationDone,
     INCLUDING xProgramUnit.GotAllTypes,
     INCLUDING xProgramUnit.GotAllLengths);
END;
@}

Arrays can be declared in two contexts, DIMENSION statements and type
statements.
The name of the array is represented by the nonterminal @{xVariableName@}
in the former and by the nonterminal @{xEntityDecl@} in the latter.
In both contexts, however, the dimension information is represented by the
nonterminal @{xArraySpec@}.
The operation that sets the type is the same in either context, but must be
parameterized for the nonterminal representing the array name:

@$@<Set the data type of an array@>==@{
DimensionDeclarators.GotTgtType=
  ResetTgtType(
    DimensionDeclarators.ObjectKey,
    IF(InIS(DummyArgument,GetKindSet(DimensionDeclarators.UnitKey,NullIS())),
      GetPtrArrTgtType(GetType(DimensionDeclarators.UnitKey,NoKey),type_void),
      NewType(array_type(
        @<Target type for@>@(DimensionDeclarators@),
        array_bound(0),
        array_bound(SUB(atoi(StringTable(xArraySpec.SizeValue)),1))))))
  <- (
    INCLUDING xProgramUnit.ClassificationDone,
    INCLUDING xProgramUnit.GotAllTypes);
@}

Contexts other than CALL statements and array declarators may determine the
type of a symbolic name, but only if that name does not appear in a CALL or
array declarator.
This condition is met by using the definition table access function
@{Establish@}, which gives the specified property a value only if it does
not already have one.
Any value set by @{EstablishTgtType@} will be changed by @{ResetTgtType@}
(the operation used in the two contexts previously discussed), but a value
set by @{ResetTgtType@} will @/not@/ be changed by any subsequent
invocation of @{EstablishTgtType@}.
A value set by @{ResetTgtType@} would be changed by a subsequent
@{ResetTgtType@}, but a symbolic name cannot appear both in a CALL
statement and an array declarator if the program is correct.


@$@<Set the data type of a name@>+=@{
SYMBOL SymbolicName COMPUTE
  INH.GotTgtType=
   EstablishTgtType(THIS.ObjectKey,THIS.UnitKey)
   <- (
     INCLUDING xProgramUnit.ClassificationDone,
     INCLUDING xProgramUnit.GotAllTypes,
     INCLUDING xProgramUnit.GotAllLengths);
END;
@}

The symbol computation will be applied to all contexts in which a symbolic
name appears, unless it is overridden.
Since @{xSubroutineNameUse@} inherits from @{SymbolicName@} (that
inheritance is defined in the FORTRAN Semantic Analysis Specification Module,
which must be used with the module described here), its computation of
@{GotTgtType@} will override this one.
Also, the computation associated with an array declarator will override
because it is a rule computation.

@{EstablishTgtType@} uses the classification of the symbolic name and
information about its FORTRAN type to determine the appropriate SUIF type:

@$@<Data Type of a Name@>+=@{
void Establish(DefTableKey key, DefTableKey UnitKey)
{ if (key == NoKey) message(DEADLY, "Terminated", 1, NoPosition);
  if (!ACCESS) {
    IntSet kinds = GetKindSet(UnitKey,NullIS());
    TypeNode base = QualifiedType(UnitKey);

    if (InIS(ExternalFunction,kinds)) {
      VALUE = NewType(func_type(base));
    } else if (InIS(Subroutine,kinds)) {
      VALUE = NewType(func_type(type_void));
    } else if (InIS(DummyProcedure,kinds)) {
      VALUE = NewType(ptr_type(new func_type(base)));
    } else if (InIS(DummyArgument,kinds)) {
      VALUE = NewType(ptr_type(base));
    } else
      VALUE = base;
  }
}
@}

@B

Constant values are represented by SUIF @{operand@} values of the
appropriate type. Fortran COMPLEX type or CHARACTER type cannot be
represented by any of suif basic types, a variable is created to hold
these constant values.

@$@<Constants@>==@{
ATTR Datum: operand;

SYMBOL xUnsignedArithmeticConstant COMPUTE
  SYNT.Datum=operand();
END;

RULE: xUnsignedArithmeticConstant ::= xIcon
COMPUTE
  xUnsignedArithmeticConstant.Datum=
    ConstVal(GetTgtType(IntegerType,type_error),xIcon);
END;

RULE: xUnsignedArithmeticConstant ::= xRcon
COMPUTE
  xUnsignedArithmeticConstant.Datum=
    ConstVal(GetTgtType(RealType,type_error),atof(StringTable(xRcon)));
END;

RULE: xUnsignedArithmeticConstant ::= xDcon
COMPUTE
  xUnsignedArithmeticConstant.Datum=
    ConstVal(
      GetTgtType(DoublePrecisionType,type_error),
      atof(StringTable(xDcon)));
END;

RULE: xLogicalConstant ::= '.true.'
COMPUTE
  xLogicalConstant.Datum=
    ConstVal(GetTgtType(LogicalType,type_error),1);
END;

RULE: xLogicalConstant ::= '.false.'
COMPUTE
  xLogicalConstant.Datum=
    ConstVal(GetTgtType(LogicalType,type_error),0);
END;

@<COMPLEX Constant@>
@<CHARACTER Constant@>
@}

COMPLEX type is represented as a @{struct@} type with @{_r@} and @{_i@}
as the names of its two fields. A variable of COMPLEX type is created
for each COMPLEX constant, codes of assignment of these two fields
are also appended. Notice that the value of this so call COMPLEX constant
cannot be determined at compile time, code of assignment must be append
at proper place. 

@$@<COMPLEX Constant@>==@{
ATTR ComplexEleRef1: LdAddress;
ATTR ComplexEleRef2: LdAddress;
ATTR structType: StructType;

RULE: xUnsignedArithmeticConstant ::= xComplexConst
COMPUTE
    xUnsignedArithmeticConstant.Datum = xComplexConst.Datum;
END;

RULE: xComplexConst ::= '(' xExpr ',' xExpr ')'
COMPUTE
    .structType = GetStructTgtType(ComplexType, NoStructType);

    .temporary = MEMBER(INCLUDING xProgramUnit.suifscope,
                        new_unique_var(GetTgtType(ComplexType, type_error),
                                       "TComp"));

    .ComplexEleRef1 = ConstInstr(
        GetElePtrType(ComplexType, type_error),
        sym_addr(.temporary, MEMBER(.structType, 
            offset(MEMBER(.structType, find_field_by_name("_r"))))));

    .ComplexEleRef2 = ConstInstr(
        GetElePtrType(ComplexType, type_error),
        sym_addr(.temporary, MEMBER(.structType,
            offset(MEMBER(.structType, find_field_by_name("_i"))))));

    xExpr[2].codechain = ORDER(
        MEMBER(.ComplexEleRef1,
            append_annote(k_fields, NEW(immed_list(immed("_r"))))),
        AppendTreeNode(
            xExpr[1].codechain,
            Store(
                GetEleType(ComplexType, type_error),
                operand(.ComplexEleRef1),
                xExpr[1].Datum)));

    xComplexConst.codechain = ORDER(
        MEMBER(.ComplexEleRef2,
            append_annote(k_fields, NEW(immed_list(immed("_i"))))),
        AppendTreeNode(
            xExpr[2].codechain,
            Store(
                GetEleType(ComplexType, type_error),
                operand(.ComplexEleRef2),
                xExpr[2].Datum)));

    xComplexConst.Datum = operand(.temporary);
END;
@}

Attribute @{charvar@} holds the variable created for a character constant,
or for the result of concatenation in case of output.
Attribute @{lenDatum@}, of which type is SUIF @{operand@} class, holds
the computation of the character length. Only symbol @{xExpr@} of which 
@{TypeCode@} value is @{OilTypeCharacterType@} may have valid definition
of these two attributes.

@$@<CHARACTER Constant@>==@{
ATTR isBlankChar: int;
ATTR Ctype: TypeNode;
ATTR CVDef: VarDef;
ATTR ImList: ImmedList; 
ATTR charvar: VarSym;

SYMBOL xExpr COMPUTE
    SYNT.charvar = NoVarSym;
END;

RULE: xExpr ::= xScon
COMPUTE
    @<CHARACTER Constant setup@>@(xExpr@)
END;
@}

A suif array variable of @{type_char@} is created to hold the value of this
CHARACTER constant. This variable is initialized via suif @{Variable 
Definition@} and @{k_multi_init@} annotation. 
Since this variable, which holds the value of CHARACTER constant, won't be
in any COMMON or EQUIVALENCE storage sequence, and, in some cases, e.g. 
when a format identifier is a CHARACTER constant in Input/Output statements,
we need to treat this CHARACTER constant as a C character string which has
a null ending, this variable will also have a null ending.
 
@$@<CHARACTER Constant setup@>@(@1@)@M@{
    .isBlankChar = EQ(strlen(StringTable(xScon)), 0);

    .Ctype = IF(.isBlankChar,
        NoTypeNode,
        NewType(array_type(
                    FtnCharEle,
                    array_bound(0),
                    array_bound(strlen(StringTable(xScon))))));

    .temporary = IF(.isBlankChar,
        NoVarSym,
        MEMBER(INCLUDING xProgramUnit.suifscope,
                        new_unique_var(.Ctype, "TC")));

    .CVDef = IF(.isBlankChar,
        NoVarDef,
        MEMBER(INCLUDING xProgramUnit.suifscope,
                define_var(.temporary,MEMBER(FtnCharEle,size()))));

    .ImList = NEW(immed_list(immed(MEMBER(FtnCharEle,size()))));

    IF(NOT(.isBlankChar),
        ORDER(
            AppImmLst0(.ImList, StringTable(xScon)),
            MEMBER(.CVDef, append_annote(k_multi_init, .ImList))));

    @1.Datum = operand(.temporary);

    @1.charvar = .temporary;

    @1.lenDatum = ConstVal(type_signed, strlen(StringTable(xScon))); 
@}

@{AppImmLst(lst, str)@} is function that converts a C character string, and
append it to a suif @{immed_list@}.
@{AppImmLst(lst, str)@} has the same functionality except that it also appends
a zero to the end.

@$@<Append immed_list@>==@{
void 
#if defined(__cplusplus) || defined(__STDC__)
AppImmLst(immed_list *lst, char *str)
#else
AppImmLst(lst, str) immed_list *lst; char *str;
#endif
{
    if(strlen(str)==0 || lst==NULL)
        return;

    while(*str) 
        lst->append(new immed_list(immed(*str++)));

}

void
#if defined(__cplusplus) || defined(__STDC__)
AppImmLst0(immed_list *lst, char *str)
#else
AppImmLst0(lst, str) immed_list *lst; char *str;
#endif
{
    if(strlen(str)==0 || lst==NULL)
        return;

    while(*str)
        lst->append(new immed_list(immed(*str++)));

    lst->append(new immed_list(immed(*str)));
}

@}

@$@<Append immed_list interface@>==@{
void 
#if defined(__cplusplus) || defined(__STDC__)
AppImmLst(immed_list *lst, char *str);
#else
AppImmLst();
#endif

void
#if defined(__cplusplus) || defined(__STDC__)
AppImmLst0(immed_list *lst, char *str);
#else
AppImmLst0();
#endif

@}

@B@<Character Type@>

A character datum is a string of characters.
The length of the character datum is the number of characters in the
string.
A character datum has one character storage unit for in a storage sequence
for each character of the string.

Each character datum is represented in Suif as an object of an array type
with a number of elements equal to its length.
This means that the type of a character datum is not simply the @{TgtType@}
property of its FORTRAN data type, but a type constructed from that type
and its length.
The function @{QualifiedType@} is used to unify access to the type of any
object.
That function may only be invoked when all type and length information is
available for unit keys:

@$@<Target type for@>@(@1@)@M@{
QualifiedType(@1.UnitKey) <- INCLUDING xProgramUnit.GotAllLengths
@}

@$@<Translation functions@>+=@{
TypeNode
#ifdef PROTO_OK
QualifiedType(DefTableKey UnitKey)
#else
QualifiedType(UnitKey) DefTableKey UnitKey;
#endif
{ int length;
  DefTableKey ftntype = GetType(UnitKey,ErrorType);

  if (ftntype != CharacterType) return GetTgtType(ftntype, type_error);

  length = GetLength(UnitKey,0);
  if (length == 0)
    message(DEADLY,"Character length missing",0,NoPosition);

  return
    NewType(array_type(
    FtnCharEle,
    array_bound(0),
    array_bound(strtol(StringTable(length)) - 1)));
}
@}

@$@<Translation function interfaces@>+=@{
extern TypeNode QualifiedType ELI_ARG((DefTableKey UnitKey));
@}

@A

@$@<Arrays and Substrings@>==@{
@<Array Declarator@>
@<Array Element Name@>
@<Subscript@>
@<Character Substring@>
@}

@B

@$@<Array Declarator@>+=@{
ATTR elemtype: TypeNode;
ATTR arraysym: VarSym;

SYMBOL xArraySpec INHERITS IndexList END;

RULE: DimensionDeclarators ::= xArraySpec
COMPUTE
  .gotarrayinstr=
    ResetArrayInstr(DimensionDeclarators.ObjectKey,xArraySpec.ArrayRef);
  @<Set the data type of an array@>
  xArraySpec.ArrayInstruction=
    NEW(in_array(
      GetPtrTgtType(GetType(DimensionDeclarators.UnitKey,NoKey),type_void),
      operand(),
      IF(InIS(DummyArgument,GetKindSet(DimensionDeclarators.UnitKey,NullIS())),
        operand(GetVariable(DimensionDeclarators.ObjectKey,NoVarSym)),
        ConstVal(
          NewType(ptr_type(
            GetTgtType(DimensionDeclarators.ObjectKey,type_error))),
          GetVariable(DimensionDeclarators.ObjectKey,NoVarSym))),
      MEMBER(GetTgtType(DimensionDeclarators.UnitKey,type_error),size()),
      GetNumberOfDims(DimensionDeclarators.UnitKey,1),
      0,
      xArraySpec.Offset))
    <- (INCLUDING xProgramUnit.GotAllTgtTypes, DimensionDeclarators.havedef);
END;
@}

@$@<Array Declarator@>+=@{
SYMBOL xArraySpec:
  Offset, Multiplier: operand;

RULE: xArraySpec ::=  '*'
COMPUTE
  .setbound=
    MEMBER(
      xArraySpec.ArrayInstruction,
      set_bound(xArraySpec.SuifIndex,operand()));
  xArraySpec.Offset=ConstVal(GetTgtType(IntegerType,type_error),1);
  xArraySpec.Multiplier=operand();
  xArraySpec.ArrayRef=
    xArraySpec.ArrayInstruction <- .setbound;
END;

RULE: xArraySpec ::=  xLowerBound ':' '*'
COMPUTE
  .setbound=
    MEMBER(
      xArraySpec.ArrayInstruction,
      set_bound(xArraySpec.SuifIndex,operand()));
  xArraySpec.Offset=xLowerBound.Datum;
  xArraySpec.Multiplier=operand();
  xArraySpec.ArrayRef=
    xArraySpec.ArrayInstruction <- .setbound;
END;

RULE: xArraySpec ::=  xExplicitShapeSpec
COMPUTE
  .setbound=
    MEMBER(
      xArraySpec.ArrayInstruction,
      set_bound(
        xArraySpec.SuifIndex,
        operand(xExplicitShapeSpec.ElementCount)));
  xArraySpec.Offset=xExplicitShapeSpec.Lower;
  xArraySpec.Multiplier=operand(xExplicitShapeSpec.ElementCount);
  xArraySpec.ArrayRef=
    xArraySpec.ArrayInstruction <- .setbound;
END;

RULE: xArraySpec ::=  xArraySpec ',' '*'
COMPUTE
  .setbound=
    MEMBER(
      xArraySpec[1].ArrayInstruction,
      set_bound(xArraySpec[1].SuifIndex,operand()));
  xArraySpec[1].ArrayRef=xArraySpec[2].ArrayRef;
  xArraySpec[1].Offset=
    Dyadic(
      io_add,
      GetTgtType(IntegerType,type_error),
      xArraySpec[2].Offset,
      xArraySpec[2].Multiplier);
  xArraySpec[1].Multiplier=operand();
  xArraySpec[2].ArrayInstruction=
    xArraySpec[1].ArrayInstruction <- .setbound;
  xArraySpec[2].SuifIndex=ADD(xArraySpec[1].SuifIndex,1);
END;

RULE: xArraySpec ::=  xArraySpec ',' xLowerBound ':' '*'
COMPUTE
  .setbound=
    MEMBER(
      xArraySpec[1].ArrayInstruction,
      set_bound(xArraySpec[1].SuifIndex,operand()));
  xArraySpec[1].ArrayRef=xArraySpec[2].ArrayRef;
  xArraySpec[1].Offset=
    Dyadic(
      io_add,
      GetTgtType(IntegerType,type_error),
      xArraySpec[2].Offset,
      Dyadic(
        io_mul,
        GetTgtType(IntegerType,type_error),
        xLowerBound.Datum,
        xArraySpec[2].Multiplier));
  xArraySpec[1].Multiplier=operand();
  xArraySpec[2].ArrayInstruction=
    xArraySpec[1].ArrayInstruction <- .setbound;
  xArraySpec[2].SuifIndex=ADD(xArraySpec[1].SuifIndex,1);
END;

RULE: xArraySpec ::=  xArraySpec ',' xExplicitShapeSpec
COMPUTE
  .setbound=
    MEMBER(
      xArraySpec[1].ArrayInstruction,
      set_bound(
        xArraySpec[1].SuifIndex,
        operand(xExplicitShapeSpec.ElementCount)));
  xArraySpec[1].ArrayRef=xArraySpec[2].ArrayRef;
  xArraySpec[1].Offset=
    Dyadic(
      io_add,
      GetTgtType(IntegerType,type_error),
      xArraySpec[2].Offset,
      Dyadic(
        io_mul,
        GetTgtType(IntegerType,type_error),
        xExplicitShapeSpec.Lower,
        xArraySpec[2].Multiplier));
  xArraySpec[1].Multiplier=
    Dyadic(
      io_mul,
      GetTgtType(IntegerType,type_error),
      xArraySpec[2].Multiplier,
      operand(xExplicitShapeSpec.ElementCount));
  xArraySpec[2].ArrayInstruction=
    xArraySpec[1].ArrayInstruction <- .setbound;
  xArraySpec[2].SuifIndex=ADD(xArraySpec[1].SuifIndex,1);
END;

SYMBOL xExplicitShapeSpec:
  Lower, ElementCount: operand;

RULE: xExplicitShapeSpec ::=  xLowerBound ':' xUpperBound
COMPUTE
  xExplicitShapeSpec.Lower=xLowerBound.Datum;
  xExplicitShapeSpec.ElementCount=
    Dyadic(
      io_add,
      GetTgtType(IntegerType,type_error),
      Dyadic(
        io_sub,
        GetTgtType(IntegerType,type_error),
        xUpperBound.Datum,
        xLowerBound.Datum),
      ConstVal(GetTgtType(IntegerType,type_error),1));
END;

RULE: xExplicitShapeSpec ::=  xUpperBound
COMPUTE
  xExplicitShapeSpec.Lower=ConstVal(GetTgtType(IntegerType,type_error),1);
  xExplicitShapeSpec.ElementCount=xUpperBound.Datum;
END;
@}

@B

@$@<Array Element Name@>==@{
ATTR ArrayInstruction, ArrayRef: Index;
ATTR ElementType: TypeNode;

RULE: xStmt ::=  xLblDef xName '(' xExprList ')' '=' xExpr xEOS
COMPUTE
  @<Establish array instruction@>@(xName@,xExprList@)
END;

RULE: xStmt ::=  xLblDef xName '(' xExprList ')' xSubstringRange '=' xExpr xEOS
COMPUTE
  @<Establish array instruction@>@(xName@,xExprList@)
END;

RULE: xStmt ::=  xLblDef xName xStmtFunctionRange
COMPUTE
  @<Establish array instruction@>@(xName@,xStmtFunctionRange@)
END;

RULE: xStmtFunctionRange ::=  '(' ')' '=' xExpr xEOS
COMPUTE
  xStmtFunctionRange.indexdone=0;
  xStmtFunctionRange.SeqCount=0;
END;

RULE: xStmtFunctionRange ::=  '(' xSFDummyArgNameList ')' '=' xExpr xEOS
COMPUTE
  xStmtFunctionRange.indexdone=xSFDummyArgNameList.indexdone;
  xStmtFunctionRange.SeqCount=xSFDummyArgNameList.SeqCount;
  xSFDummyArgNameList.ArrayInstruction=xStmtFunctionRange.ArrayInstruction;
END;

RULE: xComplexDataRef ::=  xName '(' xSectionSubscriptList ')'
COMPUTE
  @<Establish array instruction@>@(xName@,xSectionSubscriptList@)
  xComplexDataRef.ArrayRef=
    xSectionSubscriptList.ArrayInstruction
    <- xSectionSubscriptList.indexdone;
END;

RULE: xArrayElement ::=  xVariableName '(' xSectionSubscriptList ')'
COMPUTE
  @<Establish array instruction@>@(xVariableName@,xSectionSubscriptList@)
  xArrayElement.ArrayRef = xSectionSubscriptList.ArrayInstruction;
END;
@}

@$@<Establish array instruction@>@(@2@)@M@{
@2.ArrayInstruction=
  CloneArrayInstr(@1.ObjectKey,INCLUDING xProgramUnit.suifscope,NoIndex)
  <- @1.codechain;
@}

@B

Suif assumes that all arrays are stored in row-major order.
Since FORTRAN subscript calculations assume that arrays are stored in
column-major order, the translation must reverse the order of the
subscripts.
This is easily done because subscript indexing is explicit when the
subscript expressions are added to a Suif array instruction.
The @{SuifIndex@} attribute is computed for all lists that could be
subscript lists, and used to place the subscript appropriately.

@$@<Subscript@>==@{
ATTR SuifIndex: int;

SYMBOL IndexList COMPUTE
  INH.SuifIndex=0;
END;

SYMBOL xExprList INHERITS IndexList END;

RULE: xExprList ::=  xExpr
COMPUTE
  xExprList.indexdone=
    IF(NE(xExprList.ArrayInstruction,NoIndex),
      MEMBER(
        xExprList.ArrayInstruction,
        set_index(xExprList.SuifIndex,xExpr.Datum)));
END;

RULE: xExprList ::=  xExprList ',' xSectionSubscript
COMPUTE
  xExprList[1].indexdone=
    IF(NE(xExprList[1].ArrayInstruction,NoIndex),
      MEMBER(
        xExprList[1].ArrayInstruction,
        set_index(xExprList[1].SuifIndex,xSectionSubscript.Datum)));
  xExprList[2].SuifIndex=ADD(xExprList[1].SuifIndex,1);
  xExprList[2].ArrayInstruction=xExprList[1].ArrayInstruction;
END;

RULE: xExprList ::=  xSFDummyArgNameList ',' xExpr
COMPUTE
  xExprList.indexdone=
    IF(NE(xExprList.ArrayInstruction,NoIndex),
      MEMBER(
        xExprList.ArrayInstruction,
        set_index(xExprList.SuifIndex,xExpr.Datum)));
  xSFDummyArgNameList.SuifIndex=ADD(xExprList.SuifIndex,1);
  xSFDummyArgNameList.ArrayInstruction=xExprList.ArrayInstruction;
END;

SYMBOL xSFDummyArgNameList INHERITS IndexList END;

RULE: xSFDummyArgNameList ::=  xSFDummyArgName
COMPUTE
  xSFDummyArgNameList.indexdone=
    IF(NE(xSFDummyArgNameList.ArrayInstruction,NoIndex),
      MEMBER(
        xSFDummyArgNameList.ArrayInstruction,
        set_index(
          xSFDummyArgNameList.SuifIndex,
          operand(@<Variable symbol@>@(xSFDummyArgName@)))));
END;

RULE: xSFDummyArgNameList ::=  xSFDummyArgNameList ',' xSFDummyArgName
COMPUTE
  xSFDummyArgNameList[1].indexdone=
    IF(NE(xSFDummyArgNameList[1].ArrayInstruction,NoIndex),
      MEMBER(
        xSFDummyArgNameList[1].ArrayInstruction,
        set_index(
          xSFDummyArgNameList[1].SuifIndex,
          operand(@<Variable symbol@>@(xSFDummyArgName@)))));
  xSFDummyArgNameList[2].SuifIndex=ADD(xSFDummyArgNameList[1].SuifIndex,1);
  xSFDummyArgNameList[2].ArrayInstruction=
    xSFDummyArgNameList[1].ArrayInstruction;
END;

SYMBOL xSectionSubscriptList INHERITS IndexList END;

RULE: xSectionSubscriptList ::=  xSectionSubscript
COMPUTE
  xSectionSubscriptList.indexdone=
    IF(NE(xSectionSubscriptList.ArrayInstruction,NoIndex),
      MEMBER(
        xSectionSubscriptList.ArrayInstruction,
        set_index(xSectionSubscriptList.SuifIndex,xSectionSubscript.Datum)));
END;

RULE: xSectionSubscriptList ::=  xSectionSubscriptList ',' xSectionSubscript
COMPUTE
  xSectionSubscriptList[1].indexdone=
    IF(NE(xSectionSubscriptList[1].ArrayInstruction,NoIndex),
      MEMBER(
        xSectionSubscriptList[1].ArrayInstruction,
        set_index(xSectionSubscriptList[1].SuifIndex,xSectionSubscript.Datum)));
  xSectionSubscriptList[2].SuifIndex=ADD(xSectionSubscriptList[1].SuifIndex,1);
  xSectionSubscriptList[2].ArrayInstruction=
    xSectionSubscriptList[1].ArrayInstruction;
END;
@}

@B

@$@<Character Substring@>==@{
RULE: xComplexDataRef ::=  xComplexDataRef '(' xSectionSubscriptList ')'
COMPUTE
  xSectionSubscriptList.ArrayInstruction=NoIndex;
  xComplexDataRef[1].ArrayRef=NoIndex;
END;

RULE: xExprList ::=  ':'
COMPUTE
  xExprList.indexdone=0;
END;

RULE: xExprList ::=  ':' xExpr
COMPUTE
  xExprList.indexdone=0;
END;

RULE: xExprList ::=  xExpr ':'
COMPUTE
  xExprList.indexdone=0;
END;

RULE: xExprList ::=  xExpr ':' xExpr
COMPUTE
  xExprList.indexdone=0;
END;

RULE: xExprList ::=  xSFDummyArgNameList ',' ':'
COMPUTE
  xExprList.indexdone=xSFDummyArgNameList.indexdone;
  xSFDummyArgNameList.ArrayInstruction=xExprList.ArrayInstruction;
END;

RULE: xExprList ::=  xSFDummyArgNameList ',' ':' xExpr
COMPUTE
  xExprList.indexdone=xSFDummyArgNameList.indexdone;
  xSFDummyArgNameList.ArrayInstruction=xExprList.ArrayInstruction;
END;

RULE: xExprList ::=  xSFDummyArgNameList ',' xExpr ':'
COMPUTE
  xExprList.indexdone=xSFDummyArgNameList.indexdone;
  xSFDummyArgNameList.ArrayInstruction=xExprList.ArrayInstruction;
END;

RULE: xExprList ::=  xSFDummyArgNameList ',' xExpr ':' xExpr
COMPUTE
  xExprList.indexdone=xSFDummyArgNameList.indexdone;
  xSFDummyArgNameList.ArrayInstruction=xExprList.ArrayInstruction;
END;
@}

@A

An expression is a construct that yields a value.
FORTRAN has no concept of an address, and thus makes no formal distinction
between a variable and the content of that variable.
The interpretation depends on context: a variable or array element denotes
an address when it appears on the left side of an assignment, as a
DO-variable, or as an argument.
In all other cases it denotes a value stored at the address.

Because of this context-dependence, each expression node is provided with
both an ``address'' translation and a ``content'' translation.
The types of values resulting from these two interpretations are also
given:

@$@<Expressions@>+=@{
SYMBOL Expression:
  Address: Instruction, Atype: TypeNode,
  Datum: operand, Dtype: TypeNode;

SYMBOL Expression COMPUTE
  SYNT.Address=NoInstruction; SYNT.Atype=type_void;
  SYNT.Datum=operand(); SYNT.Dtype=type_void;
END;
@}

The symbol computations for @{Expression@} are intended to define the
specified attributes in those cases where their values are unknown.
These computations are overridden in specific contexts where known values
are available.

@{xExpr@} represents a general expression independent of context.
The attribute @{TypeCode@} of @{xExpr@} is given a value of type
@{tOilType@} by the expression analysis module.
@{OilTypeName(xExpr.TypeCode)@} gives the FORTRAN type of the expression as
a definition table key.

@$@<Expressions@>+=@{
SYMBOL xExpr INHERITS Expression COMPUTE
  SYNT.Atype=GetPtrTgtType(OilTypeName(THIS.TypeCode),type_error);
  SYNT.Dtype=GetTgtType(OilTypeName(THIS.TypeCode),type_error);
END;
@}

Expressions appear in several different contexts that are distinguished by
the use of distinct symbols.
These symbols are connected to @{xExpr@} by means of chain productions.

@$@<Expressions@>+=@{
@<Symbol chained to an expression@>@(xArg@)
@<Symbol chained to an expression@>@(xSectionSubscript@)
@<Symbol chained to an expression@>@(xSubscript@)
@<Symbol chained to an expression@>@(xLowerBound@)
@<Symbol chained to an expression@>@(xUpperBound@)
@}

@$@<Symbol chained to an expression@>@(@1@)@M@{
SYMBOL @1 INHERITS Expression END;

RULE: @1 ::=  xExpr
COMPUTE
  @1.Atype=xExpr.Atype;
  @1.Address=xExpr.Address;
  @1.Dtype=xExpr.Dtype;
  @1.Datum=xExpr.Datum;
  /*@1.Value=xExpr.Value;*/
END;
@}

@B@<Primaries@>

Four primaries are described in this section: symbolic constant names,
variable references, array element references, and function references.
FORTRAN does not syntactically distinguish symbolic constant names from
variable references, nor does it syntactically distinguish array element
references from function references.
These distinctions must be made on the basis of semantic information
deduced during symbol analysis.
The different primaries result in expressions with different
characteristics:

@$@<Expressions@>+=@{
ATTR varsym: VarSym;

RULE: xExpr ::= xName
COMPUTE
  .varsym=
    GetVariable(xName.ObjectKey,NoVarSym) <- xName.havedef;
  xExpr.Address=
    IF(xExpr.Value,
      NoInstruction,
      IF(InIS(DummyArgument,GetKindSet(xName.UnitKey,NullIS())),
        NEW(in_rrr(io_lod,xExpr.Atype,operand(),.varsym,operand())),
        ConstInstr(xExpr.Atype,.varsym)));
  xExpr.Datum=
    IF(xExpr.Value,
        IF(EQ(xExpr.TypeCode,OilTypeIntegerType),
          ConstVal(xExpr.Dtype,atoi(StringTable(xExpr.Value))),
          ConstVal(xExpr.Dtype,atof(StringTable(xExpr.Value)))),
      IF(InIS(DummyArgument,GetKindSet(xName.UnitKey,NullIS())),
        Monadic(io_lod,xExpr.Dtype,operand(.varsym)),
        operand(.varsym)));
END;

RULE: xExpr ::=  xComplexDataRef
COMPUTE
  xExpr.Address=xComplexDataRef.ArrayRef;
  xExpr.Datum=
    IF(xComplexDataRef.ProcedureRef,
      operand(xComplexDataRef.ProcedureRef),
    IF(xComplexDataRef.ArrayRef,
      Monadic(io_lod,xExpr.Dtype,xComplexDataRef.ArrayRef),
      ConstVal(GetTgtType(IntegerType,type_error),0)));
END;
@}

@B@<Expressions with Operators@>

All of the operators are represented by definition table keys, which are
obtained from the @{tOilOp@} values resulting from operator identification.
The properties associated with these keys determine the function used to
create the proper target tree node, as well as any additional information
needed for its construction.
Each expression node has a @{Datum@} attribute that holds the target
subtree representing the translation of the subtree rooted in that node:

@$@<Expressions@>+=@{
ATTR TgtOp: DefTableKey;

SYMBOL OpNode COMPUTE
  SYNT.TgtOp=IF(OilIsValidOp(THIS.Operator),OilOpName(THIS.Operator),NoKey);
END;
@}

Translation of an operator is carried out by a function specific to the
operator, which gathers information from the definition table keys
associated with the operator and its result type.
It then applies this information to create a target tree fragment whose
frontier consists of the operator's operands.

Pointers to the translation functions are stored
as properties of the operators:

@$@<Translation function properties@>+=@{
UnOpMap: MapUnOpFn;
BinOpMap: MapBinOpFn;
OpCode: if_ops;
@}

Translation functions for monadic and dyadic operators have different
numbers of operands and hence different types, so two properties must be
available.
A particular operator has either the @{UnOpMap@} property or the
@{BinOpMap@} property but not both.
The @{OpCode@} property is used to distinguish operators that use the same
translation function.

@$@<Translation function interfaces@>+=@{
typedef operand (*MapUnOpFn) ELI_ARG((DefTableKey,DefTableKey,operand));
typedef operand (*MapBinOpFn) \
    ELI_ARG((DefTableKey,DefTableKey,operand,operand));
@}

@$@<Translation function interfaces@>+=@{
extern operand NoUnOpMap ELI_ARG((DefTableKey,DefTableKey,operand));
extern operand NoBinOpMap ELI_ARG((DefTableKey,DefTableKey,operand,operand));
extern operand MapIdentity ELI_ARG((DefTableKey,DefTableKey,operand));
extern operand MapUnOp ELI_ARG((DefTableKey,DefTableKey,operand));
extern operand MapBinOp ELI_ARG((DefTableKey,DefTableKey,operand,operand));
extern operand MapReverse ELI_ARG((DefTableKey,DefTableKey,operand,operand));
@}

@$@<Translation functions@>+=@{
operand
#if defined(__cplusplus) || defined(__STDC__)
NoUnOpMap(DefTableKey k, DefTableKey r, operand d)
#else
NoUnOpMap(k, r, d) DefTableKey k, r; operand d;
#endif
{ return operand(); }

operand
#if defined(__cplusplus) || defined(__STDC__)
MapIdentity(DefTableKey k, DefTableKey r, operand d)
#else
MapIdentity(k, d) DefTableKey k; DefTableKey r; operand d;
#endif
{ return d; }

operand
#if defined(__cplusplus) || defined(__STDC__)
MapUnOp(DefTableKey k, DefTableKey r, operand d)
#else
MapUnOp(k, d) DefTableKey k; DefTableKey r; operand d;
#endif
{ return Monadic(GetOpCode(k, io_nop),GetTgtType(r, type_error),d); }

operand
#if defined(__cplusplus) || defined(__STDC__)
NoBinOpMap(DefTableKey k, DefTableKey r, operand dl, operand dr)
#else
NoBinOpMap(k, r, dl, dr) DefTableKey k, r; operand dl, dr;
#endif
{ return operand(); }

operand
#if defined(__cplusplus) || defined(__STDC__)
MapBinOp(DefTableKey k, DefTableKey r, operand dl, operand dr)
#else
MapBinOp(k, r, dl, dr) DefTableKey k, r; operand dl, dr;
#endif
{ return Dyadic(GetOpCode(k, io_nop),GetTgtType(r, type_error),dl,dr); }

operand
#if defined(__cplusplus) || defined(__STDC__)
MapReverse(DefTableKey k, DefTableKey r, operand dl, operand dr)
#else
MapReverse(k, r, dl, dr) DefTableKey k, r; operand dl, dr;
#endif
{ return Dyadic(GetOpCode(k, io_nop),GetTgtType(r, type_error),dr,dl); }
@}

Each of the next four subsections deals with one of the four distinct
kinds of expression used in FORTRAN,
defining the implementation of operators that can be used in the expression
and the representation of literal constants (if applicable).

@B@<Arithmetic Expressions@>

Operator identification has refined the five FORTRAN operator indications
used in arithmetic expressions on the basis of the rules given
in Tables 2 and 3.
The result is thirty-six distinct operators, each performing one of the
five operations on an appropriate set of operands.
Each operator may be translated in a different way.

@C@<Division@>

Division is implemented
for integer, real and double-precision operands
by the Suif @{div@} instruction:

@$@<Arithmetic Expressions@>+=@{
iDiv -> BinOpMap={MapBinOp}, OpCode={io_div};
rDiv -> BinOpMap={MapBinOp}, OpCode={io_div};
dDiv -> BinOpMap={MapBinOp}, OpCode={io_div};
@}

The Suif @{div@} instruction is defined as having the same semantics as the
C division operator, but the semantics of FORTRAN integer division differ
from those of C integer division.
In FORTRAN, integer division yields the integer whose magnitude is not
greater than the magnitude of the mathematical quotient and whose sign is
the same as the sign of the mathematical quotient.
Thus FORTRAN integer division always rounds the quotient towards 0.
In C, the choice of rounding is left to the implementor if either operand
is negative.
Practically, this means that C integer division will be implemented by the
hardware divide instruction, which usually rounds towards negative infinity
on sign-magnitude and radix complement machines, and towards 0 on
diminished-radix complement machines.

Since C integer division would be correctly implemented by the FORTRAN
semantics, the ultimate translation to the target machine shouild reflect
the FORTRAN semantics whenever any component of the Suif program has been
derived from FORTRAN source code.

@C@<Multiplication, Subtraction and Addition@>

Each of these operations is implemented
for integer, real and double-precision operands
by the corresponding three-operand Suif instruction:

@$@<Arithmetic Expressions@>+=@{
iMul -> BinOpMap={MapBinOp}, OpCode={io_mul};
rMul -> BinOpMap={MapBinOp}, OpCode={io_mul};
dMul -> BinOpMap={MapBinOp}, OpCode={io_mul};
iSub -> BinOpMap={MapBinOp}, OpCode={io_sub};
rSub -> BinOpMap={MapBinOp}, OpCode={io_sub};
dSub -> BinOpMap={MapBinOp}, OpCode={io_sub};
iAdd -> BinOpMap={MapBinOp}, OpCode={io_add};
rAdd -> BinOpMap={MapBinOp}, OpCode={io_add};
dAdd -> BinOpMap={MapBinOp}, OpCode={io_add};
@}

@C@<Negation@>

Negation is implemented
for integer, real and double-precision operands
by the Suif @{neg@} instruction:

@$@<Arithmetic Expressions@>+=@{
iNeg -> UnOpMap={MapUnOp}, OpCode={io_neg};
rNeg -> UnOpMap={MapUnOp}, OpCode={io_neg};
dNeg -> UnOpMap={MapUnOp}, OpCode={io_neg};
@}

@C@<Identity@>

Identity yields the value of its operand unchanged, so the identity
operator simply vanishes:

@$@<Arithmetic Expressions@>+=@{
iIdn -> UnOpMap={MapIdentity};
rIdn -> UnOpMap={MapIdentity};
dIdn -> UnOpMap={MapIdentity};
cIdn -> UnOpMap={MapIdentity};
@}

@C@<Type conversions@>

Each of these operations is implemented
by the Suif @{cvt@} instruction:

@$@<Arithmetic Expressions@>+=@{
cREAL -> UnOpMap={MapUnOp}, OpCode={io_cvt};
cDBLE -> UnOpMap={MapUnOp}, OpCode={io_cvt};
@}

The following procedure decomposes the coercion sequence for a particular
context into the individual operations:

@$@<Translation functions@>+=@{
operand
#if defined(__cplusplus) || defined(__STDC__)
MapCoercion(tOilType need, tOilType have, operand d)
#else
MapCoercion(need, have, d) tOilType need, have; operand d;
#endif
{tOilCoercionSeq seq = OilCoerce(have, need);

  if(need == OilTypeComplexType)
    return d;

  while (!OilEmptyCS(seq)) {
    DefTableKey TgtOp = OilOpName(OilHeadCS(seq));
    d =
      (*GetUnOpMap(TgtOp,NoUnOpMap))(
        TgtOp,
        OilTypeName(OilGetArgType(OilHeadCS(seq), 0)),
        d);
    seq = OilTailCS(seq);
  }

  return d;
}
@}

@$@<Translation function interfaces@>+=@{
extern operand MapCoercion ELI_ARG((tOilType, tOilType, operand));
@}

@C

@$@<Arithmetic primaries@>==@{
RULE: xExpr ::= xIcon
COMPUTE
  xExpr.Datum=ConstVal(GetTgtType(IntegerType,type_error),xIcon);
END;

RULE: xExpr ::= xUnsignedArithmeticConstant
COMPUTE
  xExpr.Datum=xUnsignedArithmeticConstant.Datum;
END;

RULE: xExpr ::= xUnOp xExpr
COMPUTE
  xExpr[1].Datum=IF(EQ(xExpr[1].TypeCode, OilTypeComplexType),
    operand(xExpr[1].tempcomp),
    APPLY(
      GetUnOpMap(xUnOp.TgtOp,NoUnOpMap),
      xUnOp.TgtOp,
      OilTypeName(xExpr[1].TypeCode),
      xExpr[2].Datum));
END;

RULE: xExpr ::= xExpr xBinOp xExpr
COMPUTE
  xExpr[1].Datum=IF(EQ(xExpr[1].TypeCode, OilTypeComplexType),
    operand(xExpr[1].tempcomp),
    APPLY(
      GetBinOpMap(xBinOp.TgtOp,NoBinOpMap),
      xBinOp.TgtOp,
      OilTypeName(xExpr[1].TypeCode),
      MapCoercion(
        OilGetArgType(xBinOp.Operator,1),
        xExpr[2].TypeCode,
        xExpr[2].Datum),
      MapCoercion(
        OilGetArgType(xBinOp.Operator,2),
        xExpr[3].TypeCode,
        xExpr[3].Datum)));
END;
@}

@B

@$@<Relational Expressions@>+=@{
iLss -> BinOpMap={MapBinOp}, OpCode={io_sl};
rLss -> BinOpMap={MapBinOp}, OpCode={io_sl};
dLss -> BinOpMap={MapBinOp}, OpCode={io_sl};
iLeq -> BinOpMap={MapBinOp}, OpCode={io_sle};
rLeq -> BinOpMap={MapBinOp}, OpCode={io_sle};
dLeq -> BinOpMap={MapBinOp}, OpCode={io_sle};
iEql -> BinOpMap={MapBinOp}, OpCode={io_seq};
rEql -> BinOpMap={MapBinOp}, OpCode={io_seq};
dEql -> BinOpMap={MapBinOp}, OpCode={io_seq};
iNeq -> BinOpMap={MapBinOp}, OpCode={io_sne};
rNeq -> BinOpMap={MapBinOp}, OpCode={io_sne};
dNeq -> BinOpMap={MapBinOp}, OpCode={io_sne};
iGtr -> BinOpMap={MapReverse}, OpCode={io_sl};
rGtr -> BinOpMap={MapReverse}, OpCode={io_sl};
dGtr -> BinOpMap={MapReverse}, OpCode={io_sl};
iGeq -> BinOpMap={MapReverse}, OpCode={io_sle};
rGeq -> BinOpMap={MapReverse}, OpCode={io_sle};
dGeq -> BinOpMap={MapReverse}, OpCode={io_sle};
@}

@B

@$@<Logical Expressions@>+=@{
lAnd -> BinOpMap={MapBinOp}, OpCode={io_and};
lOr  -> BinOpMap={MapBinOp}, OpCode={io_and};
lEqv -> BinOpMap={MapBinOp}, OpCode={io_seq};
lNeq -> BinOpMap={MapBinOp}, OpCode={io_xor};
@}

@$@<Logical primaries@>==@{
RULE: xExpr ::= xLogicalConstant
COMPUTE
  xExpr.Datum=xLogicalConstant.Datum;
END;
@}

@B

@$@<Constant Expressions@>==@{
SYMBOL Expression: Value: int;

SYMBOL Expression COMPUTE
  SYNT.Value=0;
END;
@}

@B
Since COMPLEX type is not supported by basic SUIF type, COMPLEX arithimetic
expression is implemented differently and seperately from basic arithmetic 
expression.
Normally, for each Eli symobl @{xExpr@} a temporary variable of COMPLEX type
will be created in all COMPLEX arithmetic expression when neceassary.

@$@<COMPLEX Arithmetic Expression@>+=@{
ATTR tempcomp: VarSym;

SYMBOL xExpr COMPUTE
    SYNT.tempcomp = NoVarSym;
END;

RULE: xExpr ::= xName
COMPUTE
    xExpr.tempcomp = IF(EQ(xExpr.TypeCode, OilTypeComplexType),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        NoVarSym);

    xExpr.codechain = IF(EQ(xExpr.TypeCode, OilTypeComplexType),
        AppendTreeNode(
            xExpr.codechain,
            Copy(
                GetTgtType(ComplexType, type_error),
                operand(xExpr.tempcomp),
                xExpr.Datum)),
        xExpr.codechain);
END;

RULE: xExpr ::=  xComplexDataRef
COMPUTE
    xExpr.tempcomp = IF(EQ(xExpr.TypeCode, OilTypeComplexType),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        NoVarSym);

    xExpr.codechain = IF(EQ(xExpr.TypeCode, OilTypeComplexType),
        AppendTreeNode(
            xExpr.codechain,
            Copy(
                GetTgtType(ComplexType, type_error),
                operand(xExpr.tempcomp),
                xExpr.Datum)),
        xExpr.codechain);
END;

RULE: xExpr ::= xUnsignedArithmeticConstant
COMPUTE
    xExpr.tempcomp = IF(EQ(xExpr.TypeCode, OilTypeComplexType),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        NoVarSym);

    xExpr.codechain = IF(EQ(xExpr.TypeCode, OilTypeComplexType),
        AppendTreeNode(
            xUnsignedArithmeticConstant.codechain,
            Copy(
                GetTgtType(ComplexType, type_error),
                operand(xExpr.tempcomp),
                xExpr.Datum)),
        xExpr.codechain);

END;
@}


@$@<Translation function properties@>+=@{
CompUnArApp: AppCompUnArFn;
CompBinArApp: AppCompBinArFn;
@}

@$@<Translation function interfaces@>+=@{
typedef TreeNodeList (*AppCompUnArFn) \
    ELI_ARG((TreeNodeList, VarSym, VarSym, ProcSymtab));
typedef TreeNodeList (*AppCompBinArFn) \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
@}

@$@<Translation function interfaces@>+=@{
extern TreeNodeList NoCompUnArApp \
    ELI_ARG((TreeNodeList, VarSym, VarSym, ProcSymtab));
extern TreeNodeList NoCompBinArApp \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppCompArNeg \
    ELI_ARG((TreeNodeList, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppCompArAdd \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppCompArSub \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppCompArMul \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppCompArDiv \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppCompArExp \
    ELI_ARG((TreeNodeList, VarSym, VarSym, VarSym, ProcSymtab));
extern TreeNodeList AppAssInt2Comp \
    ELI_ARG((TreeNodeList, VarSym, operand));
extern TreeNodeList AppAssReal2Comp \
    ELI_ARG((TreeNodeList, VarSym, operand));

@}

@$@<Arithmetic Expressions@>+=@{
cNeg -> CompUnArApp={AppCompArNeg};
cIdn -> CompUnArApp={NoCompUnArApp};
cAdd -> CompBinArApp={AppCompArAdd};
cSub -> CompBinArApp={AppCompArSub};
cMul -> CompBinArApp={AppCompArMul};
cDiv -> CompBinArApp={AppCompArDiv};
cExp -> CompBinArApp={AppCompArExp};
@}

@$@<Translation functions@>+=@{
#define Z_EQ_OP_X(t, o, z, x) \
    Store(t,operand(z),Monadic(o,t,Monadic(io_lod,t,x)))
#define Z_EQ_X_OP_Y(t, o, z, x, y) \
    Store(t,operand(z),Dyadic(o,t,Monadic(io_lod,t,x),Monadic(io_lod,t,y)))

TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
NoCompUnArApp
(TreeNodeList codechain, VarSym rst, VarSym src, ProcSymtab suifscope)
#else
NoCompUnArApp(codechain, rst, src, suifscope) 
TreeNodeList codechain; VarSym rst; VarSym src; ProcSymtab suifscope;
#endif
{ return codechain; }

TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
NoCompBinArApp(
    TreeNodeList codechain, 
    VarSym rst, VarSym src1, VarSym src2, 
    ProcSymtab suifscope)
#else
NoCompBinArApp(codechain, rst, src1, src2, suifscope)
TreeNodeList codechain; 
VarSym rst; VarSym src1; VarSym src2; 
ProcSymtab suifscope;
#endif
{ return codechain; }

TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
AppCompArNeg(
    TreeNodeList codechain, 
    VarSym rst, VarSym src, 
    ProcSymtab suifscope)
#else
AppCompArNeg(codechain, rst, src, suifscope)
TreeNodeList codechain; VarSym rst; VarSym src; ProcSymtab suifscope;
#endif
{
    if( rst == NoVarSym || src == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype = GetStructTgtType(ComplexType, NoStructType);

    LdAddress src_r = ConstInstr(compeleptrtype, sym_addr(src, 
        FieldOffset(compstrtype, "_r")));
    MEMBER(src_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src_i = ConstInstr(compeleptrtype, sym_addr(src,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_i")))));

/* rst._r = - src._r;
*/
    codechain = AppendTreeNode(
            codechain,
            Z_EQ_OP_X(compeletype, io_neg, rst_r, src_r));

/* rst._i = - src._i
*/
    codechain = AppendTreeNode(
            codechain,
            Z_EQ_OP_X(compeletype, io_neg, rst_i, src_i));

    return codechain;
}
                    
TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
AppCompArAdd(
    TreeNodeList codechain, 
    VarSym rst, VarSym src1, VarSym src2,
    ProcSymtab suifscope)
#else
AppCompArAdd(codechain, rst, src1, src2, suifscope)
TreeNodeList codechain; 
VarSym rst; VarSym src1; VarSym src2; 
ProcSymtab suifscope;
#endif
{
    if(rst == NoVarSym || src1 == NoVarSym || src2 == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype = GetStructTgtType(ComplexType,NoStructType);

    LdAddress src1_r = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src1_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src1_i = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src1_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src2_r = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src2_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src2_i = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src2_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));

/* rst._r = src1._r + src2._r
*/
    codechain =
        AppendTreeNode(
            codechain,
            Z_EQ_X_OP_Y(compeletype, io_add, rst_r, src1_r, src2_r));

/* rst._i = src1._i + src2._i
*/
    codechain =
        AppendTreeNode(
            codechain,
            Z_EQ_X_OP_Y(compeletype, io_add, rst_i, src1_i, src2_i));

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCompArSub(
    TreeNodeList codechain, 
    VarSym rst, VarSym src1, VarSym src2,
    ProcSymtab suifscope)
#else
AppCompArSub(codechain, rst, src1, src2, suifscope)
TreeNodeList codechain; 
VarSym rst; VarSym src1; VarSym src2;
ProcSymtab suifscope;
#endif
{
    if(rst == NoVarSym || src1 == NoVarSym || src2 == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype = GetStructTgtType(ComplexType,NoStructType);

    LdAddress src1_r = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src1_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src1_i = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src1_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src2_r = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src2_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src2_i = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src2_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));

/* rst._r = src1._r - src2._r
*/
    codechain =
        AppendTreeNode(
            codechain,
            Z_EQ_X_OP_Y(compeletype, io_sub, rst_r, src1_r, src2_r));

/* rst._i = src1._i - src2._i
*/
    codechain =
        AppendTreeNode(
            codechain,
            Z_EQ_X_OP_Y(compeletype, io_sub, rst_i, src1_i, src2_i));

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__) 
AppCompArMul(
    TreeNodeList codechain, 
    VarSym rst, VarSym src1, VarSym src2,
    ProcSymtab suifscope)
#else
AppCompArMul(codechain, rst, src1, src2, suifscope)
TreeNodeList codechain; 
VarSym rst; VarSym src1; VarSym src2;
ProcSymtab suifscope;
#endif
{
    if(rst == NoVarSym || src1 == NoVarSym || src2 == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype = GetStructTgtType(ComplexType,NoStructType);

    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src1_r1 = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src1_r1, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src1_i1 = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src1_i1, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src2_r1 = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src2_r1, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src2_i1 = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src2_i1, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src1_r2 = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src1_r2, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src1_i2 = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src1_i2, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src2_r2 = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src2_r2, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src2_i2 = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src2_i2, append_annote(k_fields, NEW(immed_list(immed("_i")))));


/* rst._r = src1._r * src2._r - src1._i * src2._i
*/
    codechain =
        AppendTreeNode(
            codechain,
            Store(
                compeletype,
                operand(rst_r),
                Dyadic(
                    io_sub,
                    compeletype,
                    Dyadic(
                        io_mul,
                        compeletype,
                        Monadic(io_lod, compeletype, src1_r1),
                        Monadic(io_lod, compeletype, src2_r1)),
                    Dyadic(
                        io_mul,
                        compeletype,
                        Monadic(io_lod, compeletype, src1_i1),
                        Monadic(io_lod, compeletype, src2_i1)))));

/* rst._i = src1._r * src2._i + src1._i * src2._r
*/
    codechain =
        AppendTreeNode(
            codechain,
            Store(
                compeletype,
                operand(rst_i),
                Dyadic(
                    io_add,
                    compeletype,
                    Dyadic(
                        io_mul,
                        compeletype,
                        Monadic(io_lod, compeletype, src1_r2),
                        Monadic(io_lod, compeletype, src2_i2)),
                    Dyadic(
                        io_mul,
                        compeletype,
                        Monadic(io_lod, compeletype, src1_i2),
                        Monadic(io_lod, compeletype, src2_r2)))));

    return codechain;
}

TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
AppCompArDiv(
    TreeNodeList codechain, 
    VarSym rst, VarSym src1, VarSym src2,
    ProcSymtab suifscope)
#else
AppCompArDiv(codechain, rst, src1, src2, suifscope)
TreeNodeList codechain; 
VarSym rst; VarSym src1; VarSym src2;
ProcSymtab suifscope;
#endif
{ 
    if(rst == NoVarSym || src1 == NoVarSym || src2 == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compptrtype = GetPtrTgtType(ComplexType, type_error);
    static TypeNode c_divptrtype = GetPtrTgtType(c_divKey, type_error);
    static ProcSym c_divsym = GetProcedure(c_divKey, NoProcSym);

    Call call_c_div = NEW(
        in_cal(
            type_void,
            operand(),
            ConstVal(c_divptrtype, c_divsym),
            3));

    MEMBER(call_c_div, set_argument(0, ConstVal(compptrtype, rst)));
    MEMBER(call_c_div, set_argument(1, ConstVal(compptrtype, src1)));
    MEMBER(call_c_div, set_argument(2, ConstVal(compptrtype, src2)));

    codechain = AppendTreeNode(codechain, NEW(tree_instr(call_c_div)));

    return codechain; 
}


TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
AppCompArExp(
    TreeNodeList codechain, 
    VarSym rst, VarSym src1, VarSym src2,
    ProcSymtab suifscope)
#else
AppCompArExp(codechain, rst, src1, src2, suifscope)
TreeNodeList codechain; 
VarSym rst; VarSym src1; VarSym src2;
ProcSymtab suifscope;
#endif
{
    if(rst == NoVarSym || src1 == NoVarSym || src2 == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compptrtype = GetPtrTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype=GetStructTgtType(ComplexType,NoStructType);
    static TypeNode dbcomptype = GetTgtType(DbComplexType, type_error);
    static TypeNode dbcompptrtype = GetPtrTgtType(DbComplexType, type_error);
    static TypeNode dbcompeletype = GetEleType(DbComplexType, type_error);
    static TypeNode dbcompeleptrtype = GetElePtrType(DbComplexType, type_error);
    static StructType dbcompstrtype = 
        GetStructTgtType(DbComplexType, NoStructType);
    static TypeNode pow_zzptrtype = GetPtrTgtType(pow_zzKey, type_error);
    static ProcSym pow_zzsym = GetProcedure(pow_zzKey, NoProcSym);

    VarSym z_rst = MEMBER(suifscope, new_unique_var(dbcomptype, "DbComp"));
    VarSym z_src1 = MEMBER(suifscope, new_unique_var(dbcomptype, "DbComp"));
    VarSym z_src2 = MEMBER(suifscope, new_unique_var(dbcomptype, "DbComp"));

    LdAddress src1_r = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src1_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src1_i = ConstInstr(compeleptrtype, sym_addr(src1,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src1_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress src2_r = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_r")));
    MEMBER(src2_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress src2_i = ConstInstr(compeleptrtype, sym_addr(src2,
        FieldOffset(compstrtype, "_i")));
    MEMBER(src2_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));

    LdAddress z_src1_r = ConstInstr(dbcompeleptrtype, sym_addr(z_src1,
        FieldOffset(dbcompstrtype, "_r")));
    MEMBER(z_src1_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress z_src1_i = ConstInstr(dbcompeleptrtype, sym_addr(z_src1,
        FieldOffset(dbcompstrtype, "_i")));
    MEMBER(z_src1_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress z_src2_r = ConstInstr(dbcompeleptrtype, sym_addr(z_src2,
        FieldOffset(dbcompstrtype, "_r")));
    MEMBER(z_src2_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress z_src2_i = ConstInstr(dbcompeleptrtype, sym_addr(z_src2,
        FieldOffset(dbcompstrtype, "_i")));
    MEMBER(z_src2_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));
    LdAddress z_rst_r = ConstInstr(dbcompeleptrtype, sym_addr(z_rst,
        FieldOffset(dbcompstrtype, "_r")));
    MEMBER(z_rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress z_rst_i = ConstInstr(dbcompeleptrtype, sym_addr(z_rst,
        FieldOffset(dbcompstrtype, "_i")));
    MEMBER(z_rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));

#define Z_EQ_CVT_X(zt, z, xt, x) \
    Store(zt,operand(z),Monadic(io_cvt,zt,Monadic(io_lod,xt,x)))

/* z_src1._r = (double)src1._r, z_src1._i = (double)src1._i; */
    codechain = AppendTreeNode(codechain, 
        Z_EQ_CVT_X(dbcompeletype, z_src1_r, compeletype, src1_r));
    codechain = AppendTreeNode(codechain, 
        Z_EQ_CVT_X(dbcompeletype, z_src1_i, compeletype, src1_i));

/* z_src2._r = (double)src2._r, z_src2._i = (double)src2._i; */
    codechain = AppendTreeNode(codechain, 
        Z_EQ_CVT_X(dbcompeletype, z_src2_r, compeletype, src2_r));
    codechain = AppendTreeNode(codechain, 
        Z_EQ_CVT_X(dbcompeletype, z_src2_i, compeletype, src2_i));

/* pow_zz(&z_rst, &z_src1, &z_src2); */
    Call call_pow_zz = NEW(
        in_cal(
            type_void,
            operand(),
            ConstVal(pow_zzptrtype, pow_zzsym),
            3));

    MEMBER(call_pow_zz, set_argument(0, ConstVal(dbcompptrtype, z_rst)));
    MEMBER(call_pow_zz, set_argument(1, ConstVal(dbcompptrtype, z_src1)));
    MEMBER(call_pow_zz, set_argument(2, ConstVal(dbcompptrtype, z_src2)));

    codechain = AppendTreeNode(codechain, NEW(tree_instr(call_pow_zz)));

/* rst._r = (float)z_rst._r, rst._i = (float)z_rst._i; */
    codechain = AppendTreeNode(codechain,
        Z_EQ_CVT_X(compeletype, rst_r, dbcompeletype, z_rst_r));
    codechain = AppendTreeNode(codechain,
        Z_EQ_CVT_X(dbcompeletype, rst_i, compeletype, z_rst_i));

    return codechain; 
}


TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppAssInt2Comp(TreeNodeList codechain, VarSym rst, operand datum)
#else
AppAssInt2Comp(codechain, rst, datum)
TreeNodeList codechain; VarSym rst; operand datum;
#endif
{
    if(rst == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype = GetStructTgtType(ComplexType,NoStructType);

    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));

/* rst._r = (float)datum;
*/
    codechain = 
        AppendTreeNode(
            codechain,
            Store(
                compeletype,
                operand(rst_r),
                Monadic(io_cvt, compeletype, datum)));

/* rst._i = 0.0;
*/
    codechain =
        AppendTreeNode(
            codechain,
            Store(
                compeletype,
                operand(rst_i),
                ConstVal(compeletype, 0.0)));

    return codechain;
}
    
TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppAssReal2Comp(TreeNodeList codechain, VarSym rst, operand datum)
#else
AppAssReal2Comp(codechain, rst, datum)
TreeNodeList codechain; VarSym rst; operand datum;
#endif
{
    if(rst == NoVarSym)
        return codechain;

    static TypeNode comptype = GetTgtType(ComplexType, type_error);
    static TypeNode compeletype = GetEleType(ComplexType, type_error);
    static TypeNode compeleptrtype = GetElePtrType(ComplexType, type_error);
    static StructType compstrtype = GetStructTgtType(ComplexType,NoStructType);

    LdAddress rst_r = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_r")));
    MEMBER(rst_r, append_annote(k_fields, NEW(immed_list(immed("_r")))));
    LdAddress rst_i = ConstInstr(compeleptrtype, sym_addr(rst,
        FieldOffset(compstrtype, "_i")));
    MEMBER(rst_i, append_annote(k_fields, NEW(immed_list(immed("_i")))));

/* rst._r = datum;
*/
    codechain =
        AppendTreeNode(
            codechain,
            Store(
                compeletype,
                operand(rst_r),
                datum));

/* rst._i = 0.0
*/
    codechain =
        AppendTreeNode(
            codechain,
            Store(
                compeletype,
                operand(rst_i),
                ConstVal(compeletype, 0.0)));

    return codechain;
}


@}


@$@<COMPLEX Arithmetic Expression@>+=@{
ATTR tempcomp1, tempcomp2: VarSym;
ATTR tempcode: TreeNodeList;

RULE: xExpr ::= xUnOp xExpr
COMPUTE
    xExpr[1].tempcomp = IF(EQ(xExpr[1].TypeCode, OilTypeComplexType),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        NoVarSym);

    .tempcomp1 = IF(AND(EQ(xExpr[1].TypeCode, OilTypeComplexType),
                        NE(xExpr[2].TypeCode, OilTypeComplexType)),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        xExpr[2].tempcomp);

    .tempcode = IF(EQ(xExpr[2].TypeCode, OilTypeIntegerType),
        AppAssInt2Comp(xExpr[2].codechain, .tempcomp1, xExpr[2].Datum),
        IF(EQ(xExpr[2].TypeCode, OilTypeRealType),
            AppAssReal2Comp(xExpr[2].codechain, .tempcomp1, xExpr[2].Datum),
            xExpr[2].codechain));

    xExpr[1].codechain = APPLY(
        GetCompUnArApp(xUnOp.TgtOp, NoCompUnArApp),
        .tempcode,
        xExpr[1].tempcomp,
        .tempcomp1,
        INCLUDING xProgramUnit.suifscope);
END;

RULE: xExpr ::= xExpr xBinOp xExpr
COMPUTE
    xExpr[1].tempcomp = IF(EQ(xExpr[1].TypeCode, OilTypeComplexType),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        NoVarSym);

    .tempcomp1 = IF(AND(EQ(xExpr[1].TypeCode, OilTypeComplexType),
                        NE(xExpr[2].TypeCode, OilTypeComplexType)),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        xExpr[2].tempcomp);

    .tempcomp2 = IF(AND(EQ(xExpr[1].TypeCode, OilTypeComplexType),
                        NE(xExpr[3].TypeCode, OilTypeComplexType)),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        xExpr[3].tempcomp);

    xExpr[3].codechain = IF(EQ(xExpr[2].TypeCode, OilTypeIntegerType),
        AppAssInt2Comp(xExpr[2].codechain, .tempcomp1, xExpr[2].Datum),
        IF(EQ(xExpr[2].TypeCode, OilTypeRealType),
            AppAssReal2Comp(xExpr[2].codechain, .tempcomp1, xExpr[2].Datum),
            xExpr[2].codechain));

    .tempcode = IF(EQ(xExpr[3].TypeCode, OilTypeIntegerType),
        AppAssInt2Comp(xExpr[3].codechain, .tempcomp2, xExpr[3].Datum),
        IF(EQ(xExpr[3].TypeCode, OilTypeRealType),
            AppAssReal2Comp(xExpr[3].codechain, .tempcomp2, xExpr[3].Datum),
            xExpr[3].codechain));

    xExpr[1].codechain = APPLY(
        GetCompBinArApp(xBinOp.TgtOp, NoCompBinArApp),
        .tempcode,
        xExpr[1].tempcomp,
        .tempcomp1,
        .tempcomp2,
        INCLUDING xProgramUnit.suifscope);
END;
@}

Functions @{pow_zz@} and @{c_div@} are C library functions in library
@{F77@}.

@$@<Definition table keys for predefined extern functions@>+=@{
pow_zzKey;
c_divKey;
@}

@$@<Extern functions@>+=@{
TypeNode ExtVoidFun = NewType(func_type(type_void));
TypeNode ExtVoidFunPtr = NewType(ptr_type(ExtVoidFun));

ProcSym c_divSym = MEMBER(GlobalScope,
    new_proc((func_type *)ExtVoidFun, src_unknown, "c_div"));
ResetTgtType(c_divKey, type_void);
ResetPtrTgtType(c_divKey, ExtVoidFunPtr);
ResetProcedure(c_divKey, c_divSym);

ProcSym pow_zzSym = MEMBER(GlobalScope, 
    new_proc((func_type *)ExtVoidFun, src_unknown, "pow_zz"));
ResetTgtType(pow_zzKey, type_void);
ResetPtrTgtType(pow_zzKey, ExtVoidFunPtr);
ResetProcedure(pow_zzKey, pow_zzSym);
@}

@A@<COMMON and EQUIVALENCE Statments@>

Fortran COMMON and EQUIVALENCE association is implemented by SUIF 
parent-variable and sub-variable constructs. A COMMON or EQUIVALENCE
storage unit sequence is declared to be a SUIF parent-variable of
an array type, whose length is the size of this storage unit sequence.

All properties of this SUIF translation module are accessed via
@{ObjectKey@}, while objects in common block sequence and equivalence
sequence are linked via @{UnitKey@}, so a link between @{ObjectKey@} and 
@{UnitKey@} needs to be established. Property @{ObjectKey@} is accessed
via @{UnitKey@}. Only common block names and leaders of equivalence sets 
have the valid value execpt for blank common block, in which case
@{ObjectKey@} and @{UnitKey@} are always the same.

@$@<Property ObjectKey@>==@{
ObjectKey: DefTableKey;
@}

Property @{ParVariable@} hold the SUIF variable symbol of the parent variable.
Property @{SubVarDef@} is used to indicate whether a variable has beem
declared to be a sub-variable of some parent variable.

@$@<Parent Variable@>==@{
ParVariable: VarSym;
SubVarDef: int;
@}

Attribute @{GotAllParVar@} asserts that property @{ParVariable@} has
valid value.
For blank common block, there is no Eli symbol associated with it, so we
set the @{ParVariable@} at symbol @{xProgramUnit@}. The parent variable
of a COMMON storage sequence is set to be in the global symbol table.

@$@<COMMON and EQUIVALENCE@>+=@{
ATTR GotAllParVar: VOID;
ATTR GotParVar: VOID;

SYMBOL xProgramUnit COMPUTE
    SYNT.GotAllParVar= IF(GT(GetComBlkSize(THIS.BlankCommonKey, 0), 0),
        ORDER(
            ResetTgtType(THIS.BlankCommonKey,
                NewType(
                    array_type(
                        GetTgtType(GetStorageUnitKind(THIS.BlankCommonKey,
                                                      NoKey),
                                   type_error),
                        array_bound(0),
                        array_bound(SUB(GetComBlkSize(THIS.BlankCommonKey, 0),
                                        1))))),

            ResetParVariable(THIS.BlankCommonKey,
                 MEMBER(GlobalScope,
                       new_var(GetTgtType(THIS.BlankCommonKey, 
                                                 type_error),
                                      "__BlankCommon"))),

            MEMBER(INCLUDING xSourceFile.suifscope,
              define_var(GetParVariable(THIS.BlankCommonKey, NoVarSym),
                MUL(
                  MEMBER(
                    GetTgtType(
                      GetStorageUnitKind(THIS.BlankCommonKey, NoKey),
                      type_error),
                    size()),
                  8))),

            MEMBER(GetParVariable(THIS.BlankCommonKey, NoVarSym),
                 append_annote(k_common_block)),

            ResetObjectKey(THIS.BlankCommonKey, THIS.BlankCommonKey),

            ResetDefined(THIS.BlankCommonKey, 1)))
    <- (THIS.GotAllEquivalence,
                CONSTITUENTS xCommonBlockName.GotParVar, 
                CONSTITUENTS xEquivalenceObject.GotParVar);
END;
                        
SYMBOL xCommonBlockName COMPUTE
    SYNT.GotParVar= IF(AND(GT(GetComBlkSize(THIS.UnitKey, 0), 0),
                               NOT(GetDefined(THIS.ObjectKey, 0))),
        ORDER(
            ResetTgtType(THIS.ObjectKey,
                NewType(
                    array_type(
                        GetTgtType(GetStorageUnitKind(THIS.UnitKey,
                                                      NoKey),
                                   type_error),
                        array_bound(0),
                        array_bound(SUB(GetComBlkSize(THIS.UnitKey, 0),
                                        1))))),

            ResetParVariable(THIS.ObjectKey,
                 MEMBER(GlobalScope,
                       new_var(GetTgtType(THIS.ObjectKey,
                                          type_error),
                               StringTable(THIS.Sym)))),

            MEMBER(INCLUDING xSourceFile.suifscope,
              define_var(GetParVariable(THIS.ObjectKey, NoVarSym),
                MUL(
                  MEMBER(
                    GetTgtType(
                      GetStorageUnitKind(THIS.UnitKey, NoKey),
                      type_error),
                    size()),
                  8))),

            MEMBER(GetParVariable(THIS.ObjectKey, NoVarSym),
                append_annote(k_common_block, 
                              NEW(immed_list(immed(StringTable(THIS.Sym)))))),

            ResetObjectKey(THIS.UnitKey, THIS.ObjectKey),

            ResetDefined(THIS.ObjectKey, 1)))
    <- INCLUDING xProgramUnit.GotAllEquivalence;
END;
@}

For EQUIVALENCE storage sequence, we only set the parent variable for leaders
of equivalence set. (Note: Please reference @/FORTRAN 77 Storage Sequences@/
for concept and implementation of equivalence set.) Here we also need to
make sure this EQUIVALENCE storage sequence is not in any COMMON storage
sequence.

@$@<COMMON and EQUIVALENCE@>+=@{
SYMBOL xEquivalenceObject COMPUTE
  SYNT.ObjectKey = CONSTITUENT xVariableName.ObjectKey;
  SYNT.UnitKey = CONSTITUENT xVariableName.UnitKey;
  SYNT.GotParVar=
    IF(AND(EQ(EquSetGetLeader(THIS.UnitKey),THIS.UnitKey),
       AND(EQ(GetComBlock(EquSetGetLeader(THIS.UnitKey),NoKey),NoKey),
       AND(EQ(GetParVariable(THIS.ObjectKey, NoVarSym),NoVarSym),
           GE(SUB(GetEquUpper(THIS.UnitKey,0),GetEquLower(THIS.UnitKey,0)),0)))),
      ORDER(
        ResetTgtType(
          THIS.ObjectKey,
          NewType(array_type(
            GetTgtType(GetStorageUnitKind(THIS.UnitKey,NoKey),type_error),
            array_bound(0),
            array_bound(
              SUB(GetEquUpper(THIS.UnitKey,0),GetEquLower(THIS.UnitKey,0)))))),
        ResetParVariable(
          THIS.ObjectKey,
          MEMBER(INCLUDING xProgramUnit.suifscope,
            new_unique_var(GetTgtType(THIS.ObjectKey,type_error),"_Equivalence"))),
        ResetObjectKey(THIS.UnitKey,THIS.ObjectKey)))
    <- INCLUDING xProgramUnit.GotAllEquivalence;
END;

ATTR ObjectKey: DefTableKey;
@}

Attribute @{AllSubVarSet@} asserts that all sub-variables offset in parent
variables have be properly set via SUIF functions.

@$@<COMMON and EQUIVALENCE@>+=@{
ATTR Allhavedef: VOID;
ATTR SubVarSet: VOID;
ATTR AllSubVarSet: VOID;

SYMBOL xProgramUnit COMPUTE
    SYNT.Allhavedef = CONSTITUENTS SymbolicName.havedef;

    SYNT.AllSubVarSet = CONSTITUENTS (
        xCommonBlockObject.SubVarSet,
        xEquivalenceObject.SubVarSet);
    SYNT.GotAllEquivalence=CONSTITUENTS xEquivalenceSet.Point;
END;

SYMBOL xCommonBlockObject COMPUTE
  SYNT.SubVarSet=
    IF(NOT(GetSubVarDef(CONSTITUENT xVariableName.ObjectKey,0)),
      ORDER(
        MEMBER(
          GetParVariable(
            GetObjectKey(
              GetComBlock(CONSTITUENT xVariableName.UnitKey,NoKey),
              NoKey),
            NoVarSym),
          add_child(
            GetVariable(CONSTITUENT xVariableName.ObjectKey, NoVarSym),
            MUL(
              MEMBER(
                GetTgtType(
                  GetStorageUnitKind(
                    GetType(CONSTITUENT xVariableName.UnitKey,NoKey),
                    NoKey),
                  type_error), 
                size()),
              GetComLower(CONSTITUENT xVariableName.UnitKey,0)))),
        ResetSubVarDef(CONSTITUENT xVariableName.ObjectKey, 1)))
    <- (INCLUDING xProgramUnit.GotAllParVar, INCLUDING xProgramUnit.Allhavedef);
END;

SYMBOL xEquivalenceObject COMPUTE
    SYNT.SubVarSet = IF(NOT(GetSubVarDef(THIS.ObjectKey, 0)),
        ORDER(
            IF(EQ(GetComBlock(EquSetGetLeader(THIS.UnitKey), NoKey), 
                  NoKey),
%if not in common 
                MEMBER(
                    GetParVariable(
                        GetObjectKey(EquSetGetLeader(THIS.UnitKey), NoKey),
                        NoVarSym),
                    add_child(
                        GetVariable(THIS.ObjectKey, NoVarSym),
                        MUL(MEMBER(GetTgtType(
                                       GetStorageUnitKind(
                                           GetType(THIS.UnitKey, NoKey), 
                                           NoKey),
                                       type_error), 
                                   size()),
                            EquSetOfftoLead(THIS.UnitKey)))),
%if in common 
                MEMBER(
                    GetParVariable(
                        GetObjectKey(
                            GetComBlock(
                                EquSetGetLeader(THIS.UnitKey),
                                NoKey),
                            NoKey),
                        NoVarSym),
                    add_child(
                        GetVariable(THIS.ObjectKey, NoVarSym),
                        MUL(MEMBER(GetTgtType(
                                       GetStorageUnitKind(
                                           GetType(THIS.UnitKey, NoKey),
                                           NoKey), 
                                       type_error), 
                                   size()),
                            ADD(EquSetOfftoLead(THIS.UnitKey),
                                GetComLower(
                                    EquSetGetLeader(THIS.UnitKey),
                                    0)))))),

            ResetSubVarDef(THIS.ObjectKey, 1)))
    <- (INCLUDING xProgramUnit.GotAllParVar,
                INCLUDING xProgramUnit.Allhavedef);
END;
@}
 
@A

An assignment statement can be implemented by either a store or a memory
copy.
Memory copies can be used only when the expression on the right-hand side
has an address, and its type agrees with the type of the variable or array
reference.

Suif has no complex type as one of it's basic type, so for every conversion
to complex type from non-complex type, i.e integer type or real type,
a temporary variable of complex type is created to hold the result of
conversion. Funcitons @{AppAssInt2Comp(cd, var, dt)@} and 
@{AppAssReal2Comp(cd, var, dt)@} will append code of assignment to a
variable of complex type from datum of integer type and real type
respectively.

@$@<Assignment Statements@>==@{
ATTR vartype: DefTableKey;
ATTR tgttype, ptrtype: TypeNode;
ATTR varaddr: operand;
ATTR tempDatum: operand;

RULE: xStmt ::= xLblDef xName '=' xExpr xEOS
COMPUTE
  .tempcomp1 = IF(AND(EQ(.vartype, ComplexType),
                      NE(xExpr.TypeCode, OilTypeComplexType)),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        xExpr.tempcomp);

  .tempcode = IF(EQ(xExpr.TypeCode, OilTypeIntegerType),
        AppAssInt2Comp(xExpr.codechain, .tempcomp1, xExpr.Datum),
        IF(EQ(xExpr.TypeCode, OilTypeRealType),
            AppAssReal2Comp(xExpr.codechain, .tempcomp1, xExpr.Datum),
            xExpr.codechain));

  .tempDatum = IF(EQ(.vartype, ComplexType),
        operand(.tempcomp1),
        xExpr.Datum);
        
  .varsym=GetVariable(xName.ObjectKey,NoVarSym) <- xName.havedef;
  .vartype=GetType(xName.UnitKey,NoKey)
  <- INCLUDING xProgramUnit.GotAllTypes;
  .tgttype=@<Target type for@>@(xName@);
  .varaddr=
    IF(InIS(DummyArgument,GetKindSet(xName.UnitKey,NullIS())),
      operand(.varsym),
      ConstVal(NewType(ptr_type(.tgttype)),.varsym))
  <- INCLUDING xProgramUnit.ClassificationDone;
  xStmt.codechain=
    AppendTreeNode(
      .tempcode,
/*
      IF(AND(xExpr.Address,EQ(.vartype,OilTypeName(xExpr.TypeCode))),
        Move(.tgttype,.varaddr,operand(xExpr.Address)),
*/
        Store(
          .tgttype,
          .varaddr,
          IF(EQ(.vartype, ComplexType),
            .tempDatum,
            MapCoercion(
              OilGetArgType(.Operator,2),
              xExpr.TypeCode,
              .tempDatum))));
END;

RULE: xStmt ::=  xLblDef xName '(' xExprList ')' '=' xExpr xEOS
COMPUTE
  .tempcomp1 = IF(AND(EQ(.vartype, ComplexType),
                      NE(xExpr.TypeCode, OilTypeComplexType)),
        MEMBER(
            INCLUDING xProgramUnit.suifscope,
            new_unique_var(
                GetTgtType(ComplexType, type_error),
                "TComp")),
        xExpr.tempcomp);

  .tempcode = IF(EQ(xExpr.TypeCode, OilTypeIntegerType),
        AppAssInt2Comp(xExpr.codechain, .tempcomp1, xExpr.Datum),
        IF(EQ(xExpr.TypeCode, OilTypeRealType),
            AppAssReal2Comp(xExpr.codechain, .tempcomp1, xExpr.Datum),
            xExpr.codechain));

  .tempDatum = IF(EQ(.vartype, ComplexType),
        operand(.tempcomp1),
        xExpr.Datum);

  .vartype=GetType(xName.UnitKey,NoKey)
  <- INCLUDING xProgramUnit.GotAllTypes;
  .tgttype=@<Target type for@>@(xName@);
  xStmt.codechain=
    AppendTreeNode(
      .tempcode,
      IF(AND(xExpr.Address,EQ(.vartype,OilTypeName(xExpr.TypeCode))),
        Move(
          .tgttype,
          operand(xExprList.ArrayInstruction),
          operand(xExpr.Address)),
        Store(
          .tgttype,
          operand(xExprList.ArrayInstruction),
          IF(EQ(.vartype, ComplexType),
            .tempDatum,
            MapCoercion(
              OilGetArgType(.Operator,2),
              xExpr.TypeCode,
              .tempDatum)))));
END;


RULE: xStmt ::=  xLblDef xName xStmtFunctionRange
COMPUTE
  xStmt.codechain=
    IF(NOT(xStmtFunctionRange.InStmtFunc),
      AppendTreeNode(
        xStmtFunctionRange.codechain,
        Store(
          @<Target type for@>@(xName@),
          operand(xStmtFunctionRange.ArrayInstruction),
          xStmtFunctionRange.Datum)),
    xLblDef.codechain);
END;

RULE: xStmtFunctionRange ::=  '(' xSFDummyArgNameList ')' '=' xExpr xEOS
COMPUTE
  xStmtFunctionRange.Datum=
    MapCoercion(OilGetArgType(.Operator,2),xExpr.TypeCode,xExpr.Datum);
END;

RULE: xStmtFunctionRange ::=  '(' ')' '=' xExpr xEOS
COMPUTE
  xStmtFunctionRange.Datum=operand();
END;

%following need changing
RULE: xStmt ::=  xLblDef xName '(' xExprList ')' xSubstringRange '=' xExpr xEOS
END;
@}

@A

@$@<Control Statements@>==@{
@<Unconditional GO TO Statement@>
@<Arithmetic IF Statement@>
@<Logical IF Statement@>
@<Block IF Statement@>
@<ELSE IF Statement@>
@<ELSE Statement@>
@<END IF Statement@>
@<DO Statement@>
@}

@B

@$@<Unconditional GO TO Statement@>==@{
RULE: xStmt ::=  xLblDef GoToKw xLblRef xEOS
COMPUTE
  xStmt.codechain=
    AppendTreeNode(
      xLblDef.codechain,
      Jump(
        GetTgtLabel(xLblRef.UnitKey,NoLabelSym)
        <- INCLUDING xProgramUnit.GotAllTgtLbls));
END;
@}

@B

@$@<Arithmetic IF Statement@>==@{
ATTR exprtype: TypeNode;
ATTR temporary: VarSym;

RULE: xStmt ::= xLblDef 'if' '(' xExpr ')' xLblRef ',' xLblRef ',' xLblRef xEOS
COMPUTE
  .exprtype=GetTgtType(OilTypeName(xExpr.TypeCode),type_error);
  .temporary=
    MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_var(.exprtype,"T"));
  xStmt[1].codechain=
    ORDER(
      AppendTreeNode(
        xLblDef.codechain,
        Store(.exprtype,operand(.temporary),xExpr.Datum)),
      AppendTreeNode(
        xLblDef.codechain,
        JumpTrue(
          GetTgtLabel(xLblRef[1].UnitKey,NoLabelSym),
          Dyadic(io_sl,.exprtype,operand(.temporary),ConstVal(.exprtype,0)))),
      AppendTreeNode(
        xLblDef.codechain,
        JumpTrue(
          GetTgtLabel(xLblRef[2].UnitKey,NoLabelSym),
          Dyadic(io_seq,.exprtype,operand(.temporary),ConstVal(.exprtype,0)))),
      AppendTreeNode(
        xLblDef.codechain,
        Jump(GetTgtLabel(xLblRef[3].UnitKey,NoLabelSym))));
END;       
@}

@B

@$@<Logical IF Statement@>==@{
ATTR Then, Else: TreeNodeList;
ATTR ElseLbl: LabelSym;

RULE: xStmt ::=  xLblDef 'if' '(' xExpr ')' xStmt
COMPUTE
  .Then=NEW(tree_node_list());
  .ElseLbl=MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L"));
  .Else=NEW(tree_node_list());
  .MakeCond=
    AppendTreeNode(
      xLblDef.codechain,
      NEW(tree_if(
        .ElseLbl,
        AppendTreeNode(NEW(tree_node_list()),JumpFalse(.ElseLbl,xExpr.Datum)),
        .Then,
        .Else)));
  xStmt[1].codechain=xLblDef.codechain <- .MakeCond;
  xStmt[2].codechain=.Then;
END;       
@}

@B

The block IF statement is used with the END IF statement and, optionally,
the ELSE IF and ELSE statements to control the execution sequence.

@$@<Block IF Statement@>==@{
RULE: xStmt ::=  xLblDef 'if' '(' xExpr ')' 'then' xEOS
COMPUTE
  .Then=NEW(tree_node_list());
  .ElseLbl=MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L"));
  .Else=NEW(tree_node_list());
  xStmt.codechain=
    ORDER(
      AppendTreeNode(
        xLblDef.codechain,
        NEW(tree_if(
          .ElseLbl,
          AppendTreeNode(NEW(tree_node_list()),JumpFalse(.ElseLbl,xExpr.Datum)),
          .Then,
          .Else))),
      OuterCodeStackPush(xLblDef.codechain),
      OuterCodeStackPush(.Else),
      .Then);
END;
@}

@B

@$@<ELSE IF Statement@>==@{
RULE: xStmt ::=  xLblDef 'elseif' '(' xExpr ')' 'then' xEOS
COMPUTE
  .Then=NEW(tree_node_list());
  .ElseLbl=MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L"));
  .Else=NEW(tree_node_list());
  xStmt.codechain=
    ORDER(
      AppendTreeNode(
        OuterCodeStackPop,
        NEW(tree_if(
          .ElseLbl,
          AppendTreeNode(NEW(tree_node_list()),JumpFalse(.ElseLbl,xExpr.Datum)),
          .Then,
          .Else))),
      OuterCodeStackPush(.Else),
      .Then)
    <- xLblDef.codechain;
END;
@}

@B

@$@<ELSE Statement@>==@{
RULE: xStmt ::=  xLblDef 'else' xEOS
COMPUTE
  xStmt.codechain=OuterCodeStackElement(1) <- xLblDef.codechain;
END;
@}

@B

@$@<END IF Statement@>==@{
RULE: xEndIfStmt ::=  xLblDef 'endif' xEOS
COMPUTE
  xEndIfStmt.codechain=
    ORDER(OuterCodeStackPop,OuterCodeStackPop) <- xLblDef.codechain;
END;
@}

@B

@$@<DO Statement@>==@{
SYMBOL xLoopControl:
  DoVariable: VarSym,
  Lower, Upper, Step: operand;

ATTR Body: TreeNodeList;

RULE: xStmt ::=  xLblDef 'do' xLblRef xLoopControl xEOS
COMPUTE
  .Body=NEW(tree_node_list());
  .MakeFor=
    AppendTreeNode(
      xLblDef.codechain,
      NEW(tree_for(
        xLoopControl.DoVariable,
        FOR_SGELE,
        MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L")),
        MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L")),
        .Body,
        xLoopControl.Lower,
        xLoopControl.Upper,
        xLoopControl.Step,
        NEW(tree_node_list()))));
  .PushContext=OuterCodeStackPush(xLblDef.codechain) <- .MakeFor;
  .BumpCount=BumpDoCount(xLblRef.UnitKey,1) <- .PushContext;
  xStmt.codechain=.Body <- .BumpCount;
END;

RULE: xBody ::=  xBody xStmt
COMPUTE
  xBody[1].codechain=MapDoEnd(xStmt.label,xStmt.codechain);
END;

SYMBOL xStmt: label: DefTableKey;

SYMBOL xStmt COMPUTE
  SYNT.label=CONSTITUENT xLblDef.UnitKey SHIELD (xStmt, xBody);
END;

RULE: xStmt ::=  xBody
COMPUTE
  xStmt.label=NoKey;
END;

RULE: xLoopControl ::=  xVariableName '=' xExpr ',' xExpr
COMPUTE
  xLoopControl.DoVariable=@<Variable symbol@>@(xVariableName@);
  xLoopControl.Lower=xExpr[1].Datum;
  xLoopControl.Upper=xExpr[2].Datum;
  xLoopControl.Step=ConstVal(GetTgtType(IntegerType,type_error),1);
END;

RULE: xLoopControl ::=  xVariableName '=' xExpr ',' xExpr ',' xExpr
COMPUTE
  xLoopControl.DoVariable=@<Variable symbol@>@(xVariableName@);
  xLoopControl.Lower=xExpr[1].Datum;
  xLoopControl.Upper=xExpr[2].Datum;
  xLoopControl.Step=xExpr[3].Datum;
END;
@}

@$@<Termination label properties@>==@{
DoCount: int [Bump];

void Bump(DefTableKey key, int count)
{ if (key == NoKey) return;
  if (!ACCESS) VALUE=0;
  VALUE++;
}
@}

@$@<Translation functions@>+=@{
TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
MapDoEnd(DefTableKey label, TreeNodeList d)
#else
MapDoEnd(label, d) DefTableKey label; TreeNodeList d;
#endif
{ int Count = GetDoCount(label,0);

  while (Count--) d = OuterCodeStackPop;
  
  return d;
}
@}

@$@<Translation function interfaces@>+=@{
extern TreeNodeList MapDoEnd ELI_ARG((DefTableKey, TreeNodeList));
#define Leftmost(x,y) (x)
#define KeyAbsent NoKey
@}

@B@<CONTINUE Statements@>

No code generation action is needed.


@A@<Input/Output Statements@>

FORTRAN input/output statements are inplemented by sequences of calls
to the functions provided by @{I77@} library. The usage of these library
functions can be referenced by running SUIF @{sf2c@} or ATT @{f2c@}.

@$@<Definition table keys for predefined extern functions@>+=@{
s_wsleKey;
e_wsleKey;
do_lioKey;
s_wsfeKey;
do_fioKey;
e_wsfeKey;
s_rsfeKey;
e_rsfeKey;
f_openKey;
f_closKey;
f_rewKey;
f_backKey;
f_endKey;
f_inquKey;
@}

@$@<Extern functions@>+=@{
TypeNode ExtIntFun = NewType(func_type(f2c_int));
TypeNode ExtIntFunPtr = NewType(ptr_type(ExtIntFun));

char *iofunlist[] = {"s_wsle", "do_lio", "e_wsle",
    "s_wsfe", "do_fio", "e_wsfe", "s_rsfe", "e_rsfe", 
    "f_open", "f_clos", "f_rew", "f_back", "f_end", "f_inqu"};
DefTableKey iofunkey[] = {s_wsleKey, do_lioKey, e_wsleKey, 
    s_wsfeKey, do_fioKey, e_wsfeKey, s_rsfeKey, e_rsfeKey,
    f_openKey, f_closKey, f_rewKey, f_backKey, f_endKey, f_inquKey};

ProcSym ioProcSym;

for(int i = 0; i < 14; i++) {
    ioProcSym = MEMBER(GlobalScope,
        new_proc((func_type *)ExtIntFun, src_unknown, iofunlist[i]));       
    ResetTgtType(iofunkey[i], f2c_int);
    ResetPtrTgtType(iofunkey[i], ExtIntFunPtr);
    ResetProcedure(iofunkey[i], ioProcSym);
}
@}

Some input/output library functions require that a referece to a constant
variable be passed as parameter.

@$@<Definition table key for constant of system use@>+=@{
Const1Key;
Const2Key;
Const3Key;
Const4Key;
Const5Key;
Const6Key;
Const7Key;
Const8Key;
Const9Key;
@}

Extern function @{do_lio()@} is used for unformated input/output. 
A reference to an integer constant must be passed to indicate the type of
the input/output data.

@$@<lio Kind@>==@{
lioKind: DefTableKey;

IntegerType -> lioKind={Const3Key};
RealType -> lioKind={Const4Key};
DoublePrecisionType -> lioKind={Const5Key};
ComplexType -> lioKind={Const6Key};
LogicalType -> lioKind={Const8Key};
CharacterType -> lioKind={Const9Key};
@}


@$@<Predefined constant function interface@>+=@{
void
#if defined(__cplusplus) || defined(__STDC__)
PredefConst(FileSetEntry file);
#else
PredefConst();
#endif
@}

@$@<Predefined constant for system use@>+=@{
void
#if defined(__cplusplus) || defined(__STDC__)
PredefConst(FileSetEntry file)
#else
PredefConst(file) FileSetEntry file;
#endif
{
    DefTableKey ConstKey[9] = {Const1Key, Const2Key, Const3Key, Const4Key,
        Const5Key, Const6Key, Const7Key, Const8Key, Const9Key};
    char *constname[9] = {"c__1", "c__2", "c__3", "c__4", "c__5",
        "c__6", "c__7", "c__8", "c__9"};

    if(file == NoFileSetEntry)
        return;

    file_symtab *filesymtab = MEMBER(file, symtab());

    for (int i = 0; i<9; i++) {

        VarSym ConstVar = 
            MEMBER(filesymtab, new_var(f2c_int, constname[i]));
        VarDef ConstDef = MEMBER(filesymtab,
            define_var(ConstVar, MEMBER(f2c_int, size())));

        MEMBER(ConstDef,
            append_annote(
                k_repeat_init,
                NEW(immed_list(
                    immed(1),
                    immed(MEMBER(f2c_int, size())),
                    immed(i+1)))));

        MEMBER(ConstVar, set_addr_taken()); 

        ResetTgtType(ConstKey[i], f2c_int);
        ResetPtrTgtType(ConstKey[i], NewType(ptr_type(f2c_int)));
        ResetVariable(ConstKey[i], ConstVar);
    }
}
@}

@$@<Input/Output Statements@>==@{
@<Units@>
@<Format Specifier and Identifier@>
@<Record Specifier@>
@<Input/Output Status, Error, and End-of-File Specifiers@>
@<READ, WRITE, and PRINT Statements@>
@<Auxiliary Input/Output Statements@>
@}

@B

Attribute @{usrdef@} indicates whether an Eli symbol @{xExpr@} associated
with @{xUnitIdentifier@} holds a valid non-empty datum.
 
@$@<Units@>==@{
ATTR usrdef: int;

SYMBOL xUnitIdentifier COMPUTE
    SYNT.Datum = operand();
    SYNT.usrdef = 0;
END;

RULE: xUnitIdentifier ::= xExpr
COMPUTE
    xUnitIdentifier.Datum = xExpr.Datum;
    xUnitIdentifier.usrdef = 1;
END;

SYMBOL xRdUnitId COMPUTE
    SYNT.Datum = operand();
    SYNT.usrdef = 0;
END;

RULE: xRdUnitId ::= '(' xExpr ')'
COMPUTE
    xRdUnitId.Datum = xExpr.Datum;
    xRdUnitId.usrdef = 1;
END;

RULE: xIoControlSpec ::= 'unit=' xUnitIdentifier 
COMPUTE
@<Assign unit@>@(xIoControlSpec.codechain@, xUnitIdentifier@,
    INCLUDING xStmt.i77listVar@, INCLUDING xStmt.i77kind@)
END;
@}

Code of assigment to the struct field with @{unit@} as the name is appended.

@$@<Assign unit@>@(@4@)@M@{
    @1 = IF(@2.usrdef, 
          AppAssignField(
             @2.codechain, 
             f2c_int, 
             @3, @4, "unit", @2.Datum),
    @2.codechain);
@}

@B

@$@<Format Specifier and Identifier@>==@{
@<Format Specifier@>
@<Format Identifier@>
@}

@$@<Format Specifier@>==@{
RULE: xIoControlSpec ::= 'fmt=' xFormatIdentifier
COMPUTE
    xIoControlSpec.codechain = IF(NE(xFormatIdentifier.fmtvar, NoVarSym),
        AppAssignField(
            xFormatIdentifier.codechain,
            NewType(ptr_type(type_char)),
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "fmt",
            xFormatIdentifier.Datum),
        xFormatIdentifier.codechain);
END;
@}

A format identifier identifies a format. The @/ANSI X3.9-1978 FORTRAN 77@/
standard specifies five situations of format identifer. So far, this Eli
specification only covers No.1 and No.5.

@$@<Format Identifier@>==@{
ATTR fmtvar: VarSym;

SYMBOL xFormatIdentifier COMPUTE
    SYNT.Datum = IF(EQ(THIS.fmtvar, NoVarSym),
        ConstVal(NewType(ptr_type(type_char)), 0),
        ConstVal(NewType(ptr_type(type_char)), THIS.fmtvar));
END;

RULE: xFormatIdentifier ::= xLblRef 
COMPUTE
    xFormatIdentifier.fmtvar = GetFmtVar(xLblRef.UnitKey, NoVarSym)
    <- INCLUDING xProgramUnit.GotAllFmtVar;
    xFormatIdentifier.fmtiochain = NE(xFormatIdentifier.fmtvar, NoVarSym);
END;

SYMBOL xFormatIdentifier COMPUTE
    SYNT.fmtvar = NoVarSym;
END;

RULE: xFormatIdentifier ::= xExpr
COMPUTE
    xFormatIdentifier.fmtvar = xExpr.charvar;
    xFormatIdentifier.fmtiochain = NE(xFormatIdentifier.fmtvar, NoVarSym);
END;

RULE: xFormatIdentifier ::= '*'
COMPUTE
    xFormatIdentifier.fmtvar = NoVarSym;
    xFormatIdentifier.fmtiochain = 0;
END;
@}

@B

@$@<Record Specifier@>==@{
RULE: xIoControlSpec ::= 'rec=' xExpr 
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xExpr.codechain,
        f2c_int,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "rec",
        xExpr.Datum);
END;
@}


@B

Since we need gather some information in lower context and use them
in upper context, we use chain @{iostatAddr@}, @{errLab@}, and @{endLab@}
to do this kind of work.
 
@$@<Input/Output Status, Error, and End-of-File Specifiers@>==@{

RULE: xIoControlSpec ::= 'iostat=' xScalarVariable        
COMPUTE
    xIoControlSpec.iostatAddr = xScalarVariable.Address;
END;

RULE: xScalarVariable ::= xVariableName
COMPUTE
    xScalarVariable.Address = ConstInstr(
        NewType(ptr_type(f2c_int)),
        GetVariable(xVariableName.ObjectKey, NoVarSym))
    <- xVariableName.havedef;
END;

RULE: xScalarVariable ::= xArrayElement
COMPUTE
    xScalarVariable.Address = xArrayElement.ArrayRef;
END;

@<Error Specifier@>
@<End-of-File Specifier@>
@}

@$@<Create a temp for iostat@>@M@{
    xStmt.tempiostAddr = ConstInstr(NewType(ptr_type(f2c_int)), 
        MEMBER(INCLUDING xProgramUnit.suifscope,
            new_unique_var(f2c_int, "Tempiost")));
@}

@C

Input/Output status specifier may be omitted in an input/output statement.
In that case, when an error specifier appears in that input/output statement,
we use a created temporary variable to hold the input/output status.

@$@<Error Specifier@>==@{
RULE: xIoControlSpec ::= 'err=' xLblRef
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xLblRef.codechain,
        f2c_flag,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "err",
        ConstVal(f2c_flag, 1));

    xIoControlSpec.iostatAddr = 
        IF(EQ(xIoControlSpec.iostatAddr, NoInstruction),
            INCLUDING xStmt.tempiostAddr,
            xIoControlSpec.iostatAddr);

    xIoControlSpec.errLab = GetTgtLabel(xLblRef.UnitKey, NoLabelSym)
    <- INCLUDING xProgramUnit.GotAllTgtLbls;
END;
@}


@C

Input/Output status specifier may be omitted in an input/output statement.
In that case, when an end-of-file specifier appears in that 
input/output statement,
we use a created temporary variable to hold the input/output status.

@$@<End-of-File Specifier@>==@{
RULE: xIoControlSpec ::= 'end=' xLblRef 
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xLblRef.codechain,
        f2c_flag,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "end",
        ConstVal(f2c_flag, 1));

    xIoControlSpec.iostatAddr = 
        IF(EQ(xIoControlSpec.iostatAddr, NoInstruction),
            INCLUDING xStmt.tempiostAddr,
            xIoControlSpec.iostatAddr);

    xIoControlSpec.endLab = GetTgtLabel(xLblRef.UnitKey, NoLabelSym)
    <- INCLUDING xProgramUnit.GotAllTgtLbls;
END;
@}


@B

The READ statement is the data transfer input statement. The WRITE and
PRINT statements are the data transfer output statements.

@$@<READ, WRITE, and PRINT Statements@>+=@{
@<Control Information List@>
@<Input/Output List@>
@<PRINT Statement@>
@<WRITE Statement@>
@<READ Statement@>
@}

READ, WRITE, and PRINT statements are implemented by a library call pair
of @{s_wsfe()@}/@{e_wsfe@}, with a call sequence of @{do_fio@} in between, 
for formated input/output. For unformated input/outout, @{s_wsle()@}
@{e_wsle()@}, and @{do_lio@} should be used respectively.

@$@<Append Call s_wsfe@>@(@8@)@M@{
    @1 = AppCall_s_wsfe(@2, @3, @4, @5, @6, @7, @8);
@}

@$@<Append Call e_wsfe@>@(@7@)@M@{
    @1 = AppCall_e_wsfe(@2, @3, @4, @5, @6, @7);
@}

@$@<READ Statement@>==@{
RULE: xStmt ::= xLblDef 'read' xIoControlSpec xInputItemList xEOS
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDIN@,0@,NoVarSym@,0@)
    @<Append Call s_wsfe@>@(
        xInputItemList.codechain@,
        xIoControlSpec.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpec.iostatAddr@,
        xStmt.i77listVar@,
        xIoControlSpec.errLab@,
        xIoControlSpec.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        xInputItemList.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpec.iostatAddr@,
        xIoControlSpec.errLab@,
        xIoControlSpec.endLab@,
        xStmt.fmtio@)
END;

RULE: xStmt ::= xLblDef 'read' xIoControlSpec xEOS
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDIN@,0@,NoVarSym@,0@)
    @<Append Call s_wsfe@>@(
        .tempcode@,
        xIoControlSpec.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpec.iostatAddr@,
        xStmt.i77listVar@,
        xIoControlSpec.errLab@,
        xIoControlSpec.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        .tempcode@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpec.iostatAddr@,
        xIoControlSpec.errLab@,
        xIoControlSpec.endLab@,
        xStmt.fmtio@)
END;

RULE: xStmt ::= xLblDef 'read' xFormatIdentifier ',' xInputItemList xEOS 
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDIN@,0@,xFormatIdentifier.fmtvar@,0@)
    @<Append Call s_wsfe@>@(
        xInputItemList.codechain@,
        xFormatIdentifier.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xStmt.i77listVar@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        xInputItemList.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
END;

RULE: xStmt ::= xLblDef 'read' xFormatIdentifier xEOS
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDIN@,0@,xFormatIdentifier.fmtvar@,0@)
    @<Append Call s_wsfe@>@(
        .tempcode@,
        xFormatIdentifier.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xStmt.i77listVar@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        .tempcode@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
END;
@}

@$@<WRITE Statement@>==@{
RULE: xStmt ::= 
    xLblDef 'write' '(' xIoControlSpecList ')' xOutputItemList xEOS
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDOUT@,0@,NoVarSym@,0@)
    @<Append Call s_wsfe@>@(
        xOutputItemList.codechain@,
        xIoControlSpecList.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpecList.iostatAddr@,
        xStmt.i77listVar@,
        xIoControlSpecList.errLab@,
        xIoControlSpecList.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        xOutputItemList.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpecList.iostatAddr@,
        xIoControlSpecList.errLab@,
        xIoControlSpecList.endLab@,
        xStmt.fmtio@)
END;

RULE: xStmt ::= xLblDef 'write' '(' xIoControlSpecList ')' xEOS
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDOUT@,0@,NoVarSym@,0@)
    @<Append Call s_wsfe@>@(
        .tempcode@,
        xIoControlSpecList.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpecList.iostatAddr@,
        xStmt.i77listVar@,
        xIoControlSpecList.errLab@,
        xIoControlSpecList.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        .tempcode@,
        INCLUDING xProgramUnit.suifscope@,
        xIoControlSpecList.iostatAddr@,
        xIoControlSpecList.errLab@,
        xIoControlSpecList.endLab@,
        xStmt.fmtio@)
END;
@}

@$@<PRINT Statement@>==@{
ATTR vardef: VarDef;
CHAIN iostatAddr: Instruction;
CHAIN endLab: LabelSym;
CHAIN errLab: LabelSym;
%ATTR cilistVar: VarSym;
ATTR tempiostAddr: Instruction;
ATTR i77listVar: VarSym;
ATTR i77kind: DefTableKey;
ATTR fmtio: int;
CHAIN fmtiochain: int;

#define STDOUT 6
#define STDIN 5

SYMBOL xStmt COMPUTE
    SYNT.i77listVar = NoVarSym;
    SYNT.i77kind = NoKey;
    SYNT.tempiostAddr = NoInstruction;
    CHAINSTART HEAD.fmtiochain = 0;
    SYNT.fmtio = TAIL.fmtiochain;
    @<Chain start iostatAddr, endLab, errLab@>
END;

SYMBOL xProgramStmt COMPUTE
    CHAINSTART HEAD.fmtiochain = 0;
    @<Chain start iostatAddr, endLab, errLab@>
END;

SYMBOL xProgramUnit COMPUTE
    CHAINSTART HEAD.fmtiochain = 0;
    @<Chain start iostatAddr, endLab, errLab@>
END;


SYMBOL xBlockDataStmt COMPUTE
    CHAINSTART HEAD.fmtiochain = 0;
    @<Chain start iostatAddr, endLab, errLab@>
END;

RULE: xStmt ::= xLblDef 'print' xFormatIdentifier ',' xOutputItemList xEOS
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDOUT@,0@,xFormatIdentifier.fmtvar@,0@)
    @<Append Call s_wsfe@>@(
        xOutputItemList.codechain@,
        xFormatIdentifier.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xStmt.i77listVar@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@,
        xOutputItemList.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
END;
    
RULE: xStmt ::= xLblDef 'print' xFormatIdentifier xEOS 
COMPUTE
    xStmt.i77kind = cilistKey;
    @<Create a temp for iostat@>
    @<Create a cilist variable@>
    @<Initialize cilist variable@>@(0@,STDOUT@,0@,xFormatIdentifier.fmtvar@,0@)
    @<Append Call s_wsfe@>@(
        .tempcode@,
        xFormatIdentifier.codechain@,
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xStmt.i77listVar@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
    @<Append Call e_wsfe@>@(
        xStmt.codechain@, 
        .tempcode@, 
        INCLUDING xProgramUnit.suifscope@,
        xFormatIdentifier.iostatAddr@,
        xFormatIdentifier.errLab@,
        xFormatIdentifier.endLab@,
        xStmt.fmtio@)
END;
@}

@$@<Chain start iostatAddr, endLab, errLab@>@M@{
    CHAINSTART HEAD.iostatAddr = NoInstruction;
    CHAINSTART HEAD.endLab = NoLabelSym;
    CHAINSTART HEAD.errLab = NoLabelSym;
@}


@C@<Control Information List@>

The struct type @{cilist@} is used for READ, WRITE, and PRINT statements.

@$@<Definition table keys for predefined structure@>+=@{
cilistKey;
@}

@$@<Predefined structure@>+=@{
int of = 0;
#define setfieldname(str, num, name) \
    {for(int i=0; i<num; i++) \
        MEMBER(str, set_field_name(i, name[i]));}
#define setfieldtype(str, num, typ) \
    {for(int i=0; i<num; i++) \
        MEMBER(str, set_field_type(i, typ[i]));}
#define setoffset(str, num, typ) \
    {of = 0;\
     for(int i=0; i<num; i++) {\
        MEMBER(str, set_offset(i, of));\
        of += MEMBER(typ[i], size());\
     }}

TypeNode CharPtrType = NewType(ptr_type(type_char));

StructType cilistStruct =
    NEW(struct_type(
        TYPE_STRUCT,
	2*MEMBER(f2c_flag, size()) + 2*MEMBER(f2c_int, size()) +
          MEMBER(CharPtrType, size()),
        "cilist",
        5));

char *cilistfldname[] =
    { "err", "unit", "end", "fmt", "rec" };
TypeNode cilistfldtype[] =
    { f2c_flag, f2c_int, f2c_flag, CharPtrType, f2c_int };

setfieldname(cilistStruct, 5, cilistfldname);
setfieldtype(cilistStruct, 5, cilistfldtype);
setoffset(cilistStruct, 5, cilistfldtype);

TypeNode cilistType = InstallType(cilistStruct);

ResetTgtType(cilistKey, cilistType);
ResetPtrTgtType(cilistKey, NewType(ptr_type(cilistType)));
ResetStructTgtType(cilistKey, cilistStruct);
@}

@$@<Create a cilist variable@>@M@{
    @<Create an i77 list variable@>@(cilistKey@, "ci__"@)
@}

@$@<Initialize cilist variable@>@(@5@)@M@{
    .vardef = MEMBER(
        INCLUDING xProgramUnit.suifscope,
        define_var(
            xStmt.i77listVar,
            MEMBER(NewType(ptr_type(type_char)), size())));

    ORDER(
%cierr
        MEMBER(
            .vardef,
            append_annote(
                k_repeat_init,
                NEW(immed_list(
                    immed(1),
                    immed(MEMBER(f2c_flag, size())),
                    immed(@1))))),
%ciunit
        MEMBER(
            .vardef,
            append_annote(
                k_repeat_init,
                NEW(immed_list(
                    immed(1),
                    immed(MEMBER(f2c_int, size())),
                    immed(@2))))),
%ciend
        MEMBER(
            .vardef,
            append_annote(
                k_repeat_init,
                NEW(immed_list(
                    immed(1),
                    immed(MEMBER(f2c_flag, size())),
                     immed(@3))))),
%cifmt
        MEMBER(
            .vardef,
            append_annote(
                k_repeat_init,
                NEW(immed_list(
                    immed(1),
                    immed(MEMBER(NewType(ptr_type(type_char)), size())),
                    IF(EQ(@4, NoVarSym),
                        immed(0),
                        immed(@4)))))),
%cirec
        MEMBER(
            .vardef,
            append_annote(
                k_repeat_init,
                NEW(immed_list(
                    immed(1),
                    immed(MEMBER(f2c_int, size())),
                    immed(@5))))));
@}

@$@<Control Information List@>==@{
ATTR Address: Instruction;

RULE: xIoControlSpecList ::= xUnitIdentifier 
COMPUTE
@<Assign unit@>@(xIoControlSpecList.codechain@, xUnitIdentifier@,
    INCLUDING xStmt.i77listVar@, INCLUDING xStmt.i77kind@)
END;

RULE: xIoControlSpecList ::= xUnitIdentifier ',' xFormatIdentifier
COMPUTE
@<Assign unit@>@(xFormatIdentifier.codechain@, xUnitIdentifier@,
    INCLUDING xStmt.i77listVar@, INCLUDING xStmt.i77kind@)
    xIoControlSpecList.codechain = IF(NE(xFormatIdentifier.fmtvar, NoVarSym),
        AppAssignField(
            xFormatIdentifier.codechain,
            NewType(ptr_type(type_char)),
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "fmt",
            xFormatIdentifier.Datum),
        xFormatIdentifier.codechain);
END;

RULE: xIoControlSpecList ::= xUnitIdentifier ',' xIoControlSpec 
COMPUTE
@<Assign unit@>@(xIoControlSpec.codechain@, xUnitIdentifier@,
    INCLUDING xStmt.i77listVar@, INCLUDING xStmt.i77kind@)
END;

RULE: xIoControlSpec ::= xRdUnitId
COMPUTE
@<Assign unit@>@(xIoControlSpec.codechain@, xRdUnitId@,
    INCLUDING xStmt.i77listVar@, INCLUDING xStmt.i77kind@)
END;
@}

@$@<I77 function interface@>+=@{
TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppAssignField
(TreeNodeList codechain, 
TypeNode tgttype, VarSym dst, DefTableKey key, char *field, operand datum);
#else
AppAssignField();
#endif
@}

@$@<I77 function call@>+=@{
TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppAssignField
(TreeNodeList codechain, 
TypeNode tgttype, VarSym dst, DefTableKey key, char *field, operand datum)
#else
AppAssignField(codechain, tgttype, dst, key, field, datum)
TreeNodeList codechain; 
TypeNode tgttype; VarSym dst; DefTableKey key; char *field; operand datum; 
#endif
{
    if(dst == NoVarSym)
        return codechain;

    StructType strtype = GetStructTgtType(key, NoStructType);

    LdAddress dst_fld = ConstInstr(NewType(ptr_type(tgttype)), sym_addr(dst,
        FieldOffset(strtype, field)));
    MEMBER(dst_fld, append_annote(k_fields, NEW(immed_list(immed(field)))));

    codechain = AppendTreeNode(codechain, 
        Store(tgttype, operand(dst_fld), datum));

    return codechain;
}
@}

@C

An input/output list specifies the entities whose values are transferred 
by a data transfer input/output statement.

@$@<Input/Output List@>==@{
@<Input List Items@>
@<Output List Items@>
@<Implied-DO List@>
@}

@$@<lioKind const@>@(@2@)@M@{
    IF(@1, NoKey, GetlioKind(OilTypeName(@2.TypeCode), NoKey))
@}

@D

@$@<Input List Items@>==@{
ATTR addrDatum: operand;
ATTR sizeDatum: operand;

RULE: xInputItemList ::= xInputItem
COMPUTE
END;

RULE: xInputItemList ::= xInputItemList ',' xInputItem
COMPUTE
END;

SYMBOL xVariable COMPUTE
  SYNT.TypeCode=
    GetOilType(
      GetType(CONSTITUENT xVariableName.UnitKey, NoKey),
      OilErrorType());
END;

RULE: xInputItem ::= xVariable
COMPUTE
    .vartype = GetType(CONSTITUENT xVariableName.UnitKey, NoKey)
    <- INCLUDING xProgramUnit.GotAllTypes;
    .addrDatum = xVariable.addrDatum;
    .sizeDatum = IF(EQ(.vartype, CharacterType),
        xVariable.lenDatum,
        xVariable.sizeDatum);

    xInputItem.codechain = AppCall_do_fio(
        xVariable.codechain,
        INCLUDING xProgramUnit.suifscope,
        xInputItem.iostatAddr,
        .addrDatum,
        .sizeDatum,
        xInputItem.errLab,
        xInputItem.endLab,
        @<lioKind const@>@(INCLUDING xStmt.fmtio@, xVariable@))
    <- INCLUDING xSourceFile.GotAllConst;
END;

SYMBOL xVariable COMPUTE
    SYNT.addrDatum = ConstVal(NewType(ptr_type(type_char)), 0);
    SYNT.sizeDatum = ConstVal(f2c_int, 0);
    SYNT.lenDatum = ConstVal(f2c_len, 0);
END;

SYMBOL xScalarVariable COMPUTE
    SYNT.lenDatum = ConstVal(f2c_len, 0);
END;

RULE: xVariable ::= xVariableName
COMPUTE
    .varsym = GetVariable(xVariableName.ObjectKey, NoVarSym)
    <- xVariableName.havedef;
    .vartype = GetType(xVariableName.UnitKey, NoKey)
    <- INCLUDING xProgramUnit.GotAllTypes;
    xVariable.addrDatum = IF(InIS(DummyArgument, 
                                  GetKindSet(xVariableName.UnitKey, NullIS())),
        operand(.varsym),
        ConstVal(@<Target type for@>@(xVariableName@), .varsym))
    <- INCLUDING xProgramUnit.ClassificationDone;

    xVariable.sizeDatum = %for char, use lenDatum
        ConstVal(f2c_int,
            DIV(MEMBER(GetTgtType(.vartype, type_void), size()), 8));
END;

RULE: xVariable ::= xVariableName '(' Subscripts ')'
COMPUTE
    @<Establish array instruction@>@(xVariableName@, Subscripts@)
    .vartype = GetType(xVariableName.UnitKey, NoKey)
    <- INCLUDING xProgramUnit.GotAllTypes;
    xVariable.addrDatum = operand(Subscripts.ArrayInstruction);
    xVariable.sizeDatum = %for char, use lenDatum
        ConstVal(f2c_int,
            DIV(MEMBER(GetTgtType(.vartype, type_void), size()), 8));
END;

RULE: xVariable ::= xVariableName xSubstringRange
COMPUTE
END;

RULE: xVariable ::= xVariableName '(' Subscripts ')' xSubstringRange
COMPUTE
    @<Establish array instruction@>@(xVariableName@, Subscripts@)
END;

RULE: Subscripts ::= xSubscriptList
COMPUTE
  xSubscriptList.ArrayInstruction=Subscripts.ArrayInstruction;
END;

RULE: xInputItem ::= xInputImpliedDo
COMPUTE
END;

SYMBOL xSubscriptList INHERITS IndexList END;

RULE: xSubscriptList ::= xSubscript
COMPUTE
    xSubscriptList.indexdone= IF(NE(xSubscriptList.ArrayInstruction,NoIndex),
        MEMBER(
            xSubscriptList.ArrayInstruction,
            set_index(xSubscriptList.SuifIndex, xSubscript.Datum)));
END;

RULE: xSubscriptList ::= xSubscriptList ',' xSubscript
COMPUTE
    xSubscriptList[1].indexdone=
        IF(NE(xSubscriptList[1].ArrayInstruction, NoIndex),
            MEMBER(
                xSubscriptList[1].ArrayInstruction,
                set_index(xSubscriptList[1].SuifIndex, xSubscript.Datum)));
    xSubscriptList[2].SuifIndex=ADD(xSubscriptList[1].SuifIndex,1);
    xSubscriptList[2].ArrayInstruction=
        xSubscriptList[1].ArrayInstruction;
END;
@}

@D

@$@<Output List Items@>==@{
ATTR sizeDatum1, sizeDatum2: operand;
ATTR lenDatum: operand;
ATTR addrDatum1, addrDatum2: operand;
ATTR tempvar1, tempvar2: VarSym;
ATTR tempcode1, tempcode2: TreeNodeList;


SYMBOL xExpr COMPUTE
    SYNT.lenDatum = ConstVal(f2c_len, 0);
END;

RULE: xOutputItemList ::= xExpr
COMPUTE
    @<Create a temp var for output@>@(.tempvar1@, xExpr@)
    @<Assign temp for output@>@(.tempcode1@, .tempvar1@, xExpr@)
    @<Assign addrDatum for output@>@(.addrDatum1@, .tempvar1@)
    @<Assign sizeDatum@>@(.sizeDatum1@, xExpr@)
    xOutputItemList.codechain = IF(NE(.tempvar1, NoVarSym),
        AppCall_do_fio(
            .tempcode1,
            INCLUDING xProgramUnit.suifscope,
            xOutputItemList.iostatAddr,
            .addrDatum1,
            .sizeDatum1,
            xOutputItemList.errLab,
            xOutputItemList.endLab,
            @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr@)),
        .tempcode1)
    <- INCLUDING xSourceFile.GotAllConst;
END;

RULE: xOutputItemList ::= xExpr ',' xExpr
COMPUTE
    @<Create a temp var for output@>@(.tempvar1@, xExpr[1]@)
    @<Assign temp for output@>@(.tempcode1@, .tempvar1@, xExpr[1]@)
    @<Assign addrDatum for output@>@(.addrDatum1@, .tempvar1@)
    @<Assign sizeDatum@>@(.sizeDatum1@, xExpr[1]@)
    xExpr[2].codechain = IF(NE(.tempvar1, NoVarSym),
        AppCall_do_fio(
            .tempcode1,
            INCLUDING xProgramUnit.suifscope,
            xOutputItemList.iostatAddr,
            .addrDatum1,
            .sizeDatum1,
            xOutputItemList.errLab,
            xOutputItemList.endLab,
            @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr[1]@)),
        .tempcode1)
    <- INCLUDING xSourceFile.GotAllConst;

    @<Create a temp var for output@>@(.tempvar2@, xExpr[2]@)
    @<Assign temp for output@>@(.tempcode2@, .tempvar2@, xExpr[2]@)
    @<Assign addrDatum for output@>@(.addrDatum2@, .tempvar2@)
    @<Assign sizeDatum@>@(.sizeDatum2@, xExpr[2]@)

    xOutputItemList.codechain = IF(NE(.tempvar2, NoVarSym),
        AppCall_do_fio(
            .tempcode2,
            INCLUDING xProgramUnit.suifscope,
            xOutputItemList.iostatAddr,
            .addrDatum2,
            .sizeDatum2,
            xOutputItemList.errLab,
            xOutputItemList.endLab,
            @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr[2]@)),
        .tempcode2)
    <- INCLUDING xSourceFile.GotAllConst;
END;

RULE: xOutputItemList ::= xExpr ',' xOutputImpliedDo 
COMPUTE
    @<Create a temp var for output@>@(.tempvar1@, xExpr@)
    @<Assign temp for output@>@(.tempcode1@, .tempvar1@, xExpr@)
    @<Assign addrDatum for output@>@(.addrDatum1@, .tempvar1@)
    @<Assign sizeDatum@>@(.sizeDatum1@, xExpr@)
    xOutputImpliedDo.codechain = IF(NE(.tempvar1, NoVarSym),
        AppCall_do_fio(
            .tempcode1,
            INCLUDING xProgramUnit.suifscope,
            xOutputItemList.iostatAddr,
            .addrDatum1,
            .sizeDatum1,
            xOutputItemList.errLab,
            xOutputItemList.endLab,
            @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr@)),
        .tempcode1)
    <- INCLUDING xSourceFile.GotAllConst;
END;

RULE: xOutputItemList ::= xOutputImpliedDo
COMPUTE
END;

RULE: xOutputItemList ::= xOutputItemList ',' xExpr 
COMPUTE
    @<Create a temp var for output@>@(.tempvar1@, xExpr@)
    @<Assign temp for output@>@(.tempcode1@, .tempvar1@, xExpr@)
    @<Assign addrDatum for output@>@(.addrDatum1@, .tempvar1@)
    @<Assign sizeDatum@>@(.sizeDatum1@, xExpr@)
    xOutputItemList[1].codechain = IF(NE(.tempvar1, NoVarSym),
        AppCall_do_fio(
            .tempcode1,
            INCLUDING xProgramUnit.suifscope,
            xOutputItemList[1].iostatAddr,
            .addrDatum1,
            .sizeDatum1,
            xOutputItemList[1].errLab,
            xOutputItemList[1].endLab,
            @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr@)),
        .tempcode1)
    <- INCLUDING xSourceFile.GotAllConst;
END;

RULE: xOutputItemList ::= xOutputItemList ',' xOutputImpliedDo
COMPUTE
END;
@}

@D

@$@<Implied-DO List@>==@{
ATTR DoVariable: VarSym;

RULE: xInputImpliedDo ::=
  '(' xInputItemList ',' xImpliedDoVariable '=' xExpr ',' xExpr ')' 
COMPUTE
    @<Implied-DO List body code@>@(
        xInputImpliedDo@, xInputItemList@, xImpliedDoVariable@)

    .DoVariable = @<Variable symbol@>@(xImpliedDoVariable@);

    @<Implied-DO List for loop@>@(xInputImpliedDo@, xExpr[2]@, .Body@,
        xExpr[1].Datum@, xExpr[2].Datum@, 
        ConstVal(GetTgtType(IntegerType,type_error),1)@)
END;

RULE: xInputImpliedDo ::= 
  '(' xInputItemList ',' xImpliedDoVariable '=' xExpr ',' xExpr ',' xExpr ')'
COMPUTE
    @<Implied-DO List body code@>@(
        xInputImpliedDo@,xInputItemList@,xImpliedDoVariable@)

    .DoVariable = @<Variable symbol@>@(xImpliedDoVariable@);

    @<Implied-DO List for loop@>@(xInputImpliedDo@, xExpr[3]@, .Body@,
        xExpr[1].Datum@, xExpr[2].Datum@, xExpr[3].Datum@)
END;

RULE: xOutputImpliedDo ::= 
  '(' xExpr ',' xImpliedDoVariable '=' xExpr ',' xExpr ')'
COMPUTE
    @<Create a temp var for output@>@(.tempvar1@, xExpr[1]@)
    @<Assign temp for output@>@(.tempcode1@, .tempvar1@, xExpr[1]@)
    @<Assign addrDatum for output@>@(.addrDatum1@, .tempvar1@)
    @<Assign sizeDatum@>@(.sizeDatum1@, xExpr[1]@)

    .DoVariable = @<Variable symbol@>@(xImpliedDoVariable@);

    @<Implied-DO List for loop@>@(xOutputImpliedDo@, xExpr[3]@,
        IF(NE(.tempvar1, NoVarSym),
            AppCall_do_fio(
                NEW(tree_node_list()),
                INCLUDING xProgramUnit.suifscope,
                xOutputImpliedDo.iostatAddr,
                .addrDatum1,
                .sizeDatum1,
                xOutputImpliedDo.errLab,
                xOutputImpliedDo.endLab,
                @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr[1]@)),
            NEW(tree_node_list()))@,
        xExpr[2].Datum@, xExpr[3].Datum@, 
        ConstVal(GetTgtType(IntegerType,type_error),1)@)
END;
                
RULE: xOutputImpliedDo ::=
  '(' xExpr ',' xImpliedDoVariable '=' xExpr ',' xExpr ',' xExpr ')'
COMPUTE
    @<Create a temp var for output@>@(.tempvar1@, xExpr[1]@)
    @<Assign temp for output@>@(.tempcode1@, .tempvar1@, xExpr[1]@)
    @<Assign addrDatum for output@>@(.addrDatum1@, .tempvar1@)
    @<Assign sizeDatum@>@(.sizeDatum1@, xExpr[1]@)

    .DoVariable = @<Variable symbol@>@(xImpliedDoVariable@);
    @<Implied-DO List for loop@>@(xOutputImpliedDo@, xExpr[4]@,
        IF(NE(.tempvar1, NoVarSym),
            AppCall_do_fio(
                NEW(tree_node_list()),
                INCLUDING xProgramUnit.suifscope,
                xOutputImpliedDo.iostatAddr,
                .addrDatum1,
                .sizeDatum1,
                xOutputImpliedDo.errLab,
                xOutputImpliedDo.endLab,
                @<lioKind const@>@(INCLUDING xStmt.fmtio@, xExpr[1]@)),
            NEW(tree_node_list()))@,
        xExpr[2].Datum@, xExpr[3].Datum@, xExpr[4].Datum@)
END;

RULE: xOutputImpliedDo ::= 
    '(' xOutputItemList ',' xImpliedDoVariable '=' xExpr ',' xExpr ')' 
COMPUTE
    @<Implied-DO List body code@>@(
        xOutputImpliedDo@, xOutputItemList@, xImpliedDoVariable@)

    .DoVariable = @<Variable symbol@>@(xImpliedDoVariable@);

    @<Implied-DO List for loop@>@(xOutputImpliedDo@, xExpr[2]@, .Body@,
        xExpr[1].Datum@, xExpr[2].Datum@,
        ConstVal(GetTgtType(IntegerType,type_error),1)@)
END;

RULE: xOutputImpliedDo ::= 
  '(' xOutputItemList ',' xImpliedDoVariable '=' xExpr ',' xExpr
    ',' xExpr ')'
COMPUTE
    @<Implied-DO List body code@>@(
        xOutputImpliedDo@, xOutputItemList@, xImpliedDoVariable@)
    .DoVariable = @<Variable symbol@>@(xImpliedDoVariable@);
    @<Implied-DO List for loop@>@(xOutputImpliedDo@, xExpr[3]@, .Body@,
        xExpr[1].Datum@, xExpr[2].Datum@, xExpr[3].Datum@)
END;
@}

@$@<Implied-DO List body code@>@(@3@)@M@{
    @2.codechain = NEW(tree_node_list());
    .Body = @2.codechain;
    @3.codechain = @1.codechain;
@}

@$@<Implied-DO List for loop@>@(@6@)@M@{
    @1.codechain = AppendTreeNode(@2.codechain,
        NEW(tree_for(
            .DoVariable,
            FOR_SGELE,
            MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L")),
            MEMBER(INCLUDING xProgramUnit.suifscope,new_unique_label("L")),
            @3, @4, @5, @6, NEW(tree_node_list()))))
    <- INCLUDING xSourceFile.GotAllConst;
@}


@$@<Create a temp var for output@>@(@2@)@M@{
    @1 = IF(NE(@2.TypeCode, OilTypeCharacterType),
        MEMBER(INCLUDING xProgramUnit.suifscope,
            new_unique_var(GetTgtType(OilTypeName(@2.TypeCode), type_error),
                "TOut_")),
        @2.charvar);
@}

For each datum of output, a variable is created to hold the value.

@$@<Assign temp for output@>@(@3@)@M@{
    @1 = IF(AND(NE(@2, NoVarSym),
                 NE(@3.TypeCode, OilTypeCharacterType)),
        AppendTreeNode(@3.codechain,
            Copy(GetTgtType(OilTypeName(@3.TypeCode), type_error),
                operand(@2), @3.Datum)),
        @3.codechain);
@}

@$@<Assign addrDatum for output@>@(@2@)@M@{
    @1 = ConstVal(NewType(ptr_type(type_char)), @2);
@}

@{lenDatum@} is for character length.

@$@<Assign sizeDatum@>@(@2@)@M@{
    @1 = IF(EQ(@2.TypeCode, OilTypeCharacterType),
        @2.lenDatum,
        ConstVal(f2c_int,
            DIV(
                MEMBER(GetTgtType(OilTypeName(@2.TypeCode), type_void), 
                     size()), 
                8)));
@}
        
@B

@$@<Auxiliary Input/Output Statements@>==@{
@<OPEN Statement@>
@<CLOSE Statement@>
@<INQUIRE Statement@>
@<File Positioning Statements@>
@}

@C

@$@<OPEN Statement@>+=@{
ATTR charptrtyp: TypeNode;

RULE: xStmt ::= xLblDef 'open' '(' xIoControlSpecList ')' xEOS 
COMPUTE
    xStmt.i77kind = olistKey;
    @<Create a temp for iostat@>
    @<Create an olist variable@>
    @<Initialize olist variable@>
    xStmt.codechain = AppCall_f_open(
        xIoControlSpecList.codechain,
        INCLUDING xProgramUnit.suifscope,
        xIoControlSpecList.iostatAddr,
        xStmt.i77listVar,
        xIoControlSpecList.errLab);
END;
@}

@$@<Create an olist variable@>@M@{
    @<Create an i77 list variable@>@(olistKey@, "o__"@)
@}

@$@<Initialize olist variable@>@M@{
    .vardef = MEMBER(
        INCLUDING xProgramUnit.suifscope,
        define_var(
            xStmt.i77listVar,
            MEMBER(NewType(ptr_type(type_char)), size())));

    .charptrtyp = NewType(ptr_type(type_char));

    ORDER(
%oerr
        VarDefRepeatInit(.vardef, f2c_flag, 0),
%ounit
        VarDefRepeatInit(.vardef, f2c_int, STDOUT),
%ofnm
        VarDefRepeatInit(.vardef, .charptrtyp, 0),
%ofnmlen
        VarDefRepeatInit(.vardef, f2c_len, 0),
%osta
        VarDefRepeatInit(.vardef, .charptrtyp, 0),
%oacc
        VarDefRepeatInit(.vardef, .charptrtyp, 0),
%ofm 
        VarDefRepeatInit(.vardef, .charptrtyp, 0),
%orl
        VarDefRepeatInit(.vardef, f2c_int, 0),
%oblnk
        VarDefRepeatInit(.vardef, .charptrtyp, 0)); 
@}

@$@<Create an i77 list variable@>@(@2@)@M@{
    xStmt.i77listVar = MEMBER(
        INCLUDING xProgramUnit.suifscope,
        new_unique_var(
            GetTgtType(@1, type_error),
            @2));
@}


@$@<OPEN Statement@>+=@{

%olist, inlist
RULE: xIoControlSpec ::= 'file=' xExpr
COMPUTE
    .tempcode = AppAssignField(
        xExpr.codechain, 
        f2c_len, 
        INCLUDING xStmt.i77listVar, 
        INCLUDING xStmt.i77kind,
        "filen",
        xExpr.lenDatum);

    xIoControlSpec.codechain = AppAssignField(
        .tempcode,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "file",
        ConstVal(NewType(ptr_type(type_char)), xExpr.charvar));
END;

%olist, cllist
RULE: xIoControlSpec ::= 'status=' xExpr
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xExpr.codechain,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "sta",
        ConstVal(NewType(ptr_type(type_char)), xExpr.charvar));
END;

%olist, inlist
RULE: xIoControlSpec ::= 'access=' xExpr
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xExpr.codechain,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "acc",
        ConstVal(NewType(ptr_type(type_char)), xExpr.charvar));
END;

%olist, inlist
RULE: xIoControlSpec ::= 'form=' xExpr
COMPUTE
    .tempcode = IF(EQ(INCLUDING xStmt.i77kind, inlistKey),
        AppAssignField(
            xExpr.codechain,
            f2c_len,
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "fmtlen",
            xExpr.lenDatum),
        xExpr.codechain);

    xIoControlSpec.codechain = IF(EQ(INCLUDING xStmt.i77kind, inlistKey),
        IF(NE(xExpr.Address, NoInstruction),
            AppAssignField(
                .tempcode,
                NewType(ptr_type(type_char)),
                INCLUDING xStmt.i77listVar,
                INCLUDING xStmt.i77kind,
                "fmt",
                operand(xExpr.Address)),
            .tempcode),
        AppAssignField(
            xExpr.codechain,
            NewType(ptr_type(type_char)),
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "fm",
            ConstVal(NewType(ptr_type(type_char)), xExpr.charvar)));
END;

%olist, inlist
RULE: xIoControlSpec ::= 'recl=' xExpr
COMPUTE
    xIoControlSpec.codechain = IF(EQ(INCLUDING xStmt.i77kind, inlistKey),
        IF(NE(xExpr.Address, NoInstruction),
            AppAssignField(
                xExpr.codechain,
                NewType(ptr_type(f2c_int)),
                INCLUDING xStmt.i77listVar,
                INCLUDING xStmt.i77kind,
                "recl",
                operand(xExpr.Address)),
            xExpr.codechain),
        AppAssignField(
            xExpr.codechain,
            f2c_int,
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "rl",
            xExpr.Datum));
END;

%olist, inlist
RULE: xIoControlSpec ::= 'blank=' xExpr
COMPUTE
    .tempcode = IF(EQ(INCLUDING xStmt.i77kind, inlistKey),
        AppAssignField(
            xExpr.codechain,
            f2c_len,
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "blanklen",
            xExpr.lenDatum),
        xExpr.codechain);

    xIoControlSpec.codechain = IF(EQ(INCLUDING xStmt.i77kind, inlistKey),
        IF(NE(xExpr.Address, NoInstruction),
            AppAssignField(
                .tempcode,
                NewType(ptr_type(type_char)),
                INCLUDING xStmt.i77listVar,
                INCLUDING xStmt.i77kind,
                "blank",
                operand(xExpr.Address)),
            .tempcode),
        AppAssignField(
            xExpr.codechain,
            NewType(ptr_type(type_char)),
            INCLUDING xStmt.i77listVar,
            INCLUDING xStmt.i77kind,
            "blnk",
            ConstVal(NewType(ptr_type(type_char)), xExpr.charvar)));
END;

RULE: xIoControlSpec ::= 'exist=' xScalarVariable
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xScalarVariable.codechain,
        NewType(ptr_type(f2c_int)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "ex",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'opened=' xScalarVariable
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xScalarVariable.codechain,
        NewType(ptr_type(f2c_int)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "open",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'number=' xScalarVariable
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xScalarVariable.codechain,
        NewType(ptr_type(f2c_int)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "num",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'named=' xScalarVariable
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xScalarVariable.codechain,
        NewType(ptr_type(f2c_int)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "named",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'name=' xScalarVariable
COMPUTE
    .tempcode = AppAssignField(
        xScalarVariable.codechain,
        f2c_len,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "namlen",
        xScalarVariable.lenDatum);

    xIoControlSpec.codechain = AppAssignField(
        .tempcode,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "name",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'sequential=' xScalarVariable 
COMPUTE
    .tempcode = AppAssignField(
        xScalarVariable.codechain,
        f2c_len,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "seqlen",
        xScalarVariable.lenDatum);

    xIoControlSpec.codechain = AppAssignField(
        .tempcode,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "seq",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'direct=' xScalarVariable
COMPUTE
    .tempcode = AppAssignField(
        xScalarVariable.codechain,
        f2c_len,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "dirlen",
        xScalarVariable.lenDatum);

    xIoControlSpec.codechain = AppAssignField(
        .tempcode,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "dir",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'formatted=' xScalarVariable 
COMPUTE
    .tempcode = AppAssignField(
        xScalarVariable.codechain,
        f2c_int,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "formlen",
        xScalarVariable.lenDatum);

    xIoControlSpec.codechain = AppAssignField(
        .tempcode,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "form",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'unformatted=' xScalarVariable
COMPUTE
    .tempcode = AppAssignField(
        xScalarVariable.codechain,
        f2c_len,
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "unflen",
        xScalarVariable.lenDatum);

    xIoControlSpec.codechain = AppAssignField(
        .tempcode,
        NewType(ptr_type(type_char)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "unf",
        operand(xScalarVariable.Address));
END;

RULE: xIoControlSpec ::= 'nextrec=' xScalarVariable
COMPUTE
    xIoControlSpec.codechain = AppAssignField(
        xScalarVariable.codechain,
        NewType(ptr_type(f2c_int)),
        INCLUDING xStmt.i77listVar,
        INCLUDING xStmt.i77kind,
        "nrec",
        operand(xScalarVariable.Address));
END;
@}

@$@<Definition table keys for predefined structure@>+=@{
olistKey;
@}

@$@<Predefined structure@>+=@{
StructType olistStruct = 
    NEW(struct_type(
        TYPE_STRUCT,
	MEMBER(f2c_flag, size()) + 2*MEMBER(f2c_int, size()) +
	  MEMBER(f2c_len, size()) + 5*MEMBER(CharPtrType, size()),
        "olist",
        9));

char *olistfldname[] = 
    {"err","unit","file","filen","sta","acc","fm","rl","blnk"};
TypeNode olistfldtype[] =
    {f2c_flag, f2c_int, CharPtrType, f2c_len, CharPtrType,
    CharPtrType, CharPtrType, f2c_int, CharPtrType};

setfieldname(olistStruct, 9, olistfldname);
setfieldtype(olistStruct, 9, olistfldtype);
setoffset(olistStruct, 9, olistfldtype);

TypeNode olistType = InstallType(olistStruct);

ResetTgtType(olistKey, olistType);
ResetPtrTgtType(olistKey, NewType(ptr_type(olistType)));
ResetStructTgtType(olistKey, olistStruct);
@}

@C

@$@<CLOSE Statement@>+=@{
RULE: xStmt ::= xLblDef 'close' '(' xIoControlSpecList ')' xEOS
COMPUTE
    xStmt.i77kind = cllistKey;
    @<Create a temp for iostat@>
    @<Create a cllist variable@>
    @<Initialize cllist variable@>
    xStmt.codechain = AppCall_f_clos(
        xIoControlSpecList.codechain,
        INCLUDING xProgramUnit.suifscope,
        xIoControlSpecList.iostatAddr,
        xStmt.i77listVar,
        xIoControlSpecList.errLab);
END;
@}

@$@<Create a cllist variable@>@M@{
    @<Create an i77 list variable@>@(cllistKey@, "cl__"@)
@}

@$@<Initialize cllist variable@>@M@{
    .vardef = MEMBER(
        INCLUDING xProgramUnit.suifscope,
        define_var(
            xStmt.i77listVar,
            MEMBER(NewType(ptr_type(type_char)), size())));

    .charptrtyp = NewType(ptr_type(type_char));

    ORDER(
%cerr
        VarDefRepeatInit(.vardef, f2c_flag, 0),
%cunit
        VarDefRepeatInit(.vardef, f2c_int, STDOUT),
%csta
        VarDefRepeatInit(.vardef, .charptrtyp, 0));
@}

@$@<CLOSE Statement@>+=@{
@}

@$@<Definition table keys for predefined structure@>+=@{
cllistKey;
@}

@$@<Predefined structure@>+=@{
StructType cllistStruct =
    NEW(struct_type(
        TYPE_STRUCT,
        MEMBER(f2c_flag, size()) + MEMBER(f2c_int, size()) +
	  MEMBER(CharPtrType, size()),
        "cllist",
        3));

char *cllistfldname[] = {"err", "unit", "sta"};
TypeNode cllistfldtype[] = {f2c_flag, f2c_int, CharPtrType};

setfieldname(cllistStruct, 3, cllistfldname);
setfieldtype(cllistStruct, 3, olistfldtype);
setoffset(cllistStruct, 3, olistfldtype);

TypeNode cllistType = InstallType(cllistStruct);

ResetTgtType(cllistKey, cllistType);
ResetPtrTgtType(cllistKey, NewType(ptr_type(cllistType)));
ResetStructTgtType(cllistKey, cllistStruct);
@}

@$@<Create an inlist variable@>@M@{
    @<Create an i77 list variable@>@(inlistKey@, "ioin_"@)
@}

@$@<Initialize inlist variable@>@M@{
    .vardef = MEMBER(
        INCLUDING xProgramUnit.suifscope,
        define_var(
            xStmt.i77listVar,
            MEMBER(NewType(ptr_type(type_char)), size())));

    MEMBER(.vardef, append_annote(k_repeat_init, NEW(immed_list(
        immed(DIV(MEMBER(GetTgtType(inlistKey, type_error), size()),
            MEMBER(NewType(ptr_type(type_char)), size()))),
        immed(MEMBER(NewType(ptr_type(type_char)), size())),
        immed(0)))));
@}

@C

@$@<INQUIRE Statement@>==@{
RULE: xStmt ::= xLblDef 'inquire' '(' xIoControlSpecList ')' xEOS
COMPUTE
    xStmt.i77kind = inlistKey;
    @<Create a temp for iostat@>
    @<Create an inlist variable@>
    @<Initialize inlist variable@>
    xStmt.codechain = AppCall_f_inqu(
        xIoControlSpecList.codechain,
        INCLUDING xProgramUnit.suifscope,
        xIoControlSpecList.iostatAddr,
        xStmt.i77listVar,
        xIoControlSpecList.errLab);
END;
@}

@$@<Definition table keys for predefined structure@>+=@{
inlistKey;
@}

@$@<Predefined structure@>+=@{
TypeNode IntPtrType = NewType(ptr_type(f2c_int));

StructType inlistStruct =
    NEW(struct_type(
        TYPE_STRUCT,
	MEMBER(f2c_flag, size())
	    + 2*MEMBER(f2c_int, size())
	    + 8*MEMBER(f2c_len, size())
            + 9*MEMBER(CharPtrType, size())
            + 6*MEMBER(IntPtrType, size()),
        "inlist",
        26));

char *inlistfldname[] = {"err",
    "unit", "file", "filen", "ex", "open",
    "num", "named", "name", "namlen", "acc",
    "acclen", "seq", "seqlen", "dir", "dirlen",
    "fmt", "fmtlen", "form", "formlen", "unf",
    "unflen", "recl", "nrec", "blank", "blanklen"};
TypeNode inlistfldtype[] = {f2c_flag,
    f2c_int, CharPtrType, f2c_len, IntPtrType, IntPtrType,
    IntPtrType, IntPtrType, CharPtrType, f2c_len, CharPtrType,
    f2c_len, CharPtrType, f2c_len, CharPtrType, f2c_len,
    CharPtrType, f2c_len, CharPtrType, f2c_int, CharPtrType,
    f2c_len, IntPtrType, IntPtrType, CharPtrType, f2c_len};
 
setfieldname(inlistStruct, 26, inlistfldname);
setfieldtype(inlistStruct, 26, inlistfldtype);
setoffset(inlistStruct, 26, inlistfldtype);

TypeNode inlistType = InstallType(inlistStruct);

ResetTgtType(inlistKey, inlistType);
ResetPtrTgtType(inlistKey, NewType(ptr_type(inlistType)));
ResetStructTgtType(inlistKey, inlistStruct);
@}
         
        

@$@<File Positioning Statements@>==@{
@<BACKSPACE Statement@>
@<ENDFILE Statement@>
@<REWIND Statement@>
@}

@$@<Create an alist variable@>@M@{
    @<Create an i77 list variable@>@(alistKey@, "a__"@)
@}

@$@<Initialize alist variable@>@M@{
    .vardef = MEMBER(
        INCLUDING xProgramUnit.suifscope,
        define_var(
            xStmt.i77listVar,
            MEMBER(f2c_int, size())));

    ORDER(
%err
        VarDefRepeatInit(.vardef, f2c_flag, 0),
%unit
        VarDefRepeatInit(.vardef, f2c_int, STDOUT));
@}

@$@<BACKSPACE Statement@>==@{
RULE: xStmt ::= xLblDef 'backspace' xUnitIdentifier xEOS
COMPUTE
    xStmt.i77kind = alistKey;
    @<Create a temp for iostat@>
    @<Create an alist variable@>
    @<Initialize alist variable@>
    @<Assign unit@>@(.tempcode@, xUnitIdentifier@, 
        xStmt.i77listVar@, xStmt.i77kind@)
    xStmt.codechain = AppCall_f_back(
        .tempcode, 
        INCLUDING xProgramUnit.suifscope,
        xUnitIdentifier.iostatAddr,
        xStmt.i77listVar,
        xUnitIdentifier.errLab);
END;

RULE: xStmt ::= xLblDef 'backspace' '(' xIoControlSpecList ')' xEOS
COMPUTE
    xStmt.i77kind = alistKey;
    @<Create a temp for iostat@>
    @<Create an alist variable@>
    @<Initialize alist variable@>
    xStmt.codechain = AppCall_f_back(
        xIoControlSpecList.codechain,
        INCLUDING xProgramUnit.suifscope,
        xIoControlSpecList.iostatAddr,
        xStmt.i77listVar,
        xIoControlSpecList.errLab);
END;
@}

@$@<ENDFILE Statement@>==@{
RULE: xStmt ::= xLblDef 'endfile' xUnitIdentifier xEOS
COMPUTE
    xStmt.i77kind = alistKey;
    @<Create a temp for iostat@>
    @<Create an alist variable@>
    @<Initialize alist variable@>
    @<Assign unit@>@(.tempcode@, xUnitIdentifier@, 
        xStmt.i77listVar@, xStmt.i77kind@)
    xStmt.codechain = AppCall_f_rew(
        .tempcode,
        INCLUDING xProgramUnit.suifscope,
        xUnitIdentifier.iostatAddr,
        xStmt.i77listVar,
        xUnitIdentifier.errLab);
END;

RULE: xStmt ::= xLblDef 'endfile' '(' xIoControlSpecList ')' xEOS 
COMPUTE
    xStmt.i77kind = alistKey;
    @<Create a temp for iostat@>
    @<Create an alist variable@>
    @<Initialize alist variable@>
    xStmt.codechain = AppCall_f_rew(
        xIoControlSpecList.codechain,
        INCLUDING xProgramUnit.suifscope,
        xIoControlSpecList.iostatAddr,
        xStmt.i77listVar,
        xIoControlSpecList.errLab);
END;
@}

@$@<REWIND Statement@>==@{
RULE: xStmt ::= xLblDef 'rewind' xUnitIdentifier xEOS
COMPUTE
    xStmt.i77kind = alistKey;
    @<Create a temp for iostat@>
    @<Create an alist variable@>
    @<Initialize alist variable@>
    @<Assign unit@>@(.tempcode@, xUnitIdentifier@, 
        xStmt.i77listVar@, xStmt.i77kind@)
    xStmt.codechain = AppCall_f_rew(
        .tempcode, 
        INCLUDING xProgramUnit.suifscope,
        xUnitIdentifier.iostatAddr,
        xStmt.i77listVar,
        xUnitIdentifier.errLab);
END;

RULE: xStmt ::= xLblDef 'rewind' '(' xIoControlSpecList ')' xEOS
COMPUTE
    xStmt.i77kind = alistKey;
    @<Create a temp for iostat@>
    @<Create an alist variable@>
    @<Initialize alist variable@>
    xStmt.codechain = AppCall_f_rew(
        xIoControlSpecList.codechain,
        INCLUDING xProgramUnit.suifscope,
        xIoControlSpecList.iostatAddr,
        xStmt.i77listVar,
        xIoControlSpecList.errLab);
END;
@}



@$@<Definition table keys for predefined structure@>+=@{
alistKey;
@}

@$@<Predefined structure@>+=@{
StructType alistStruct =
    NEW(struct_type(
        TYPE_STRUCT,
        MEMBER(f2c_flag, size()) + MEMBER(f2c_int, size()),
        "alist",
        2));

char *alistfldname[] = {"err", "unit"};
TypeNode alistfldtype[] = {f2c_flag, f2c_int};

setfieldname(alistStruct, 2, alistfldname);
setfieldtype(alistStruct, 2, alistfldtype);
setoffset(alistStruct, 2, alistfldtype);

TypeNode alistType = InstallType(alistStruct);

ResetTgtType(alistKey, alistType);
ResetPtrTgtType(alistKey, NewType(ptr_type(alistType)));
ResetStructTgtType(alistKey, alistStruct);
@} 


@B@<Call to the I77 library functions@>

@$@<I77 function interface@>+=@{
TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
AppCall_s_wsfe(TreeNodeList codechain, ProcSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab, LabelSym endLab, int fmtio);
#else
AppCall_s_wsfe();
#endif

TreeNodeList 
#if defined(__cplusplus) || defined(__STDC__)
AppCall_e_wsfe
(TreeNodeList codechain, ProcSymtab dst_scope, Instruction iostatAddr,
    LabelSym errLab, LabelSym endLab, int fmtio);
#else
AppCall_e_wsfe();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_do_fio
(TreeNodeList codechain, ProcSymtab dst_scope,
    Instruction iostatAddr, operand addrDatum, operand sizeDatum,
    LabelSym errLab, LabelSym endLab, DefTableKey liokind);
#else
AppCall_do_fio();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_open(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab);
#else
AppCall_f_open();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_clos(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab);
#else
AppCall_f_clos();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_rew(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab);
#else
AppCall_f_rew();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_back(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab);
#else
AppCall_f_back();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_end(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab);
#else
AppCall_f_end();
#endif

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_inqu(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab);
#else
AppCall_f_inqu();
#endif
@}

@$@<I77 function call@>+=@{
#define Jump_end(cd, sc, st, lb) \
    {LabelSym ltemp1 = MEMBER(sc, new_unique_label("TempLab"));\
     cd = AppendTreeNode(cd, JumpFalse(ltemp1,\
              Dyadic(io_sl, f2c_int, Monadic(io_lod, f2c_int, st), \
                  ConstVal(f2c_int, 0))));\
     cd = AppendTreeNode(cd, Jump(lb));\
     cd = AppendTreeNode(cd, LabelDef(ltemp1));}

#define Jump_err(cd, sc, st, lb) \
    {LabelSym ltemp2 = MEMBER(sc, new_unique_label("TempLab"));\
     cd = AppendTreeNode(cd, JumpFalse(ltemp2,\
              Dyadic(io_sl, f2c_int, ConstVal(f2c_int, 0), \
                  Monadic(io_lod, f2c_int, st))));\
     cd = AppendTreeNode(cd, Jump(lb));\
     cd = AppendTreeNode(cd, LabelDef(ltemp2));}

#define Jump_err2(cd, sc, st, lb) \
    {LabelSym ltemp2 = MEMBER(sc, new_unique_label("L"));\
     cd = AppendTreeNode(cd, JumpFalse(ltemp2,\
              Dyadic(io_sne, f2c_int, Monadic(io_lod, f2c_int, st), \
                  ConstVal(f2c_int, 0))));\
     cd = AppendTreeNode(cd, Jump(lb));\
     cd = AppendTreeNode(cd, LabelDef(ltemp2));}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_s_wsfe(TreeNodeList codechain, ProcSymtab dst_scope, 
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab, LabelSym endLab, int fmtio)
#else
AppCall_s_wsfe(codechain, dst_scope, iostatAddr, i77listVar, 
  errLab, endLab, fmtio)
TreeNodeList codechain; ProcSymtab dst_scope; 
Instruction iostatAddr; VarSym i77listVar;
LabelSym errLab; LabelSym endLab; int fmtio;
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    static TypeNode s_wsfertntype = GetTgtType(s_wsfeKey, type_error);
    static TypeNode s_wsfeptrtype = GetPtrTgtType(s_wsfeKey, type_error);
    ProcSym s_wsfesym = (fmtio)? GetProcedure(s_wsfeKey, NoProcSym):
        GetProcedure(s_wsleKey, NoProcSym);
    TypeNode cilistptrtype = GetPtrTgtType(cilistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_s_wsfe = NEW(
        in_cal(
            s_wsfertntype,
            operand(),
            ConstVal(s_wsfeptrtype, s_wsfesym),
            1));

    MEMBER(call_s_wsfe, set_argument(0, ConstVal(cilistptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, ( iostatAddr == NoInstruction)?
        NEW(tree_instr(call_s_wsfe)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_s_wsfe)));

    if (endLab != NoLabelSym)
        Jump_end(codechain, dst_scope, iostatDatum.clone(dst_scope), endLab);

    if (errLab != NoLabelSym)
        Jump_err(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_e_wsfe
(TreeNodeList codechain, ProcSymtab dst_scope, Instruction iostatAddr,
    LabelSym errLab, LabelSym endLab, int fmtio)
#else
AppCall_e_wsfe(codechain, dst_scope, iostatAddr, errLab, endLab, fmtio)
TreeNodeList codechain; ProcSymtab dst_scope, Instruction iostatAddr;
LabelSym errLab; LabelSym endLab; int fmtio;
#endif
{
    static TypeNode e_wsfertntype = GetTgtType(e_wsfeKey, type_error);
    static TypeNode e_wsfeptrtype = GetPtrTgtType(e_wsfeKey, type_error);
    ProcSym e_wsfesym = (fmtio)? GetProcedure(e_wsfeKey, NoProcSym):
        GetProcedure(e_wsleKey, NoProcSym);

    operand iostatDatum = operand(iostatAddr);

    Call call_e_wsfe = NEW(
        in_cal(
            e_wsfertntype,
            operand(),
            ConstVal(e_wsfeptrtype, e_wsfesym),
            0));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_e_wsfe)):
        Store(f2c_int, 
            iostatDatum.clone(dst_scope), operand(call_e_wsfe)));

    if (endLab != NoLabelSym)
        Jump_end(codechain, dst_scope, iostatDatum.clone(dst_scope), endLab);

    if (errLab != NoLabelSym)
        Jump_err(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_do_fio
(TreeNodeList codechain, ProcSymtab dst_scope, 
  Instruction iostatAddr, operand addrDatum, operand sizeDatum,
  LabelSym errLab, LabelSym endLab, DefTableKey liokind)
#else
AppCall_do_fio(codechain, dst_scope, iostatAddr, addrDatum, sizeDatum,
  errLab, endLab, liokind)
TreeNodeList codechain; ProcSymtab dst_scope;
Instruction iostatAddr; operand addrDatum; operand sizeDatum;
LabelSym errLab; LabelSym endLab; DefTableKey liokind
#endif
{
    static TypeNode do_fiortntype = GetTgtType(do_fioKey, type_error);
    static TypeNode do_fioptrtype = GetPtrTgtType(do_fioKey, type_error);
    ProcSym do_fiosym = (liokind == NoKey) ?
        GetProcedure(do_fioKey, NoProcSym): GetProcedure(do_lioKey, NoProcSym);
    static TypeNode intptrtype = NewType(ptr_type(type_signed));
    static TypeNode const1ptrtype = GetPtrTgtType(Const1Key, type_error);
    static VarSym const1varsym = GetVariable(Const1Key, NoVarSym);
    static TypeNode charptrtype = NewType(ptr_type(type_char));
    VarSym lioconstsym = GetVariable(liokind, NoVarSym);
    int argnum = (liokind == NoKey)? 3:4;
    int i;

    operand iostatDatum = operand(iostatAddr);

    Call call_do_fio = NEW(
        in_cal(
            do_fiortntype,
            operand(),
            ConstVal(do_fioptrtype, do_fiosym),
            argnum));

    i = 0;

    if(liokind != NoKey) {
        MEMBER(call_do_fio,
          set_argument(i++, ConstVal(const1ptrtype, sym_addr(lioconstsym,0))));
    }
    MEMBER(call_do_fio, 
        set_argument(i++, ConstVal(const1ptrtype, sym_addr(const1varsym, 0))));
    MEMBER(call_do_fio,
        set_argument(i++, Monadic(io_cvt, charptrtype, addrDatum)));
    MEMBER(call_do_fio,
        set_argument(i++, sizeDatum));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_do_fio)):
        Store(f2c_int, 
            iostatDatum.clone(dst_scope), operand(call_do_fio)));

    if (endLab != NoLabelSym)
        Jump_end(codechain, dst_scope, iostatDatum.clone(dst_scope), endLab);

    if (errLab != NoLabelSym)
        Jump_err(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_open(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab)
#else
AppCall_f_open(codechain, dst_scope,
  iostatAddr, i77listVar, errLab)
TreeNodeList codechain; BlockSymtab dst_scope;
Instruction iostatAddr; VarSym i77listVar; LabelSym errLab; 
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    TypeNode f_openrtntype = GetTgtType(f_openKey, type_error);
    TypeNode f_openptrtype = GetPtrTgtType(f_openKey, type_error);
    ProcSym f_opensym = GetProcedure(f_openKey, NoProcSym);
    TypeNode olistptrtype = GetPtrTgtType(olistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_f_open = NEW(
        in_cal(
        f_openrtntype,
            operand(),
            ConstVal(f_openptrtype, f_opensym),
            1));

    MEMBER(call_f_open, set_argument(0, ConstVal(olistptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, ( iostatAddr == NoInstruction)?
        NEW(tree_instr(call_f_open)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_f_open)));

    if (errLab != NoLabelSym)
       Jump_err2(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;

}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_clos(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab)
#else
AppCall_f_clos(codechain, dst_scope, iostatAddr, i77listVar, errLab)
TreeNodeList codechain; BlockSymtab dst_scope;
Instruction iostatAddr; VarSym i77listVar; LabelSym errLab;
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    TypeNode f_closrtntype = GetTgtType(f_closKey, type_error);
    TypeNode f_closptrtype = GetPtrTgtType(f_closKey, type_error);
    ProcSym f_clossym = GetProcedure(f_closKey, NoProcSym);
    TypeNode cllistptrtype = GetPtrTgtType(cllistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_f_clos = NEW(
        in_cal(
            f_closrtntype,
            operand(),
            ConstVal(f_closptrtype, f_clossym),
            1));

    MEMBER(call_f_clos, set_argument(0, ConstVal(cllistptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_f_clos)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_f_clos)));

    if (errLab != NoLabelSym)
       Jump_err2(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;

}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_rew(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab)
#else
AppCall_f_rew(codechain, dst_scope, iostatAddr, i77listVar, errLab)
TreeNodeList codechain; BlockSymtab dst_scope;
Instruction iostatAddr; VarSym i77listVar; LabelSym errLab;
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    TypeNode i77rtntype = GetTgtType(f_rewKey, type_error);
    TypeNode i77ptrtype = GetPtrTgtType(f_rewKey, type_error);
    ProcSym i77sym = GetProcedure(f_rewKey, NoProcSym);
    TypeNode i77listptrtype = GetPtrTgtType(alistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_i77 = NEW(
        in_cal(
            i77rtntype,
            operand(),
            ConstVal(i77ptrtype, i77sym),
            1));

    MEMBER(call_i77, set_argument(0, ConstVal(i77listptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_i77)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_i77)));

    if (errLab != NoLabelSym)
       Jump_err2(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_back(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab)
#else
AppCall_f_back(codechain, dst_scope, iostatAddr, i77listVar, errLab)
TreeNodeList codechain; BlockSymtab dst_scope;
Instruction iostatAddr; VarSym i77listVar; LabelSym errLab;
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    TypeNode i77rtntype = GetTgtType(f_backKey, type_error);
    TypeNode i77ptrtype = GetPtrTgtType(f_backKey, type_error);
    ProcSym i77sym = GetProcedure(f_backKey, NoProcSym);
    TypeNode i77listptrtype = GetPtrTgtType(alistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_i77 = NEW(
        in_cal(
            i77rtntype,
            operand(),
            ConstVal(i77ptrtype, i77sym),
            1));

    MEMBER(call_i77, set_argument(0, ConstVal(i77listptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_i77)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_i77)));

    if (errLab != NoLabelSym)
       Jump_err2(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_end(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab)
#else
AppCall_f_end(codechain, dst_scope, iostatAddr, i77listVar, errLab)
TreeNodeList codechain; BlockSymtab dst_scope;
Instruction iostatAddr; VarSym i77listVar; LabelSym errLab;
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    TypeNode i77rtntype = GetTgtType(f_endKey, type_error);
    TypeNode i77ptrtype = GetPtrTgtType(f_endKey, type_error);
    ProcSym i77sym = GetProcedure(f_endKey, NoProcSym);
    TypeNode i77listptrtype = GetPtrTgtType(alistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_i77 = NEW(
        in_cal(
            i77rtntype,
            operand(),
            ConstVal(i77ptrtype, i77sym),
            1));

    MEMBER(call_i77, set_argument(0, ConstVal(i77listptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_i77)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_i77)));

    if (errLab != NoLabelSym)
       Jump_err2(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

TreeNodeList
#if defined(__cplusplus) || defined(__STDC__)
AppCall_f_inqu(TreeNodeList codechain, BlockSymtab dst_scope,
    Instruction iostatAddr, VarSym i77listVar,
    LabelSym errLab)
#else
AppCall_f_inqu(codechain, dst_scope, iostatAddr, i77listVar, errLab)
TreeNodeList codechain; BlockSymtab dst_scope;
Instruction iostatAddr; VarSym i77listVar; LabelSym errLab;
#endif
{
    if(i77listVar == NoVarSym)
        return codechain;

    TypeNode i77rtntype = GetTgtType(f_inquKey, type_error);
    TypeNode i77ptrtype = GetPtrTgtType(f_inquKey, type_error);
    ProcSym i77sym = GetProcedure(f_inquKey, NoProcSym);
    TypeNode i77listptrtype = GetPtrTgtType(inlistKey, type_error);

    operand iostatDatum = operand(iostatAddr);

    Call call_i77 = NEW(
        in_cal(
            i77rtntype,
            operand(),
            ConstVal(i77ptrtype, i77sym),
            1));

    MEMBER(call_i77, set_argument(0, ConstVal(i77listptrtype, i77listVar)));

    codechain = AppendTreeNode(codechain, (iostatAddr == NoInstruction)?
        NEW(tree_instr(call_i77)):
        Store(
            f2c_int, iostatDatum.clone(dst_scope), operand(call_i77)));

    if (errLab != NoLabelSym)
       Jump_err2(codechain, dst_scope, iostatDatum.clone(dst_scope), errLab);

    return codechain;
}

@}

@A@<Format Specification@>

The FORMAT statement is considered as a character constant expression
of a special form. The Eli specification of this character constant
evaluation is in the @/FORTRAN 77 Expression Specification@/. The rule
attribute @{Fmt@} holds this character string with null ending. A 
variable of SUIF character array will be created to hold this value
and will be initialized via SUIF @{k_multi_init@} annotation.
Propery @{FmtVar@} holds this SUIF variable symbol and is accessed
via definition table key of a FORTRAN label. 
Attribute @{GotAllFmtVar@} asserts that all @{FmtVar@} have been properly
set. 

@$@<Properties accessed via definition table key of a f77 label@>+=@{
FmtVar: VarSym;
@}

@$@<Format Specification@>+=@{
ATTR Gotfmtvar: VOID;

SYMBOL xFmtSpec COMPUTE
    INH.Gotfmtvar= 1;
END;

ATTR GotAllFmtVar: VOID;

SYMBOL xProgramUnit COMPUTE
    SYNT.GotAllFmtVar = CONSTITUENTS xFmtSpec.Gotfmtvar;
END;


RULE: xStmt ::=  xLblDef 'format' '(' xFmtSpec ')' xEOS
COMPUTE
    .Ctype = NewType(array_type(
        FtnCharEle,
        array_bound(0),
        array_bound(strlen(.Fmt))));

    .temporary = MEMBER(INCLUDING xProgramUnit.suifscope,
        new_unique_var(.Ctype, "fmt__"));

    .CVDef = MEMBER(INCLUDING xProgramUnit.suifscope,
        define_var(.temporary,MEMBER(FtnCharEle,size())));

    .ImList = NEW(immed_list(immed(MEMBER(FtnCharEle,size()))));

    ORDER(
        AppImmLst0(.ImList, .Fmt),
        MEMBER(.CVDef, append_annote(k_multi_init, .ImList)));

    xFmtSpec.Gotfmtvar = ResetFmtVar(xLblDef.UnitKey, .temporary);
END;
@}

@A

A FORTRAN main program is represented in SUIF as a procedure named
@{MAIN__@}, with no arguments and no result.
The source language is, of course, FORTRAN.

@$@<Main Program@>==@{
RULE: xProgramUnit ::= xMainRange
COMPUTE
  xProgramUnit.suifproc=
    MEMBER(
      GlobalScope,
      new_proc(
        CASTP(func_type,NewType(func_type(type_void))),
        src_fortran,
        "MAIN__"));
END;

RULE: xProgramUnit ::= xProgramStmt xMainRange
COMPUTE
  xProgramUnit.suifproc=
    MEMBER(
      GlobalScope,
      new_proc(
        CASTP(func_type,NewType(func_type(type_void))),
        src_fortran,
        "MAIN__"));
END;
@}

@A

@$@<Functions and Subroutines@>==@{
SYMBOL xProgramUnit:
  suifproc:  ProcSym;

SYMBOL xProgramUnit COMPUTE
  SYNT.suifproc=NoProcSym;
END;

ATTR partialtype, suiftype: FuncType;

@<Referencing a Function@>
@<Statement Function@>
@<External Functions@>
@<Subroutines@>
@<Entry Statement@>
@<RETURN Statement@>
@<Dummy Arguments@>
@}

@B

Some of the intrinsic functions are implemented directly by the specification
while the rest are assumed to have an implementation defined in a library
that is linked with the final code.  The property @{CompilerImpl@} is used
to distinguish those that are implemented by the specification from the others.

@$@<Compiler Implementation Property@>==@{
CompilerImpl: int;

#define Implemented(f)	f -> CompilerImpl = {1}

Implemented(INTKey);
Implemented(IFIXKey);
Implemented(IDINTKey);
Implemented(REALKey);
Implemented(FLOATKey);
Implemented(SNGLKey);
Implemented(DBLEKey);
Implemented(CMPLXKey);
Implemented(ICHARKey);
Implemented(CHARKey);
Implemented(MAXKey);
Implemented(MAX0Key);
Implemented(AMAX1Key);
Implemented(DMAX1Key);
Implemented(AMAX0Key);
Implemented(MAX1Key);
Implemented(MINKey);
Implemented(MIN0Key);
Implemented(AMIN1Key);
Implemented(DMIN1Key);
Implemented(AMIN0Key);
Implemented(MIN1Key);
Implemented(LGEKey);
Implemented(LGTKey);
Implemented(LLEKey);
Implemented(LLTKey);

#undef Implemented
@}

@$@<Instantiate library modules@>+=@{
$/Adt/List.gnrc +instance=operand +referto=suif :inst
@}

@$@<Referencing a Function@>+=@{
ATTR CallInstruction: Call;
ATTR ProcedureRef: Instruction;
ATTR OperandList: operandList;

RULE: xComplexDataRef ::=  xName '(' xSectionSubscriptList ')'
COMPUTE
  .CallInstruction=
    CloneCallInstr(xName.ObjectKey,INCLUDING xProgramUnit.suifscope,NoCall)
    <- xName.havedef;
  .newargcount=
    IF(NE(.CallInstruction,NoCall),
      MEMBER(
        .CallInstruction,
        set_num_args(xSectionSubscriptList.SeqCount)));
  xSectionSubscriptList.CallInstruction=
    .CallInstruction <- .newargcount;
  xComplexDataRef.ProcedureRef=
    IF(GetCompilerImpl(xName.ObjectKey, 0),
      TranslateIntrinsic(
        xName.ObjectKey,
        xSectionSubscriptList.OperandList,
        COORDREF),
      xSectionSubscriptList.CallInstruction)
    <- xSectionSubscriptList.indexdone;
END;

RULE: xExpr ::=  xName '(' ')'
COMPUTE
  xExpr.Datum=
    operand(GetCallInstr(xName.ObjectKey,NoCall))
    <- xName.havedef;
END;

RULE: xComplexDataRef ::=  xComplexDataRef '(' xSectionSubscriptList ')'
COMPUTE
  xComplexDataRef[1].ProcedureRef=NoCall;
END;

SYMBOL xSectionSubscriptList COMPUTE
  INH.CallInstruction=NoCall;
  SYNT.ProcedureRef=NoCall;
END;
@}

@$@<Translation function interfaces@>+=@{
#include "operandList.h"
#include "err.h"

extern Instruction TranslateIntrinsic
  ELI_ARG((DefTableKey key, operandList arglist, POSITION *pos));
@}

@$@<Translation functions@>+=@{
#include "operandList.h"

static Instruction
#ifdef PROTO_OK
MinMaxImpl (if_ops op, TypeNode restype, operandList arglist, POSITION *pos)
#else
MinMaxImpl (op, restype, arglist, pos)
if_ops op;
TypeNode restype;
operandList arglist;
POSITION *pos;
#endif
{
  Instruction result;

  if (LengthoperandList(arglist) < 2) {
    message(FATAL, "Not enough arguments to intrinsic function", 0, pos);
    return NoInstruction;
  }

  result=
    new in_rrr(op, restype, operand(),
               HeadoperandList(arglist),
               HeadoperandList(TailoperandList(arglist)));

  arglist = TailoperandList(TailoperandList(arglist));

  while (arglist != NULLoperandList) {
    result=
      new in_rrr(op, restype, operand(), operand(result),
                 HeadoperandList(arglist));
    arglist = TailoperandList(arglist);
  }

  return result;
}

Instruction
#ifdef PROTO_OK
TranslateIntrinsic (DefTableKey key, operandList arglist, POSITION *pos)
#else
TranslateIntrinsic (key, arglist, pos)
DefTableKey key;
operandList arglist;
POSITION *pos;
#endif
{
  Instruction result;
  Instruction arg1, arg2;

  if (key == INTKey || key == IFIXKey || key == IDINTKey || key == ICHARKey)
    return
      new in_rrr(io_cvt, f2c_int, operand(),
                 HeadoperandList(arglist), operand());

  if (key == REALKey || key == FLOATKey || key == SNGLKey)
    return
      new in_rrr(io_cvt, type_float, operand(),
                 HeadoperandList(arglist), operand());

  if (key == DBLEKey)
    return
      new in_rrr(io_cvt, type_double, operand(),
                 HeadoperandList(arglist), operand());

  if (key == CMPLXKey) {
    message(FATAL, "CMPLX intrinsic not supported", 0, pos);
    return NoInstruction;
  }

  if (key == CHARKey)
    return
      new in_rrr(io_cvt, type_char, operand(),
                 HeadoperandList(arglist), operand());

  if (key == MAXKey)
    return MinMaxImpl(io_max, HeadoperandList(arglist).type(), arglist, pos);

  if (key == MAX0Key)
    return MinMaxImpl(io_max, f2c_int, arglist, pos);

  if (key == AMAX1Key)
    return MinMaxImpl(io_max, type_float, arglist, pos);

  if (key == DMAX1Key)
    return MinMaxImpl(io_max, type_double, arglist, pos);

  if (key == AMAX0Key) {
    result = MinMaxImpl(io_max, f2c_int, arglist, pos);
    return
      new in_rrr(io_cvt, type_float, operand(), operand(result), operand());
  }

  if (key == MAX1Key) {
    result = MinMaxImpl(io_max, type_float, arglist, pos);
    return
      new in_rrr(io_cvt, f2c_int, operand(), operand(result), operand());
  }

  if (key == MINKey)
    return MinMaxImpl(io_min, HeadoperandList(arglist).type(), arglist, pos);

  if (key == MIN0Key)
    return MinMaxImpl(io_min, f2c_int, arglist, pos);

  if (key == AMIN1Key)
    return MinMaxImpl(io_min, type_float, arglist, pos);

  if (key == DMIN1Key)
    return MinMaxImpl(io_min, type_double, arglist, pos);

  if (key == AMIN0Key) {
    result = MinMaxImpl(io_min, f2c_int, arglist, pos);
    return
      new in_rrr(io_cvt, type_float, operand(), operand(result), operand());
  }

  if (key == MIN1Key) {
    result = MinMaxImpl(io_min, type_float, arglist, pos);
    return
      new in_rrr(io_cvt, f2c_int, operand(), operand(result), operand());
  }

  if (key == LGEKey || key == LGTKey || key == LLEKey || key == LLTKey) {
    operand opnd1, opnd2;
    Instruction arg1, arg2;

    if (LengthoperandList(arglist) != 2) {
      message(FATAL,
        "Not enough arguments to intrinsic function",
        0, pos);
      return NoInstruction;
    }

    opnd1 = HeadoperandList(arglist);
    opnd2 = HeadoperandList(TailoperandList(arglist));

    if (opnd1.type() != type_char || opnd2.type() != type_char) {
      message(FATAL,
        "Operands to intrinsic function must be character types",
        0, pos);
      return NoInstruction;
    }

    arg1 = new in_rrr(io_cvt, type_signed, operand(), opnd1, operand());
    arg2 = new in_rrr(io_cvt, type_signed, operand(), opnd2, operand());

    if (key == LGEKey)
      return new in_rrr(io_sle, type_signed, operand(), arg2, arg1);

    if (key == LGTKey)
      return new in_rrr(io_sl, type_signed, operand(), arg2, arg1);

    if (key == LLEKey)
      return new in_rrr(io_sle, type_signed, operand(), arg1, arg2);

    if (key == LLTKey)
      return new in_rrr(io_sl, type_signed, operand(), arg1, arg2);
  }

  /* This shouldn't happen */
  message(FATAL,
    "Internal error: intrinsic function implementation not defined",
    0, pos);
  return NoInstruction;
}
@}

@$@<Referencing a Function@>+=@{
ATTR temp: VarSym;

RULE: xSectionSubscriptList ::=  xSectionSubscript
COMPUTE
  @<Store argument value@>@(xSectionSubscript@,@,0@)
  xSectionSubscriptList.OperandList=
    ConsoperandList(xSectionSubscript.Datum, NULLoperandList);
END;

RULE: xSectionSubscriptList ::=  xSectionSubscriptList ',' xSectionSubscript
COMPUTE
  @<Store argument value@>@(xSectionSubscript@,[1]@,xSectionSubscriptList[2].SeqCount@)
  xSectionSubscriptList[2].CallInstruction=
    xSectionSubscriptList[1].CallInstruction;
  xSectionSubscriptList[1].OperandList=
    AppEloperandList(
      xSectionSubscriptList[2].OperandList,
      xSectionSubscript.Datum);
END;
@}

@$@<Store argument value@>@(@3@)@M@{
  .temp=
    IF(AND(@1List@2.CallInstruction,NOT(@1.Address)),
      MEMBER(
        INCLUDING xProgramUnit.suifscope,
        new_unique_var(@1.Dtype,"T")),
      NoVarSym);
  .setarg=
    IF(@1List@2.CallInstruction,
      MEMBER(
        @1List@2.CallInstruction,
        set_argument(@3,IF(@1.Address,@1.Address,ConstInstr(@1.Dtype,.temp)))));
  @1List@2.ProcedureRef=@1List@2.CallInstruction <- .setarg;
  @1List@2.codechain=
    IF(AND(@1List@2.CallInstruction,NOT(@1.Address)),
      AppendTreeNode(@1.codechain,Store(@1.Dtype,operand(.temp),@1.Datum)),
      @1.codechain);
@}

@B

@$@<Statement Function@>==@{
@}

@B

@$@<External Functions@>+=@{
CHAIN RoutineType: FuncType;
SYMBOL xSubprogramRange:
  FuncName: DefTableKey,
  Sym: int,
  resulttype: TypeNode;

SYMBOL xSubprogramRange COMPUTE
  INH.FuncName=NoKey;
  INH.Sym=0;
  INH.resulttype=type_void;
END;

RULE: xProgramUnit ::= xLblDef xFunctionPrefix xFunctionName xSubprogramRange
COMPUTE
  xProgramUnit.suifproc=
    CreateSUIFProc(
      StringTable(xFunctionName.Sym),
      xSubprogramRange.RoutineType);
  xFunctionName.upperdef=
    ResetDefined(xFunctionName.ObjectKey,1)
    <- xProgramUnit.suifproc;
  CHAINSTART xSubprogramRange.RoutineType=
    NEW(func_type(xSubprogramRange.resulttype,xSubprogramRange.ArgCount));
  xSubprogramRange.FuncName=xFunctionName.ObjectKey;
  xSubprogramRange.Sym=xFunctionName.Sym;
  xSubprogramRange.resulttype=
    GetTgtType(GetType(xFunctionName.UnitKey,NoKey),type_error);
END;
@}

@$@<Make function result variable@>@(@1@)@M@{
xSubprogramRange.GotVariable=
  IF(xSubprogramRange.FuncName,
    ResetVariable(
      xSubprogramRange.FuncName,
      MEMBER(
        INCLUDING xProgramUnit.suifscope,
        new_var(
          xSubprogramRange.resulttype,
          StringTable(xSubprogramRange.Sym)))))
  <- xFormalParameterList.codechain;
@1.codechain=
  xFormalParameterList.codechain <- xSubprogramRange.GotVariable;
@}

@$@<External Functions@>+=@{
RULE: xSubprogramRange ::=  xFormalParameterList xEOS xBody xEndFunctionStmt
COMPUTE
  @<Make function result variable@>@(xBody@)
END;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xEndFunctionStmt
COMPUTE
  @<Make function result variable@>@(xEndFunctionStmt@)
END;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xBody xEndSubroutineStmt
COMPUTE
  @<Make function result variable@>@(xBody@)
END;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xEndSubroutineStmt
COMPUTE
  @<Make function result variable@>@(xEndSubroutineStmt@)
END;
@}

@B

@$@<Subroutines@>==@{
RULE: xProgramUnit ::= xLblDef 'subroutine' xSubroutineName xSubprogramRange
COMPUTE
  xProgramUnit.suifproc=
    CreateSUIFProc(
      StringTable(xSubroutineName.Sym),
      xSubprogramRange.RoutineType);
  xSubroutineName.upperdef=
    ResetDefined(xSubroutineName.ObjectKey,1) <- xProgramUnit.suifproc;
  CHAINSTART xSubprogramRange.RoutineType=
    NEW(func_type(type_void,xSubprogramRange.ArgCount));
END;

RULE: xStmt ::=  xLblDef 'call' xSubroutineNameUse '(' xArgList ')' xEOS
COMPUTE
  .CallInstruction=
    CloneCallInstr(
      xSubroutineNameUse.ObjectKey,
      INCLUDING xProgramUnit.suifscope,
      NoCall)
    <- xSubroutineNameUse.havedef;
  .newargcount=
    MEMBER(.CallInstruction,set_num_args(xArgList.SeqCount));
  xArgList.CallInstruction=
    .CallInstruction <- .newargcount;
  xStmt.codechain=
    AppendTreeNode(
      xArgList.codechain,
      NEW(tree_instr(xArgList.ProcedureRef)));
END;

RULE: xStmt ::=  xLblDef 'call' xSubroutineNameUse xEOS
COMPUTE
  xStmt.codechain=
    AppendTreeNode(
      xSubroutineNameUse.codechain,
      NEW(tree_instr(
        CloneCallInstr(
          xSubroutineNameUse.ObjectKey,
          INCLUDING xProgramUnit.suifscope,
          NoCall))))
    <- xSubroutineNameUse.havedef;
END;

RULE: xArgList ::=  xArg
COMPUTE
  @<Store argument value@>@(xArg@,@,0@)
END;

RULE: xArgList ::=  xArgList ',' xArg
COMPUTE
  @<Store argument value@>@(xArg@,[1]@,xArgList[2].SeqCount@)
  xArgList[2].CallInstruction=xArgList[1].CallInstruction;
END;

SYMBOL xArg COMPUTE
  SYNT.Value=0;
END;

SYMBOL xArgList COMPUTE
  SYNT.ProcedureRef=THIS.CallInstruction;
END;
@}

@B

@$@<Entry Statement@>==@{
RULE: xStmt ::=  xLblDef 'entry' xEntryName xFormalParameterList xEOS
COMPUTE
  .suifproc=
    CreateSUIFProc(
      StringTable(xEntryName.Sym),
      xFormalParameterList.RoutineType);
  xEntryName.upperdef=
    ResetDefined(xEntryName.ObjectKey,1) <- .suifproc;
  CHAINSTART xFormalParameterList.RoutineType=
    NEW(func_type(
      GetTgtType(GetType(xEntryName.UnitKey,NoKey),type_error),
      xFormalParameterList.SeqCount));
END;
@}

@$@<Translation functions@>+=@{
ProcSym
#ifdef PROTO_OK
CreateSUIFProc (char *name, FuncType typ)
#else
CreateSUIFProc (name, typ)
char *name;
FuncType typ;
#endif
{
  ProcSym proc;

  GlobalScope->install_type(typ);
  proc = GlobalScope->lookup_proc(name);
  if (proc)
    proc->set_type(typ);
  else
    proc = GlobalScope->new_proc(typ, src_fortran, name);

  return proc;
}
@}

@$@<Translation function interfaces@>+=@{
ProcSym CreateSUIFProc ELI_ARG((char *, FuncType));
@}

@B

@$@<RETURN Statement@>+=@{
RULE: xStmt ::=  xLblDef 'return' xEOS
COMPUTE
  xStmt.codechain=@<Simple return operation@>;
END;

RULE: xEndFunctionStmt ::=  xLblDef 'end' xEOS
COMPUTE
  xEndFunctionStmt.codechain=@<Simple return operation@>;
END;

RULE: xEndSubroutineStmt ::=  xLblDef 'end' xEOS
COMPUTE
  xEndSubroutineStmt.codechain=@<Simple return operation@>;
END;
@}

@$@<Simple return operation@>@M@{
AppendTreeNode(
  xLblDef.codechain,
  MEMBER(
    INCLUDING xProgramUnit.RetInstr,
    clone(INCLUDING xProgramUnit.suifscope)))
@}

@$@<RETURN Statement@>+=@{
SYMBOL xProgramUnit: RetInstr: TreeInstr;

RULE: xProgramUnit ::=  xLblDef xFunctionPrefix xFunctionName xSubprogramRange
COMPUTE
  xProgramUnit.RetInstr=
    NEW(tree_instr(
      NEW(in_rrr(
        io_ret,
        xSubprogramRange.resulttype,
        operand(),
        operand(GetVariable(xFunctionName.ObjectKey,NoVarSym))))))
    <- xSubprogramRange.GotVariable;
END;

RULE: xProgramUnit ::=  xLblDef 'subroutine' xSubroutineName xSubprogramRange
COMPUTE
  xProgramUnit.RetInstr=NEW(tree_instr(NEW(in_rrr(io_ret))));
END;

SYMBOL xProgramUnit COMPUTE
  SYNT.RetInstr=NoTreeInstr;
END;
@}

@B

@$@<Dummy Arguments@>==@{
SYMBOL xSubprogramRange: ArgCount: int;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xBody xEndFunctionStmt
COMPUTE
  xSubprogramRange.ArgCount=xFormalParameterList.SeqCount;
END;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xEndFunctionStmt
COMPUTE
  xSubprogramRange.ArgCount=xFormalParameterList.SeqCount;
END;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xBody xEndSubroutineStmt
COMPUTE
  xSubprogramRange.ArgCount=xFormalParameterList.SeqCount;
END;

RULE: xSubprogramRange ::=  xFormalParameterList xEOS xEndSubroutineStmt
COMPUTE
  xSubprogramRange.ArgCount=xFormalParameterList.SeqCount;
END;

ATTR typekey: DefTableKey;

RULE: xFormalParameter ::=  xDummyArgName
COMPUTE
  .typekey=
    GetType(xDummyArgName.UnitKey,NoKey)
    <- INCLUDING xProgramUnit.GotAllTypes;
  .GotArg=
    MEMBER(
      xFormalParameter.RoutineType,
      set_arg_type(
        SUB(xFormalParameter.SeqIndex,1),
        GetTgtType(xDummyArgName.ObjectKey,type_error)
          <- INCLUDING xProgramUnit.GotAllTgtTypes));
  xFormalParameter.RoutineType=xFormalParameter.RoutineType <- .GotArg;
END;

RULE: xFormalParameter ::=  '*'
COMPUTE
  .GotArg=
    MEMBER(
      xFormalParameter.RoutineType,
      set_arg_type(SUB(xFormalParameter.SeqIndex,1),type_void));
  xFormalParameter.RoutineType=xFormalParameter.RoutineType <- .GotArg;
END;
@}

@A@<Scope and Classes of Symbolic Names@>

@B

An executable program as a scope for symbolic names is embodied in a
@{FileSetEntrySet@} object,
while both program units and statement functions are embodied in
@{SuifProcedure@}s.
The implied-DO in a DATA statement is executed by the translator and thus
does not appear in the SUIF program.

Each program unit is a procedure that defines a scope.
The names and types of the procedures must be derived from context:

@$@<Scope of Symbolic Names@>+=@{
SYMBOL xProgramUnit:
  suifscope: ProcSymtab;

SYMBOL xProgramUnit COMPUTE
  SYNT.suifscope=NoProcSymtab;
END;

RULE: xProgramUnit ::= xLblDef 'subroutine' xSubroutineName xSubprogramRange
COMPUTE
  xProgramUnit.suifscope=
    NewProcSymtab(MEMBER(INCLUDING xSourceFile.file,symtab()),
      StringTable(xSubroutineName.Sym));
END;

RULE: xProgramUnit ::= xLblDef xFunctionPrefix xFunctionName xSubprogramRange
COMPUTE
  xProgramUnit.suifscope=
    NewProcSymtab(MEMBER(INCLUDING xSourceFile.file,symtab()),
      StringTable(xFunctionName.Sym));
END;

RULE: xProgramUnit ::= xMainRange
COMPUTE
  xProgramUnit.suifscope=
    NewProcSymtab(MEMBER(INCLUDING xSourceFile.file,symtab()), "MAIN__");
END;

RULE: xProgramUnit ::= xProgramStmt xMainRange
COMPUTE
  xProgramUnit.suifscope=
    NewProcSymtab(MEMBER(INCLUDING xSourceFile.file,symtab()),"MAIN__");
END;
@}

This creates a SUIF file object.  The file symbol table should contain the
variable definitions for common blocks.

@$@<Scope of Symbolic Names@>+=@{
SYMBOL xSourceFile: file: FileSetEntry, filename: int, suifscope: FileSymtab;

SYMBOL xSourceFile COMPUTE
  SYNT.filename=GetClpValue(InputFile, 0);
  SYNT.file=NewFile(
              IF(EQ(THIS.filename, 0),
                "suifout",
                GenOutputName(THIS.filename, ".eli")));
  SYNT.suifscope=MEMBER(THIS.file, symtab());
END;
@}

@$@<Translation function interfaces@>+=@{
char *GenOutputName ELI_ARG((int i, char *suffix));
@}

@$@<Translation functions@>+=@{
char *
#ifdef PROTO_OK
GenOutputName (int i, char *suffix)
#else
GenOutputName (i, suffix)
int i;
char *suffix;
#endif
{
  char *str;
  char *p;

  str = StringTable(i);
  p = strrchr(str, '/');
  if (p)
    str = p + 1;
  p = strrchr(str, '.');
  if (!p || strcmp(p, ".f"))
    obstack_strgrow(Csm_obstk, str);
  else
    for (; str < p; ++str)
      obstack_1grow(Csm_obstk, str[0]);
  return obstack_strcpy(Csm_obstk, suffix);
}
@}

Some variables are created to hold some constant values for system use, i.g.
some are passed as parameters to input/output library functions. These
constants are set to be in the file symbol table. So they are created after
the file symbol table is created.
Attribute @{GotAllConst@} asserts that all these variables have been created
and properly initialized.

@$@<Scope of Symbolic Names@>+=@{
SYMBOL xSourceFile: GotAllConst: VOID;

SYMBOL xSourceFile COMPUTE
    SYNT.GotAllConst = PredefConst(THIS.file);
END;
@}

@B

External functions, subroutines and variables are the only symbolic names
that can be used without a specific, preceding definition in FORTRAN.
Thus the essential properties of these objects may need to be set on the fly.
If a variable is in a common block, this variable should be declared to
be in the global symbol table.

@$@<Classes of Symbolic Names@>==@{
DefineSym(THIS.Sym,
    THIS.ObjectKey,
    THIS.UnitKey,
    INCLUDING xProgramUnit.suifscope,
    OR(NE(GetComBlock(THIS.UnitKey, NoKey), NoKey),
       NE(GetComBlock(EquSetGetLeader(THIS.UnitKey), NoKey), NoKey)))
@}

@$@<Translation functions@>+=@{
void
#ifdef PROTO_OK
DefineSym(
  int Sym,
  DefTableKey ObjectKey,
  DefTableKey UnitKey,
  ProcSymtab scope,
  int isInCom)
#else
DefineSym(Sym, ObjectKey, UnitKey, scope, isInCom)
int Sym; DefTableKey Key,UnitKey; ProcSymtab scope; int isInCom;
#endif
{ IntSet kinds;
  TypeNode symtype;

  if (GetDefined(ObjectKey,0)) return;

  ResetDefined(ObjectKey,1);
  kinds = GetKindSet(UnitKey,NullIS());
  symtype = GetTgtType(ObjectKey, type_error);

  if (InIS(ExternalFunction,kinds)) {
    proc_sym *rtn;

    rtn = GlobalScope->
            new_proc((func_type *)symtype, src_fortran, StringTable(Sym));
    ResetProcedure(ObjectKey, rtn);
    ResetCallInstr(
      ObjectKey,
      new in_cal(
        GetTgtType(GetType(UnitKey, NoKey), type_error),
        operand(),
        ConstVal(NewType(ptr_type(symtype)),rtn),
        0));
  } else if (InIS(Subroutine,kinds)) {
    proc_sym *rtn;

    rtn = GlobalScope->
            new_proc((func_type *)symtype, src_fortran, StringTable(Sym));
    ResetProcedure(ObjectKey, rtn);
    ResetCallInstr(
      ObjectKey,
      new in_cal(
        type_void,
        operand(),
        ConstVal(NewType(ptr_type(symtype)),rtn),
        0));
  } else if (InIS(DummyProcedure,kinds)) {
    var_sym *rtn;

    rtn = scope->new_var(symtype, StringTable(Sym));
    rtn->set_param();
    /* The dummy arguments are guaranteed to be processed in order */
    /* because of the codechain.  Therefore, we can simply append  */
    /* the dummy argument to the list of procedure arguments and   */
    /* know that the order will be retained.                       */
    scope->params()->append(rtn);
    ResetVariable(ObjectKey, rtn);
    ResetCallInstr(
      ObjectKey,
      new in_cal(
        GetTgtType(GetType(UnitKey, NoKey), type_error),
        operand(),
        Monadic(io_lod,symtype,rtn),
        0));
  } else if (InIS(IntrinsicFunction,kinds)) {
    if (!GetCompilerImpl(ObjectKey,0)) {
      proc_sym *rtn;

      rtn = GlobalScope->
              new_proc((func_type *)symtype, src_fortran, StringTable(Sym));
      ResetProcedure(ObjectKey, rtn);
      ResetCallInstr(
        ObjectKey,
        new in_cal(
          GetTgtType(GetType(UnitKey, NoKey), type_error),
          operand(),
          ConstVal(NewType(ptr_type(symtype)),rtn),
          0));
    }
  } else {
    var_sym *var;

    /* if it's in a common block, set it into global symbol table */
    var = (isInCom? GlobalScope:scope)->new_var(symtype, StringTable(Sym));
    ResetVariable(ObjectKey, var);
    if (InIS(DummyArgument,kinds)) {
      var->set_param();
      /* The dummy arguments are guaranteed to be processed in order */
      /* because of the codechain.  Therefore, we can simply append  */
      /* the dummy argument to the list of procedure arguments and   */
      /* know that the order will be retained.                       */
      scope->params()->append(var);
    }
  }
}
@}

@$@<Translation function interfaces@>+=@{
void DefineSym ELI_ARG((int,DefTableKey,DefTableKey,ProcSymtab,int));
@}



@A@<Specification Files for SUIF Translation@>

This section briefly describes the specification files that implement the
suif translation process.

@B

A type-@{specs@} file provides names of additional objects to be included
in the set of specifications.
Here the objects are the library instantiations needed to support the
translation process.

@O@<f77suif.specs@>==@{
@<Instantiate library modules@>
@}

@B

A type-@{pdl@} file describes the properties that must be available to
describe entities.

@O@<f77suif.pdl@>==@{
"f77suif.h"

@<Definition table keys for predefined extern functions@>
@<Definition table keys for predefined structure@>
@<Definition table key for constant of system use@>
@<lio Kind@>
@<Definition table key for double complex@>
@<Properties of a Symbolic Name@>
@<Properties of a Statement Label@>
@<Data types@>
@<Element type@>
@<Data Type of a Name@>
@<Property ObjectKey@>
@<Parent Variable@>
@<Translation function properties@>
@<Arithmetic Expressions@>
@<Relational Expressions@>
@<Logical Expressions@>
@<Termination label properties@>
@<Properties accessed via definition table key of a f77 label@>
@<Compiler Implementation Property@>
@}

@B

A type-@{lido@} file describes the relationships that must exist among
computations in the tree.

@O@<f77suif.lido@>==@{
@<FORTRAN Terms and Concepts@>
@<Normal execution sequence@>
@<Set the data type of a name@>
@<Constants@>
@<Arrays and Substrings@>
@<Expressions@>
@<Arithmetic primaries@>
@<Logical primaries@>
@<Constant Expressions@>
@<Assignment Statements@>
@<Control Statements@>
@<Main Program@>
@<Functions and Subroutines@>
@<Scope of Symbolic Names@>
@<COMMON and EQUIVALENCE@>
@<COMPLEX Arithmetic Expression@>
@<Format Specification@>
@<Input/Output Statements@>
@}

@B

A type-@{head@} file provides the interfaces for abstract data types used
in the tree computations.

@O@<f77suif.head@>==@{
#include <stdlib.h>
#include "f77suif.h"
@}

@B

A type-@{c@} file provides the implementation of the abstract data types
defined by this specification.

@O@<f77suif.c@>==@{
static char rcsid[] =
  "$Id: F77Suif.fw,v 1.22 1998/01/04 13:17:10 waite Exp $";
@<Identification of the creating tool@>

#include <string.h>
#include "f77suif.h"
#include "csm.h"
#include "IntSet.h"
#include "pdl_gen.h"

@<Translation functions@>
@<Predefined constant for system use@>
@<f2c type variable definitions@>
@<I77 function call@>
@<Append immed_list@>
@}

@B

A type-@{h@} file provides the interface for the abstract data types
defined by this specification.

@O@<f77suif.h@>==@{
#ifndef F77SUIF_H
#define F77SUIF_H

#include "deftbl.h"
#include "oiladt2.h"
#include "suif_fw.h"
#include "OuterCodeStack.h"
#include "eliproto.h"

@<Translation function interfaces@>
@<Predefined constant function interface@>
@<f2c type variable externs@>
@<Append immed_list interface@>
@<I77 function interface@>
#endif
@}


@B

A type-@{init@} file provides code to be executed before the processor
begins reading input text.

@O@<f77suif.init@>==@{
@<SUIF library initialization@>
#include "pdl_gen.h"
@<f2c type variable initialization@>
@<Primitive type property initialization@>
@<Extern functions@>
@<Predefined structure@>
@}

\end{document}
