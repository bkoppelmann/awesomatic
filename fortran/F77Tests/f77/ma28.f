      
      SUBROUTINE COPY(KNUM, A1, A2, ICN1, ICN2, IRN1, IRN2)
      DOUBLE PRECISION A1(KNUM), A2(KNUM)
      INTEGER ICN1(KNUM),ICN2(KNUM),IRN1(KNUM),IRN2(KNUM)
      DO 10 I=1,KNUM
        A2(I) = A1(I)
        ICN2(I) = ICN1(I)
        IRN2(I) = IRN1(I)
   10 CONTINUE
      RETURN
      END
      SUBROUTINE RANMAT(M, N, ICN, LICN, IPTR, NNNP1, KNUM, IW)
      INTEGER IPTR(NNNP1)
      INTEGER ICN(LICN),IW(N)
      LOGICAL SING
      COMMON /RANMA/ SING
      INUM = (KNUM/N)*2
      IF (INUM.GT.N-1) INUM = N - 1
      MATNUM = 1
      DO 10 I=1,N
        IW(I) = 0
   10 CONTINUE
      DO 50 J=1,M
        IPTR(J) = MATNUM
        IF (SING) GO TO 20
        IF (J.GT.N) GO TO 20
        ICN(MATNUM) = J
        IW(J) = J
        MATNUM = MATNUM + 1
   20   IF (N.EQ.1) GO TO 50
        CALL FA01BS(INUM, LROW)
        LROW = LROW - 1
        IF (LROW.EQ.0) GO TO 50
        DO 40 II=1,LROW
   30     CALL FA01BS(N, I)
          IF (IW(I).EQ.J) GO TO 30
          IW(I) = J
          ICN(MATNUM) = I
          MATNUM = MATNUM + 1
   40   CONTINUE
   50 CONTINUE
      MP1 = M + 1
      DO 60 I=MP1,NNNP1
        IPTR(I) = MATNUM
   60 CONTINUE
      KNUM = MATNUM - 1
      RETURN
      END
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MA28AD MA28BD MA28CD
C###### CALLS   MA30    MC20    MC22    MC23    MC24
      SUBROUTINE MA28AD(N, NZ, A, LICN, IRN, LIRN, ICN, U, IKEEP, IW, W,
     * IFLAG)
C THIS SUBROUTINE PERFORMS THE LU FACTORIZATION OF A.
C
C THE PARAMETERS ARE AS FOLLOWS.....
C N     ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C NZ    NUMBER OF NON-ZEROS IN INPUT MATRIX  NOT ALTERED BY SUBROUTINE.
C A IS A  REAL ARRAY  LENGTH LICN.  HOLDS NON-ZEROS OF MATRIX ON ENTRY
C     AND NON-ZEROS OF FACTORS ON EXIT.  REORDERED BY MC20A/AD AND
C     MC23A/AD AND ALTERED BY MA30A/AD.
C LICN  INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY SUBROUTINE.
C IRN   INTEGER ARRAY OF LENGTH LIRN.  HOLDS ROW INDICES ON INPUT.
C     USED AS WORKSPACE BY MA30A/AD TO HOLD COLUMN ORIENTATION OF
C     MATRIX.
C LIRN  INTEGER  LENGTH OF ARRAY IRN. NOT ALTERED BY THE SUBROUTINE.
C ICN   INTEGER ARRAY OF LENGTH LICN.  HOLDS COLUMN INDICES ON ENTRY
C     AND COLUMN INDICES OF DECOMPOSED MATRIX ON EXIT. REORDERED BY
C     MC20A/AD AND MC23A/AD AND ALTERED BY MA30A/AD.
C U     REAL VARIABLE  SET BY USER TO CONTROL BIAS TOWARDS NUMERIC OR
C     SPARSITY PIVOTING.  U=1.0 GIVES PARTIAL PIVOTING WHILE U=0. DOES
C     NOT CHECK MULTIPLIERS AT ALL.  VALUES OF U GREATER THAN ONE ARE
C     TREATED AS ONE WHILE NEGATIVE VALUES ARE TREATED AS ZERO.  NOT
C     ALTERED BY SUBROUTINE.
C IKEEP  INTEGER ARRAY OF LENGTH 5*N  USED AS WORKSPACE BY MA28A/AD
C     (SEE LATER COMMENTS).  IT IS NOT REQUIRED TO BE SET ON ENTRY
C     AND, ON EXIT, IT CONTAINS INFORMATION ABOUT THE DECOMPOSITION.
C     IT SHOULD BE PRESERVED BETWEEN THIS CALL AND SUBSEQUENT CALLS
C     TO MA28B/BD OR MA28C/CD.
C     IKEEP(I,1),I=1,N  HOLDS THE TOTAL LENGTH OF THE PART OF ROW I
C     IN THE DIAGONAL BLOCK.
C     ROW IKEEP(I,2),I=1,N  OF THE INPUT MATRIX IS THE ITH ROW IN
C     PIVOT ORDER.
C     COLUMN IKEEP(I,3),I=1,N  OF THE INPUT MATRIX IS THE ITH COLUMN
C     IN PIVOT ORDER.
C     IKEEP(I,4),I=1,N  HOLDS THE LENGTH OF THE PART OF ROW I IN
C     THE L PART OF THE L/U DECOMPOSITION.
C     IKEEP(I,5),I=1,N  HOLDS THE LENGTH OF THE PART OF ROW I IN THE
C     OFF-DIAGONAL BLOCKS.  IF THERE IS ONLY ONE DIAGONAL BLOCK,
C     IKEEP(1,5) WILL BE SET TO -1.
C IW    INTEGER ARRAY OF LENGTH 8*N.  IF THE OPTION NSRCH.LE.N IS
C     USED, THEN THE LENGTH OF ARRAY IW CAN BE REDUCED TO 7*N.
C W REAL ARRAY  LENGTH N.  USED BY MC24A/AD BOTH AS WORKSPACE AND TO
C     RETURN GROWTH ESTIMATE IN W(1).  THE USE OF THIS ARRAY BY MA28A/AD
C     IS THUS OPTIONAL DEPENDING ON COMMON BLOCK LOGICAL VARIABLE GROW.
C IFLAG  INTEGER VARIABLE  USED AS ERROR FLAG BY ROUTINE.  A POSITIVE
C     OR ZERO VALUE ON EXIT INDICATES SUCCESS.  POSSIBLE NEGATIVE
C     VALUES ARE -1 THROUGH -14.
C
      INTEGER N, NZ, LICN, LIRN, IFLAG
      INTEGER IRN(LIRN), ICN(LICN), IKEEP(N,5), IW(N,8)
      DOUBLE PRECISION A(LICN), U, W(N)
C
C COMMON AND PRIVATE VARIABLES.
C     COMMON BLOCK MA28F/FD IS USED MERELY
C     TO COMMUNICATE WITH COMMON BLOCK MA30F/FD  SO THAT THE USER
C     NEED NOT DECLARE THIS COMMON BLOCK IN HIS MAIN PROGRAM.
C THE COMMON BLOCK VARIABLES ARE AS FOLLOWS ...
C LP,MP  INTEGER  DEFAULT VALUE 6 (LINE PRINTER).  UNIT NUMBER
C     FOR ERROR MESSAGES AND DUPLICATE ELEMENT WARNING RESP.
C NLP,MLP  INTEGER  UNIT NUMBER FOR MESSAGES FROM MA30A/AD AND
C     MC23A/AD RESP.  SET BY MA28A/AD TO VALUE OF LP.
C LBLOCK  LOGICAL  DEFAULT VALUE TRUE.  IF TRUE MC23A/AD IS USED
C     TO FIRST PERMUTE THE MATRIX TO BLOCK LOWER TRIANGULAR FORM.
C GROW    LOGICAL  DEFAULT VALUE TRUE.  IF TRUE THEN AN ESTIMATE
C     OF THE INCREASE IN SIZE OF MATRIX ELEMENTS DURING L/U
C     DECOMPOSITION IS GIVEN BY MC24A/AD.
C EPS,RMIN,RESID  REAL/DOUBLE PRECISION VARIABLES NOT REFERENCED
C     BY MA28A/AD.
C IRNCP,ICNCP  INTEGER  SET TO NUMBER OF COMPRESSES ON ARRAYS IRN AND
C     ICN/A RESPECTIVELY.
C MINIRN,MINICN  INTEGER  MINIMUM LENGTH OF ARRAYS IRN AND ICN/A
C     RESPECTIVELY, FOR SUCCESS ON FUTURE RUNS.
C IRANK  INTEGER   ESTIMATED RANK OF MATRIX.
C MIRNCP,MICNCP,MIRANK,MIRN,MICN INTEGER VARIABLES.  USED TO
C     COMMUNICATE BETWEEN MA30F/FD AND MA28F/FD VALUES OF ABOVENAMED
C     VARIABLES WITH SOMEWHAT SIMILAR NAMES.
C ABORT1,ABORT2  LOGICAL VARIABLES WITH DEFAULT VALUE TRUE.  IF FALSE
C     THEN DECOMPOSITION WILL BE PERFORMED EVEN IF THE MATRIX IS
C     STRUCTURALLY OR NUMERICALLY SINGULAR RESPECTIVELY.
C ABORTA,ABORTB  LOGICAL VARIABLES USED TO COMMUNICATE VALUES OF
C     ABORT1 AND ABORT2 TO MA30A/AD.
C ABORT  LOGICAL  USED TO COMMUNICATE VALUE OF ABORT1 TO MC23A/AD.
C ABORT3  LOGICAL VARIABLE NOT REFERENCED BY MA28A/AD.
C IDISP   INTEGER ARRAY  LENGTH 2.  USED TO COMMUNICATE INFORMATION
C     ON DECOMPOSITION BETWEEN THIS CALL TO MA28A/AD AND SUBSEQUENT
C     CALLS TO MA28B/BD AND MA28C/CD.  ON EXIT, IDISP(1) AND
C     IDISP(2) INDICATE POSITION IN ARRAYS A AND ICN OF THE
C     FIRST AND LAST ELEMENTS IN THE L/U DECOMPOSITION OF THE
C     DIAGONAL BLOCKS, RESPECTIVELY.
C NUMNZ  INTEGER  STRUCTURAL RANK OF MATRIX.
C NUM    INTEGER  NUMBER OF DIAGONAL BLOCKS.
C LARGE  INTEGER  SIZE OF LARGEST DIAGONAL BLOCK.
C
C SEE BLOCK DATA FOR FURTHER COMMENTS ON COMMON BLOCK VARIABLES.
C SEE CODE FOR COMMENTS ON PRIVATE VARIABLES.
C
      DOUBLE PRECISION TOL, THEMAX, BIG, DXMAX, ERRMAX, DRES, CGCE,
     * TOL1, BIG1, UPRIV, RMIN, EPS, RESID, ZERO
      INTEGER IDISP(2)
      LOGICAL GROW, LBLOCK, ABORT, ABORT1, ABORT2, ABORT3, ABORTA,
     * ABORTB, LBIG, LBIG1
      COMMON /MA28ED/ LP, MP, LBLOCK, GROW
      COMMON /MA28FD/ EPS, RMIN, RESID, IRNCP, ICNCP, MINIRN, MINICN,
     * IRANK, ABORT1, ABORT2
      COMMON /MA28GD/ IDISP
      COMMON /MA28HD/ TOL, THEMAX, BIG, DXMAX, ERRMAX, DRES, CGCE,
     * NDROP, MAXIT, NOITER, NSRCH, ISTART, LBIG
      COMMON /MA30ID/ TOL1, BIG1, NDROP1, NSRCH1, LBIG1
      COMMON /MA30ED/ NLP, ABORTA, ABORTB, ABORT3
      COMMON /MA30FD/ MIRNCP, MICNCP, MIRANK, MIRN, MICN
      COMMON /MC23BD/ MLP, NUMNZ, NUM, LARGE, ABORT
      EXTERNAL MA28JD
C
C SOME  INITIALIZATION AND TRANSFER OF INFORMATION BETWEEN
C     COMMON BLOCKS (SEE EARLIER COMMENTS).
      DATA ZERO /0.0D0/
      IFLAG = 0
      ABORTA = ABORT1
      ABORTB = ABORT2
      ABORT = ABORT1
      MLP = LP
      NLP = LP
      TOL1 = TOL
      LBIG1 = LBIG
      NSRCH1 = NSRCH
C UPRIV PRIVATE COPY OF U IS USED IN CASE IT IS OUTSIDE
C     RANGE  ZERO TO ONE  AND  IS THUS ALTERED BY MA30A/AD.
      UPRIV = U
C SIMPLE DATA CHECK ON INPUT VARIABLES AND ARRAY DIMENSIONS.
      IF (N.GT.0) GO TO 10
      IFLAG = -8
      IF (LP.NE.0) WRITE (LP,99999) N
      GO TO 210
   10 IF (NZ.GT.0) GO TO 20
      IFLAG = -9
      IF (LP.NE.0) WRITE (LP,99998) NZ
      GO TO 210
   20 IF (LICN.GE.NZ) GO TO 30
      IFLAG = -10
      IF (LP.NE.0) WRITE (LP,99997) LICN
      GO TO 210
   30 IF (LIRN.GE.NZ) GO TO 40
      IFLAG = -11
      IF (LP.NE.0) WRITE (LP,99996) LIRN
      GO TO 210
C
C DATA CHECK TO SEE IF ALL INDICES LIE BETWEEN 1 AND N.
   40 DO 50 I=1,NZ
        IF (IRN(I).GT.0 .AND. IRN(I).LE.N .AND. ICN(I).GT.0 .AND.
     *   ICN(I).LE.N) GO TO 50
        IF (IFLAG.EQ.0 .AND. LP.NE.0) WRITE (LP,99995)
        IFLAG = -12
        IF (LP.NE.0) WRITE (LP,99994) I, A(I), IRN(I), ICN(I)
   50 CONTINUE
      IF (IFLAG.LT.0) GO TO 220
C
C SORT MATRIX INTO ROW ORDER.
      CALL MC20AD(N, NZ, A, ICN, IW, IRN, 0)
C PART OF IKEEP IS USED HERE AS A WORK-ARRAY.  IKEEP(I,2) IS
C     THE LAST ROW TO HAVE A NON-ZERO IN COLUMN I.  IKEEP(I,3)
C     IS THE OFF-SET OF COLUMN I FROM THE START OF THE ROW.
      DO 60 I=1,N
        IKEEP(I,2) = 0
        IKEEP(I,1) = 0
   60 CONTINUE
C
C CHECK FOR DUPLICATE ELEMENTS .. SUMMING ANY SUCH ENTRIES AND
C     PRINTING A WARNING MESSAGE ON UNIT MP.
C MOVE IS EQUAL TO THE NUMBER OF DUPLICATE ELEMENTS FOUND.
      MOVE = 0
C THE LOOP ALSO CALCULATES THE LARGEST ELEMENT IN THE MATRIX, THEMAX.
      THEMAX = ZERO
C J1 IS POSITION IN ARRAYS OF FIRST NON-ZERO IN ROW.
      J1 = IW(1,1)
      DO 130 I=1,N
        IEND = NZ + 1
        IF (I.NE.N) IEND = IW(I+1,1)
        LENGTH = IEND - J1
        IF (LENGTH.EQ.0) GO TO 130
        J2 = IEND - 1
        NEWJ1 = J1 - MOVE
        DO 120 JJ=J1,J2
          J = ICN(JJ)
          THEMAX = DMAX1(THEMAX,DABS(A(JJ)))
          IF (IKEEP(J,2).EQ.I) GO TO 110
C FIRST TIME COLUMN HAS OCURRED IN CURRENT ROW.
          IKEEP(J,2) = I
          IKEEP(J,3) = JJ - MOVE - NEWJ1
          IF (MOVE.EQ.0) GO TO 120
C SHIFT NECESSARY BECAUSE OF  PREVIOUS DUPLICATE ELEMENT.
          NEWPOS = JJ - MOVE
          A(NEWPOS) = A(JJ)
          ICN(NEWPOS) = ICN(JJ)
          GO TO 120
C DUPLICATE ELEMENT.
  110     MOVE = MOVE + 1
          LENGTH = LENGTH - 1
          JAY = IKEEP(J,3) + NEWJ1
          IF (MP.NE.0) WRITE (MP,99993) I, J, A(JJ)
          A(JAY) = A(JAY) + A(JJ)
          THEMAX = DMAX1(THEMAX,DABS(A(JAY)))
  120   CONTINUE
        IKEEP(I,1) = LENGTH
        J1 = IEND
  130 CONTINUE
C
C KNUM IS ACTUAL NUMBER OF NON-ZEROS IN MATRIX WITH ANY MULTIPLE
C     ENTRIES COUNTED ONLY ONCE.
      KNUM = NZ - MOVE
      IF (.NOT.LBLOCK) GO TO 140
C
C PERFORM BLOCK TRIANGULARISATION.
      CALL MC23AD(N, ICN, A, LICN, IKEEP, IDISP, IKEEP(1,2),
     *IKEEP(1,3), IKEEP(1,5), IW(1,3), IW)
      IF (IDISP(1).GT.0) GO TO 170
      IFLAG = -7
      IF (IDISP(1).EQ.-1) IFLAG = -1
      IF (LP.NE.0) WRITE (LP,99992)
      GO TO 210
C
C BLOCK TRIANGULARIZATION NOT REQUESTED.
C MOVE STRUCTURE TO END OF DATA ARRAYS IN PREPARATION FOR
C     MA30A/AD.
C ALSO SET LENOFF(1) TO -1 AND SET PERMUTATION ARRAYS.
  140 DO 150 I=1,KNUM
        II = KNUM - I + 1
        NEWPOS = LICN - I + 1
        ICN(NEWPOS) = ICN(II)
        A(NEWPOS) = A(II)
  150 CONTINUE
      IDISP(1) = 1
      IDISP(2) = LICN - KNUM + 1
      DO 160 I=1,N
        IKEEP(I,2) = I
        IKEEP(I,3) = I
  160 CONTINUE
      IKEEP(1,5) = -1
  170 IF (LBIG) BIG1 = THEMAX
      IF (NSRCH.LE.N) GO TO 180
C
C PERFORM L/U DECOMOSITION ON DIAGONAL BLOCKS.
      CALL MA30AD(N, ICN, A, LICN, IKEEP, IKEEP(1,4), IDISP,
     *IKEEP(1,2), IKEEP(1,3), IRN, LIRN, IW(1,2), IW(1,3), IW(1,4),
     *IW(1,5), IW(1,6), IW(1,7), IW(1,8), IW, UPRIV, IFLAG)
      GO TO 190
C THIS CALL IF USED IF NSRCH HAS BEEN SET LESS THAN OR EQUAL N.
C     IN THIS CASE, TWO INTEGER WORK ARRAYS OF LENGTH CAN BE SAVED.
  180 CALL MA30AD(N, ICN, A, LICN, IKEEP, IKEEP(1,4), IDISP,
     * IKEEP(1,2), IKEEP(1,3), IRN, LIRN, IW(1,2), IW(1,3), IW(1,4),
     * IW(1,5), IW, IW, IW(1,6), IW, UPRIV, IFLAG)
C
C TRANSFER COMMON BLOCK INFORMATION.
  190 MINIRN = MAX0(MIRN,NZ)
      MINICN = MAX0(MICN,NZ)
      IRNCP = MIRNCP
      ICNCP = MICNCP
      IRANK = MIRANK
      NDROP = NDROP1
      IF (LBIG) BIG = BIG1
      IF (IFLAG.GE.0) GO TO 200
      IF (LP.NE.0) WRITE (LP,99991)
      GO TO 210
C
C REORDER OFF-DIAGONAL BLOCKS ACCORDING TO PIVOT PERMUTATION.
  200 I1 = IDISP(1) - 1
      IF (I1.NE.0) CALL MC22AD(N, ICN, A, I1, IKEEP(1,5), IKEEP(1,2),
     * IKEEP(1,3), IW, IRN)
      I1 = IDISP(1)
      IEND = LICN - I1 + 1
C
C OPTIONALLY CALCULATE ELEMENT GROWTH ESTIMATE.
      IF (GROW) CALL MC24AD(N, ICN, A(I1), IEND, IKEEP, IKEEP(1,4), W)
C INCREMENT GROWTH ESTIMATE BY ORIGINAL MAXIMUM ELEMENT.
      IF (GROW) W(1) = W(1) + THEMAX
      IF (GROW .AND. N.GT.1) W(2) = THEMAX
C SET FLAG IF THE ONLY ERROR IS DUE TO DUPLICATE ELEMENTS.
      IF (IFLAG.GE.0 .AND. MOVE.NE.0) IFLAG = -14
      GO TO 220
  210 IF (LP.NE.0) WRITE (LP,99990)
  220 RETURN
99999 FORMAT (36X, 17HN OUT OF RANGE = , I10)
99998 FORMAT (36X, 18HNZ NON POSITIVE = , I10)
99997 FORMAT (36X, 17HLICN TOO SMALL = , I10)
99996 FORMAT (36X, 17HLIRN TOO SMALL = , I10)
99995 FORMAT (54H ERROR RETURN FROM MA28A/AD BECAUSE INDICES FOUND OUT ,
     * 8HOF RANGE)
99994 FORMAT (1X, I6, 22HTH ELEMENT WITH VALUE , 1PD22.14, 9H IS OUT O,
     * 21HF RANGE WITH INDICES , I8, 2H ,, I8)
99993 FORMAT (31H DUPLICATE ELEMENT IN POSITION , I8, 2H ,, I8,
     * 12H WITH VALUE , 1PD22.14)
99992 FORMAT (36X, 26HERROR RETURN FROM MC23A/AD)
99991 FORMAT (36X, 26HERROR RETURN FROM MA30A/AD)
99990 FORMAT (36H+ERROR RETURN FROM MA28A/AD BECAUSE )
      END
      SUBROUTINE MA28BD(N, NZ, A, LICN, IVECT, JVECT, ICN, IKEEP, IW, W,
     * IFLAG)
C THIS SUBROUTINE FACTORIZES A MATRIX OF A SIMILAR SPARSITY
C     PATTERN TO THAT PREVIOUSLY FACTORIZED BY MA28A/AD.
C THE PARAMETERS ARE AS FOLLOWS ...
C N      INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C NZ     INTEGER  NUMBER OF NON-ZEROS IN INPUT MATRIX  NOT ALTERED
C     BY SUBROUTINE.
C A      REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  HOLDS NON-ZEROS OF
C     MATRIX ON ENTRY AND NON-ZEROS OF FACTORS ON EXIT.  REORDERED BY
C     MA28D/DD AND ALTERED BY SUBROUTINE MA30B/BD.
C LICN   INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C IVECT,JVECT  INTEGER ARRAYS OF LENGTH NZ.  HOLD ROW AND COLUMN
C     INDICES OF NON-ZEROS RESPECTIVELY.  NOT ALTERED BY SUBROUTINE.
C ICN    INTEGER ARRAY OF LENGTH LICN.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28B/BD.
C IKEEP  INTEGER ARRAY OF LENGTH 5*N.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28B/BD.
C IW     INTEGER ARRAY  LENGTH 5*N.  USED AS WORKSPACE BY MA28D/DD AND
C     MA30B/BD.
C W      REAL/DOUBLE PRECISION ARRAY  LENGTH N.  USED AS WORKSPACE
C     BY MA28D/DD,MA30B/BD AND (OPTIONALLY) MC24A/AD.
C IFLAG  INTEGER  USED AS ERROR FLAG WITH POSITIVE OR ZERO VALUE
C     INDICATING SUCCESS.
C
      INTEGER N, NZ, LICN, IW(N,5), IFLAG
      INTEGER IKEEP(N,5), IVECT(NZ), JVECT(NZ), ICN(LICN)
      DOUBLE PRECISION A(LICN), W(N)
C
C PRIVATE AND COMMON VARIABLES.
C UNLESS OTHERWISE STATED COMMON BLOCK VARIABLES ARE AS IN MA28A/AD.
C     THOSE VARIABLES REFERENCED BY MA28B/BD ARE MENTIONED BELOW.
C LP,MP  INTEGERS  USED AS IN MA28A/AD AS UNIT NUMBER FOR ERROR AND
C     WARNING MESSAGES, RESPECTIVELY.
C NLP    INTEGER VARIABLE USED TO GIVE VALUE OF LP TO MA30E/ED.
C EPS    REAL/DOUBLE PRECISION  MA30B/BD WILL OUTPUT A POSITIVE VALUE
C     FOR IFLAG IF ANY MODULUS OF THE RATIO OF PIVOT ELEMENT TO THE
C     LARGEST ELEMENT IN ITS ROW (U PART ONLY) IS LESS THAN EPS (UNLESS
C     EPS IS GREATER THAN 1.0 WHEN NO ACTION TAKES PLACE).
C RMIN   REAL/DOUBLE PRECISION  VARIABLE EQUAL TO THE VALUE OF THIS
C     MINIMUM RATIO IN CASES WHERE EPS IS LESS THAN OR EQUAL TO 1.0.
C MEPS,MRMIN  REAL/DOUBLE PRECISION VARIABLES USED BY THE SUBROUTINE
C     TO COMMUNICATE BETWEEN COMMON BLOCKS MA28F/FD AND MA30G/GD.
C IDISP  INTEGER ARRAY  LENGTH 2  THE SAME AS THAT USED BY MA28A/AD.
C     IT IS UNCHANGED BY MA28B/BD.
C
C SEE BLOCK DATA OR MA28A/AD FOR FURTHER COMMENTS ON VARIABLES
C     IN COMMON.
C SEE CODE FOR COMMENTS ON PRIVATE VARIABLES.
C
      LOGICAL GROW, LBLOCK, ABORTA, ABORTB, ABORT1, ABORT2, ABORT3,
     * LBIG, LBIG1
      INTEGER IDISP(2)
      DOUBLE PRECISION EPS, MEPS, RMIN, MRMIN, RESID, TOL,
     * THEMAX, BIG, DXMAX, ERRMAX, DRES, CGCE, TOL1, BIG1
C
      COMMON /MA28ED/ MP, LP, LBLOCK, GROW
      COMMON /MA28FD/ EPS, RMIN, RESID, IRNCP, ICNCP, MINIRN, MINICN,
     * IRANK, ABORT1, ABORT2
      COMMON /MA28GD/ IDISP
      COMMON /MA28HD/ TOL, THEMAX, BIG, DXMAX, ERRMAX, DRES, CGCE,
     * NDROP, MAXIT, NOITER, NSRCH, ISTART, LBIG
      COMMON /MA30ED/ NLP, ABORTA, ABORTB, ABORT3
      COMMON /MA30GD/ MEPS, MRMIN
      COMMON /MA30ID/ TOL1, BIG1, NDROP1, NSRCH1, LBIG1
C
C CHECK TO SEE IF ELEMENTS WERE DROPPED IN PREVIOUS MA28A/AD CALL.
      IF (NDROP.EQ.0) GO TO 10
      IFLAG = -15
      WRITE (6,99999) IFLAG, NDROP
      GO TO 70
   10 IFLAG = 0
      MEPS = EPS
      NLP = LP
C SIMPLE DATA CHECK ON VARIABLES.
      IF (N.GT.0) GO TO 20
      IFLAG = -11
      IF (LP.NE.0) WRITE (LP,99998) N
      GO TO 60
   20 IF (NZ.GT.0) GO TO 30
      IFLAG = -10
      IF (LP.NE.0) WRITE (LP,99997) NZ
      GO TO 60
   30 IF (LICN.GE.NZ) GO TO 40
      IFLAG = -9
      IF (LP.NE.0) WRITE (LP,99996) LICN
      GO TO 60
C
   40 CALL MA28DD(N, A, LICN, IVECT, JVECT, NZ, ICN, IKEEP, IKEEP(1,4),
     * IKEEP(1,5), IKEEP(1,2), IKEEP(1,3), IW(1,3), IW, W(1), IFLAG)
C THEMAX IS LARGEST ELEMENT IN MATRIX.
      THEMAX = W(1)
      IF (LBIG) BIG1 = THEMAX
C IDUP EQUALS ONE IF THERE WERE DUPLICATE ELEMENTS, ZERO OTHERWISE.
      IDUP = 0
      IF (IFLAG.EQ.(N+1)) IDUP = 1
      IF (IFLAG.LT.0) GO TO 60
C
C PERFORM ROW-GAUSS ELIMINATION ON THE STRUCTURE RECEIVED FROM MA28D/DD
      CALL MA30BD(N, ICN, A, LICN, IKEEP, IKEEP(1,4), IDISP,
     * IKEEP(1,2), IKEEP(1,3), W, IW, IFLAG)
C
C TRANSFER COMMON BLOCK INFORMATION.
      IF (LBIG) BIG1 = BIG
      RMIN = MRMIN
      IF (IFLAG.GE.0) GO TO 50
      IFLAG = -2
      IF (LP.NE.0) WRITE (LP,99995)
      GO TO 60
C
C OPTIONALLY CALCULATE THE GROWTH PARAMETER.
   50 I1 = IDISP(1)
      IEND = LICN - I1 + 1
      IF (GROW) CALL MC24AD(N, ICN, A(I1), IEND, IKEEP, IKEEP(1,4), W)
C INCREMENT ESTIMATE BY LARGEST ELEMENT IN INPUT MATRIX.
      IF (GROW) W(1) = W(1) + THEMAX
      IF (GROW .AND. N.GT.1) W(2) = THEMAX
C SET FLAG IF THE ONLY ERROR IS DUE TO DUPLICATE ELEMENTS.
      IF (IDUP.EQ.1 .AND. IFLAG.GE.0) IFLAG = -14
      GO TO 70
   60 IF (LP.NE.0) WRITE (LP,99994)
   70 RETURN
99999 FORMAT (39H ERROR RETURN FROM MA28B/BD WITH IFLAG=, I4/I7, 4H ENT,
     * 39HRIES DROPPED FROM STRUCTURE BY MA28A/AD)
99998 FORMAT (36X, 17HN OUT OF RANGE = , I10)
99997 FORMAT (36X, 18HNZ NON POSITIVE = , I10)
99996 FORMAT (36X, 17HLICN TOO SMALL = , I10)
99995 FORMAT (36X, 26HERROR RETURN FROM MA30B/BD)
99994 FORMAT (36H+ERROR RETURN FROM MA28B/BD BECAUSE )
      END
      SUBROUTINE MA28DD(N, A, LICN, IVECT, JVECT, NZ, ICN, LENR, LENRL,
     * LENOFF, IP, IQ, IW1, IW, W1, IFLAG)
C THIS SUBROUTINE NEED NEVER BE CALLED BY THE USER DIRECTLY.
C     IT SORTS THE USER'S MATRIX INTO THE STRUCTURE OF THE DECOMPOSED
C     FORM AND CHECKS FOR THE PRESENCE OF DUPLICATE ENTRIES OR
C     NON-ZEROS LYING OUTSIDE THE SPARSITY PATTERN OF THE DECOMPOSITION
C     IT ALSO CALCULATES THE LARGEST ELEMENT IN THE INPUT MATRIX.
      DOUBLE PRECISION A(LICN), ZERO, W1, AA
      INTEGER IW(N,2), IDISP(2)
      INTEGER ICN(LICN), IVECT(NZ), JVECT(NZ), IP(N), IQ(N),
     * LENR(N), IW1(N,3), LENRL(N), LENOFF(N)
      LOGICAL LBLOCK, GROW, BLOCKL
      COMMON /MA28ED/ LP, MP, LBLOCK, GROW
      COMMON /MA28GD/ IDISP
      DATA ZERO /0.0D0/
      BLOCKL = LENOFF(1).GE.0
C IW1(I,3)  IS SET TO THE BLOCK IN WHICH ROW I LIES AND THE
C     INVERSE PERMUTATIONS TO IP AND IQ ARE SET IN IW1(.,1) AND
C     IW1(.,2) RESP.
C POINTERS TO BEGINNING OF THE PART OF ROW I IN DIAGONAL AND
C   OFF-DIAGONAL BLOCKS ARE SET IN IW(I,2) AND IW(I,1) RESP.
      IBLOCK = 1
      IW(1,1) = 1
      IW(1,2) = IDISP(1)
      DO 10 I=1,N
        IW1(I,3) = IBLOCK
        IF (IP(I).LT.0) IBLOCK = IBLOCK + 1
        II = IABS(IP(I)+0)
        IW1(II,1) = I
        JJ = IQ(I)
        JJ = IABS(JJ)
        IW1(JJ,2) = I
        IF (I.EQ.1) GO TO 10
        IF (BLOCKL) IW(I,1) = IW(I-1,1) + LENOFF(I-1)
        IW(I,2) = IW(I-1,2) + LENR(I-1)
   10 CONTINUE
C PLACE EACH NON-ZERO IN TURN INTO ITS CORRECT LOCATION
C    IN THE A/ICN ARRAY.
      IDISP2 = IDISP(2)
      DO 170 I=1,NZ
C NECESSARY TO AVOID REFERENCE TO UNASSIGNED ELEMENT OF ICN.
        IF (I.GT.IDISP2) GO TO 20
        IF (ICN(I).LT.0) GO TO 170
   20   IOLD = IVECT(I)
        JOLD = JVECT(I)
        AA = A(I)
C THIS IS A DUMMY LOOP FOR FOLLOWING A CHAIN OF INTERCHANGES.
C   IT WILL BE EXECUTED NZ TIMES IN TOTAL.
        DO 140 IDUMMY=1,NZ
C PERFORM SOME VALIDITY CHECKS ON IOLD AND JOLD.
          IF (IOLD.LE.N .AND. IOLD.GT.0 .AND. JOLD.LE.N .AND.
     *     JOLD.GT.0) GO TO 30
          IF (LP.NE.0) WRITE (LP,99999) I, A(I), IOLD, JOLD
          IFLAG = -12
          GO TO 180
   30     INEW = IW1(IOLD,1)
          JNEW = IW1(JOLD,2)
C ARE WE IN A VALID BLOCK AND IS IT DIAGONAL OR OFF-DIAGONAL?
          IF (IW1(INEW,3)-IW1(JNEW,3)) 40, 60, 50
   40     IFLAG = -13
          IF (LP.NE.0) WRITE (LP,99998) IOLD, JOLD
          GO TO 180
   50     J1 = IW(INEW,1)
          J2 = J1 + LENOFF(INEW) - 1
          GO TO 110
C ELEMENT IS IN DIAGONAL BLOCK.
   60     J1 = IW(INEW,2)
          IF (INEW.GT.JNEW) GO TO 70
          J2 = J1 + LENR(INEW) - 1
          J1 = J1 + LENRL(INEW)
          GO TO 110
   70     J2 = J1 + LENRL(INEW)
C BINARY SEARCH OF ORDERED LIST  .. ELEMENT IN L PART OF ROW.
          DO 100 JDUMMY=1,N
            MIDPT = (J1+J2)/2
            JCOMP = IABS(ICN(MIDPT)+0)
            IF (JNEW-JCOMP) 80, 130, 90
   80       J2 = MIDPT
            GO TO 100
   90       J1 = MIDPT
  100     CONTINUE
          IFLAG = -13
          IF (LP.NE.0) WRITE (LP,99997) IOLD, JOLD
          GO TO 180
C LINEAR SEARCH ... ELEMENT IN L PART OF ROW OR OFF-DIAGONAL BLOCKS.
  110     DO 120 MIDPT=J1,J2
            IF (IABS(ICN(MIDPT)+0).EQ.JNEW) GO TO 130
  120     CONTINUE
          IFLAG = -13
          IF (LP.NE.0) WRITE (LP,99997) IOLD, JOLD
          GO TO 180
C EQUIVALENT ELEMENT OF ICN IS IN POSITION MIDPT.
  130     IF (ICN(MIDPT).LT.0) GO TO 160
          IF (MIDPT.GT.NZ .OR. MIDPT.LE.I) GO TO 150
          W1 = A(MIDPT)
          A(MIDPT) = AA
          AA = W1
          IOLD = IVECT(MIDPT)
          JOLD = JVECT(MIDPT)
          ICN(MIDPT) = -ICN(MIDPT)
  140   CONTINUE
  150   A(MIDPT) = AA
        ICN(MIDPT) = -ICN(MIDPT)
        GO TO 170
  160   A(MIDPT) = A(MIDPT) + AA
C SET FLAG FOR DUPLICATE ELEMENTS.
        IFLAG = N + 1
  170 CONTINUE
C RESET ICN ARRAY  AND ZERO ELEMENTS IN L/U BUT NOT IN A.
C ALSO CALCULATE MAXIMUM ELEMENT OF A.
  180 W1 = ZERO
      DO 200 I=1,IDISP2
        IF (ICN(I).LT.0) GO TO 190
        A(I) = ZERO
        GO TO 200
  190   ICN(I) = -ICN(I)
        W1 = DMAX1(W1,DABS(A(I)))
  200 CONTINUE
      RETURN
99999 FORMAT (9H ELEMENT , I6, 12H WITH VALUE , 1PD22.14, 10H HAS INDIC,
     * 3HES , I8, 2H ,, I8/36X, 20HINDICES OUT OF RANGE)
99998 FORMAT (36X, 8HNON-ZERO, I7, 2H ,, I6, 23H IN ZERO OFF-DIAGONAL B,
     * 4HLOCK)
99997 FORMAT (36X, 8H ELEMENT, I6, 2H ,, I6, 23H WAS NOT IN L/U PATTERN)
      END
      SUBROUTINE MA28CD(N, A, LICN, ICN, IKEEP, RHS, W, MTYPE)
C
C THIS SUBROUTINE USES THE FACTORS FROM MA28A/AD OR MA28B/BD TO
C     SOLVE A SYSTEM OF EQUATIONS WITHOUT ITERATIVE REFINEMENT.
C THE PARAMETERS ARE ...
C N   INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C A   REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  THE SAME ARRAY AS
C     WAS USED IN THE MOST RECENT CALL TO MA28A/AD OR MA28B/BD.
C LICN  INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C ICN    INTEGER ARRAY OF LENGTH LICN.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28C/CD.
C IKEEP  INTEGER ARRAY OF LENGTH 5*N.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28C/CD.
C RHS    REAL/DOUBLE PRECISION ARRAY  LENGTH N.  ON ENTRY, IT HOLDS THE
C     RIGHT HAND SIDE.  ON EXIT, THE SOLUTION VECTOR.
C W      REAL/DOUBLE PRECISION ARRAY  LENGTH N. USED AS WORKSPACE BY
C     MA30C/CD.
C MTYPE  INTEGER  USED TO TELL MA30C/CD TO SOLVE THE DIRECT EQUATION
C     (MTYPE=1) OR ITS TRANSPOSE (MTYPE.NE.1).
C
      DOUBLE PRECISION A(LICN), RHS(N), W(N), RESID, MRESID, EPS, RMIN
      INTEGER IDISP(2)
      INTEGER ICN(LICN), IKEEP(N,5)
      LOGICAL ABORT1, ABORT2
C COMMON BLOCK VARIABLES.
C UNLESS OTHERWISE STATED COMMON BLOCK VARIABLES ARE AS IN MA28A/AD.
C     THOSE VARIABLES REFERENCED BY MA28C/CD ARE MENTIONED BELOW.
C RESID  REAL/DOUBLE PRECISION  VARIABLE RETURNS MAXIMUM RESIDUAL OF
C     EQUATIONS WHERE PIVOT WAS ZERO.
C MRESID  REAL/DOUBLE PRECISION VARIABLE USED BY MA28C/CD TO
C     COMMUNICATE BETWEEN MA28F/FD AND MA30H/HD.
C IDISP  INTEGER ARRAY  LENGTH 2  THE SAME AS THAT USED BY MA28A/AD.
C     IT IS UNCHANGED BY MA28B/BD.
C
C FURTHER INFORMATION ON COMMON BLOCK VARIABLES CAN BE FOUND IN BLOCK
C     DATA OR MA28A/AD.
      COMMON /MA28FD/ EPS, RMIN, RESID, IRNCP, ICNCP, MINIRN, MINICN,
     * IRANK, ABORT1, ABORT2
      COMMON /MA28GD/ IDISP
      COMMON /MA30HD/ MRESID
C
C THIS CALL PERFORMS THE SOLUTION OF THE SET OF EQUATIONS.
      CALL MA30CD(N, ICN, A, LICN, IKEEP, IKEEP(1,4), IKEEP(1,5),
     * IDISP, IKEEP(1,2), IKEEP(1,3), RHS, W, MTYPE)
C TRANSFER COMMON BLOCK INFORMATION.
      RESID = MRESID
      RETURN
      END
      SUBROUTINE MA28ID(N, NZ, AORG, IRNORG, ICNORG, LICN, A, ICN,
     * IKEEP, RHS, X, R, W, MTYPE, PREC, IFLAG)
C THIS SUBROUTINE USES THE FACTORS FROM AN EARLIER CALL TO MA28A/AD
C     OR MA28B/BD TO SOLVE THE SYSTEM OF EQUATIONS WITH ITERATIVE
C     REFINEMENT.
C
C THE PARAMETERS ARE...
C
C N IS EQUAL TO THE ORDER OF THE MATRIX. IT IS NOT ALTERED BY THE
C     SUBROUTINE.
C NZ IS EQUAL TO THE NUMBER OF ENTRIES IN THE ORIGINAL MATRIX.  IT IS
C     NOT ALTERED BY THE SUBROUTINE.
C FOR THIS ENTRY THE ORIGINAL MATRIX MUST HAVE BEEN SAVED IN
C     AORG,IRNORG,ICNORG WHERE ENTRY AORG(K) IS IN ROW IRNORG(K) AND
C     COLUMN ICNORG(K), K=1,...NZ.  INFORMATION ABOUT THE FACTORS OF A
C     IS COMMUNICATED TO THIS SUBROUTINE VIA THE PARAMETERS LICN, A, ICN
C     AND IKEEP WHERE:
C AORG IS AN ARRAY OF LENGTH NZ.  NOT ALTERED BY MA28I/ID.
C IRNORG IS AN ARRAY OF LENGTH NZ.  NOT ALTERED BY MA28I/ID.
C ICNORG IS AN ARRAY OF LENGTH NZ.  NOT ALTERED BY MA28I/ID.
C LICN IS EQUAL TO THE LENGTH OF ARRAYS A AND ICN. IT IS NOT ALTERED BY
C     THE SUBROUTINE.
C A IS AN ARRAY OF LENGTH LICN. IT MUST BE UNCHANGED SINCE THE LAST CALL
C     TO MA28A/AD OR MA28B/BD. IT IS NOT ALTERED BY THE SUBROUTINE.
C ICN, IKEEP ARE THE ARRAYS (OF LENGTHS LICN AND 5*N, RESPECTIVELY) OF
C     THE SAME NAMES AS IN THE PREVIOUS ALL TO MA28A/AD. THEY SHOULD BE
C     UNCHANGED SINCE THIS EARLIER CALL AND    THEY ARE NOT ALTERED BY
C     MA28I/ID.
C THE  OTHER PARAMETERS ARE AS FOLLOWS:
C RHS IS AN ARRAY OF LENGTH N. THE USER MUST SET RHS(I) TO CONTAIN THE
C     VALUE OF THE I TH COMPONENT OF THE RIGHT HAND SIDE. IT IS NOT
C     ALTERED BY MA28I/ID.
C X IS AN ARRAY OF LENGTH N. IF AN INITIAL GUESS OF THE SOLUTION IS
C     GIVEN (ISTART EQUAL TO 1), THEN THE USER MUST SET X(I) TO CONTAIN
C     THE VALUE OF THE I TH COMPONENT OF THE ESTIMATED SOLUTION.  ON
C     EXIT, X(I) CONTAINS THE I TH COMPONENT OF THE SOLUTION VECTOR.
C R IS AN ARRAY OF LENGTH N. IT NEED NOT BE SET ON ENTRY.  ON EXIT, R(I)
C     CONTAINS THE I TH COMPONENT OF AN ESTIMATE OF THE ERROR IF MAXIT
C     IS GREATER THAN 0.
C W IS AN ARRAY OF LENGTH N. IT IS USED AS WORKSPACE BY MA28I/ID.
C MTYPE MUST BE SET TO DETERMINE WHETHER MA28I/ID WILL SOLVE A*X=RHS
C     (MTYPE EQUAL TO 1) OR AT*X=RHS (MTYPE NE 1, ZERO SAY). IT IS NOT
C     ALTERED BY MA28I/ID.
C PREC SHOULD BE SET BY THE USER TO THE RELATIVE ACCURACY REQUIRED. THE
C     ITERATIVE REFINEMENT WILL TERMINATE IF THE MAGNITUDE OF THE
C     LARGEST COMPONENT OF THE ESTIMATED ERROR RELATIVE TO THE LARGEST
C     COMPONENT IN THE SOLUTION IS LESS THAN PREC.  IT IS NOT ALTERED BY
C     MA28I/ID.
C IFLAG IS A DIAGNOSTIC FLAG WHICH WILL BE SET TO ZERO ON SUCCESSFUL
C     EXIT FROM MA28I/ID, OTHERWISE IT WILL HAVE A NON-ZERO VALUE. THE
C     NON-ZERO VALUE IFLAG CAN HAVE ON EXIT FROM MA28I/ID ARE ...
C     -16    INDICATING THAT MORE THAN MAXIT ITEARTIONS ARE REQUIRED.
C     -17    INDICATING THAT MORE CONVERGENCE WAS TOO SLOW.
C
      INTEGER N, NZ, LICN, MTYPE, IFLAG
      INTEGER ICNORG(NZ), IRNORG(NZ), IKEEP(N,5), ICN(LICN)
      DOUBLE PRECISION A(LICN), AORG(NZ), RHS(N), R(N), X(N), W(N), PREC
C
C PRIVATE AND COMMON VARIABLES.
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C SEE COMMENTS IN CODE FOR USE OF PRIVATE VARIABLES.
C
      LOGICAL LBLOCK, GROW, LBIG
      INTEGER LP, MP, NDROP, MAXIT, NOITER, ISTART
      DOUBLE PRECISION TOL, THEMAX, BIG, DXMAX, ERRMAX, DRES,
     * CGCE, D, DD, CONVER, ZERO
      COMMON /MA28ED/ LP, MP, LBLOCK, GROW
      COMMON /MA28HD/ TOL, THEMAX, BIG, DXMAX, ERRMAX, DRES, CGCE,
     * NDROP, MAXIT, NOITER, NSRCH, ISTART, LBIG
C
      DATA ZERO /0.0D0/
C
C   INITIALIZATION OF NOITER, ERRMAX AND IFLAG.
C
      NOITER = 0
      ERRMAX = ZERO
      IFLAG = 0
C
C  JUMP IF A STARTING VECTOR HAS BEEN SUPPLIED BY THE USER.
C
      IF (ISTART.EQ.1) GO TO 20
C
C  MAKE A COPY OF THE RIGHT-HAND SIDE VECTOR.
C
      DO 10 I=1,N
        X(I) = RHS(I)
   10 CONTINUE
C
C  FIND THE FIRST SOLUTION.
C
      CALL MA28CD(N, A, LICN, ICN, IKEEP, X, W, MTYPE)
C
C  STOP THE COMPUTATIONS IF   MAXIT=0.
C
   20 IF (MAXIT.EQ.0) GO TO 160
C
C  CALCULATE THE MAX-NORM OF THE FIRST SOLUTION.
C
      DD = 0.0
      DO 30 I=1,N
        DD = DMAX1(DD,DABS(X(I)))
   30 CONTINUE
      DXMAX = DD
C
C  BEGIN THE ITERATIVE PROCESS.
C
      DO 120 ITERAT=1,MAXIT
        D = DD
C
C  CALCULATE THE RESIDUAL VECTOR.
C
        DO 40 I=1,N
          R(I) = RHS(I)
   40   CONTINUE
        IF (MTYPE.EQ.1) GO TO 60
        DO 50 I=1,NZ
          NROW = IRNORG(I)
          NCOL = ICNORG(I)
          R(NCOL) = R(NCOL) - AORG(I)*X(NROW)
   50   CONTINUE
        GO TO 80
C MTYPE=1.
   60   DO 70 I=1,NZ
          NROW = IRNORG(I)
          NCOL = ICNORG(I)
          R(NROW) = R(NROW) - AORG(I)*X(NCOL)
   70   CONTINUE
   80   DRES = 0.0
C
C  FIND THE MAX-NORM OF THE RESIDUAL VECTOR.
C
        DO 90 I=1,N
          DRES = DMAX1(DRES,DABS(R(I)))
   90   CONTINUE
C
C  STOP THE CALCULATIONS IF THE MAX-NORM OF
C  THE RESIDUAL VECTOR IS ZERO.
C
        IF (DRES.EQ.0.0) GO TO 150
C
C  CALCULATE THE CORRECTION VECTOR.
C
        NOITER = NOITER + 1
        CALL MA28CD(N, A, LICN, ICN, IKEEP, R, W, MTYPE)
C
C  FIND THE MAX-NORM OF THE CORRECTION VECTOR.
C
        DD = 0.0
        DO 100 I=1,N
          DD = DMAX1(DD,DABS(R(I)))
  100   CONTINUE
C
C  CHECK THE CONVERGENCE.
C
        IF (DD.GT.D*CGCE .AND. ITERAT.GE.2) GO TO 130
        IF (DXMAX*10.0+DD.EQ.DXMAX*10.0) GO TO 140
C
C  ATTEMPT TO IMPROVE THE SOLUTION.
C
        DXMAX = 0.0
        DO 110 I=1,N
          X(I) = X(I) + R(I)
          DXMAX = DMAX1(DXMAX,DABS(X(I)))
  110   CONTINUE
C
C  CHECK THE STOPPING CRITERION.
C
        IF (DD.LT.PREC*DXMAX) GO TO 140
  120 CONTINUE
C MORE THAN MAXIT ITERATIONS REQUIRED.
      IFLAG = -16
      WRITE (LP,99999) IFLAG, MAXIT
      GO TO 140
C CONVERGENCE RATE UNACCEPTABLY SLOW.
  130 IFLAG = -17
      CONVER = DD/D
      WRITE (LP,99998) IFLAG, CONVER, CGCE
C
C  THE ITERATIVE PROCESS IS TERMINATED.
C
  140 ERRMAX = DD
  150 CONTINUE
  160 RETURN
99999 FORMAT (41H ERROR RETURN FROM MA28I/ID WITH IFLAG = , I3/6H MORE ,
     * 4HTHAN, I5, 20H ITERATIONS REQUIRED)
99998 FORMAT (38H ERROR RETURN FROM MA28I WITH IFLAG = , I3/9H CONVERGE,
     * 12HNCE RATE OF , 1PE9.2, 9H TOO SLOW/24H MAXIMUM ACCEPTABLE RATE,
     * 8H SET TO , 1PE9.2)
      END
      BLOCK DATA MA28JD
C
C COMMENTS ON ALL THE COMMON BLOCK VARIABLES ARE GIVEN HERE EVEN
C     THOUGH SOME ARE NOT INITIALIZED BY BLOCK DATA.
C LP,MP ARE USED BY THE SUBROUTINE AS THE UNIT NUMBERS FOR ITS WARNING
C     AND DIAGNOSTIC MESSAGES. DEFAULT VALUE FOR BOTH IS 6 (FOR LINE
C     PRINTER OUTPUT). THE USER CAN EITHER RESET THEM TO A DIFFERENT
C     STREAM NUMBER OR SUPPRESS THE OUTPUT BY SETTING THEM TO ZERO.
C     WHILE LP DIRECTS THE OUTPUT OF ERROR DIAGNOSTICS FROM THE
C     PRINCIPAL SUBROUTINES AND INTERNALLY CALLED SUBROUTINES, MP
C     CONTROLS ONLY THE OUTPUT OF A MESSAGE WHICH WARNS THE USER THAT HE
C     HAS INPUT TWO OR MORE NON-ZEROS A(I), . . ,A(K) WITH THE SAME ROW
C     AND COLUMN INDICES.  THE ACTION TAKEN IN THIS CASE IS TO PROCEED
C     USING A NUMERICAL VALUE OF A(I)+...+A(K). IN THE ABSENCE OF OTHER
C     ERRORS, IFLAG WILL EQUAL -14 ON EXIT.
C LBLOCK IS A LOGICAL VARIABLE WHICH CONTROLS AN OPTION OF FIRST
C     PREORDERING THE MATRIX TO BLOCK LOWER TRIANGULAR FORM (USING
C     HARWELL SUBROUTINE MC23A). THE PREORDERING IS PERFORMED IF LBLOCK
C     IS EQUAL TO ITS DEFAULT VALUE OF .TRUE. IF LBLOCK IS SET TO
C     .FALSE. , THE OPTION IS NOT INVOKED AND THE SPACE ALLOCATED TO
C     IKEEP CAN BE REDUCED TO 4*N+1.
C GROW IS A LOGICAL VARIABLE. IF IT IS LEFT AT ITS DEFAULT VALUE OF
C     .TRUE. , THEN ON RETURN FROM MA28A/AD OR MA28B/BD, W(1) WILL GIVE
C     AN ESTIMATE (AN UPPER BOUND) OF THE INCREASE IN SIZE OF ELEMENTS
C     ENCOUNTERED DURING THE DECOMPOSITION. IF THE MATRIX IS WELL
C     SCALED, THEN A HIGH VALUE FOR W(1), RELATIVE TO THE LARGEST ENTRY
C     IN THE INPUT MATRIX, INDICATES THAT THE LU DECOMPOSITION MAY BE
C     INACCURATE AND THE USER SHOULD BE WARY OF HIS RESULTS AND PERHAPS
C     INCREASE U FOR SUBSEQUENT RUNS.  WE WOULD LIKE TO EMPHASISE THAT
C     THIS VALUE ONLY RELATES TO THE ACCURACY OF OUR LU DECOMPOSITION
C     AND GIVES NO INDICATION AS TO THE SINGULARITY OF THE MATRIX OR THE
C     ACCURACY OF THE SOLUTION.  THIS UPPER BOUND CAN BE A SIGNIFICANT
C     OVERESTIMATE PARTICULARLY IF THE MATRIX IS BADLY SCALED. IF AN
C     ACCURATE VALUE FOR THE GROWTH IS REQUIRED, LBIG (Q.V.) SHOULD BE
C     SET TO .TRUE.
C EPS,RMIN ARE REAL VARIABLES. IF, ON ENTRY TO MA28B/BD, EPS IS LESS
C     THAN ONE, THEN RMIN WILL GIVE THE SMALLEST RATIO OF THE PIVOT TO
C     THE LARGEST ELEMENT IN THE CORRESPONDING ROW OF THE UPPER
C     TRIANGULAR FACTOR THUS MONITORING THE STABILITY OF SUCCESSIVE
C     FACTORIZATIONS. IF RMIN BECOMES VERY LARGE AND W(1) FROM
C     MA28B/BD IS ALSO VERY LARGE, IT MAY BE ADVISABLE TO PERFORM A
C     NEW DECOMPOSITION USING MA28A/AD.
C RESID IS A REAL VARIABLE WHICH ON EXIT FROM MA28C/CD GIVES THE VALUE
C     OF THE MAXIMUM RESIDUAL OVER ALL THE EQUATIONS UNSATISFIED BECAUSE
C     OF DEPENDENCY (ZERO PIVOTS).
C IRNCP,ICNCP ARE INTEGER VARIABLES WHICH MONITOR THE ADEQUACY OF "ELBOW
C     ROOM" IN IRN AND A/ICN RESPECTIVELY. IF EITHER IS QUITE LARGE (SAY
C     GREATER THAN N/10), IT WILL PROBABLY PAY TO INCREASE THE SIZE OF
C     THE CORRESPONDING ARRAY FOR SUBSEQUENT RUNS. IF EITHER IS VERY LOW
C     OR ZERO THEN ONE CAN PERHAPS SAVE STORAGE BY REDUCING THE SIZE OF
C     THE CORRESPONDING ARRAY.
C MINIRN,MINICN ARE INTEGER VARIABLES WHICH, IN THE EVENT OF A
C     SUCCESSFUL RETURN (IFLAG GE 0 OR IFLAG=-14) GIVE THE MINIMUM SIZE
C     OF IRN AND A/ICN RESPECTIVELY WHICH WOULD ENABLE A SUCCESSFUL RUN
C     ON AN IDENTICAL MATRIX. ON AN EXIT WITH IFLAG EQUAL TO -5, MINICN
C     GIVES THE MINIMUM VALUE OF ICN FOR SUCCESS ON SUBSEQUENT RUNS ON
C     AN IDENTICAL MATRIX. IN THE EVENT OF FAILURE WITH IFLAG= -6, -4,
C     -3, -2, OR -1, THEN MINICN AND MINIRN GIVE THE MINIMUM VALUE OF
C     LICN AND LIRN RESPECTIVELY WHICH WOULD BE REQUIRED FOR A
C     SUCCESSFUL DECOMPOSITION UP TO THE POINT AT WHICH THE FAILURE
C     OCCURRED.
C IRANK IS AN INTEGER VARIABLE WHICH GIVES AN UPPER BOUND ON THE RANK OF
C     THE MATRIX.
C ABORT1 IS A LOGICAL VARIABLE WITH DEFAULT VALUE .TRUE.  IF ABORT1 IS
C     SET TO .FALSE.  THEN MA28A/AD WILL DECOMPOSE STRUCTURALLY SINGULAR
C     MATRICES (INCLUDING RECTANGULAR ONES).
C ABORT2 IS A LOGICAL VARIABLE WITH DEFAULT VALUE .TRUE.  IF ABORT2 IS
C     SET TO .FALSE. THEN MA28A/AD WILL DECOMPOSE NUMERICALLY SINGULAR
C     MATRICES.
C IDISP IS AN INTEGER ARRAY OF LENGTH 2. ON OUTPUT FROM MA28A/AD, THE
C     INDICES OF THE DIAGONAL BLOCKS OF THE FACTORS LIE IN POSITIONS
C     IDISP(1) TO IDISP(2) OF A/ICN. THIS ARRAY MUST BE PRESERVED
C     BETWEEN A CALL TO MA28A/AD AND SUBSEQUENT CALLS TO MA28B/BD,
C     MA28C/CD OR MA28I/ID.
C TOL IS A REAL VARIABLE.  IF IT IS SET TO A POSITIVE VALUE, THEN ANY
C     NON-ZERO WHOSE MODULUS IS LESS THAN TOL WILL BE DROPPED FROM THE
C     FACTORIZATION.  THE FACTORIZATION WILL THEN REQUIRE LESS STORAGE
C     BUT WILL BE INACCURATE.  AFTER A RUN OF MA28A/AD WITH TOL POSITIVE
C     IT IS NOT POSSIBLE TO USE MA28B/BD AND THE USER IS RECOMMENDED TO
C     USE MA28I/ID TO OBTAIN THE SOLUTION.  THE DEFAULT VALUE FOR TOL IS
C     0.0.
C THEMAX IS A REAL VARIABLE.  ON EXIT FROM MA28A/AD, IT WILL HOLD THE
C     LARGEST ENTRY OF THE ORIGINAL MATRIX.
C BIG IS A REAL VARIABLE. IF LBIG HAS BEEN SET TO .TRUE., BIG WILL HOLD
C     THE LARGEST ENTRY ENCOUNTERED DURING THE FACTORIZATION BY MA28A/AD
C     OR MA28B/BD.
C DXMAX IS A REAL VARIABLE. ON EXIT FROM MA28I/ID, DXMAX WILL BE SET TO
C     THE LARGEST COMPONENT OF THE SOLUTION.
C ERRMAX IS A REAL VARIABLE.  ON EXIT FROM MA28I/ID, IF MAXIT IS
C     POSITIVE, ERRMAX WILL BE SET TO THE LARGEST COMPONENT IN THE
C     ESTIMATE OF THE ERROR.
C DRES IS A REAL VARIABLE.  ON EXIT FROM MA28I/ID, IF MAXIT IS POSITIVE,
C     DRES WILL BE SET TO THE LARGEST COMPONENT OF THE RESIDUAL.
C CGCE IS A REAL VARIABLE. IT IS USED BY MA28I/ID TO CHECK THE
C     CONVERGENCE RATE.  IF THE RATIO OF SUCCESSIVE CORRECTIONS IS
C     NOT LESS THAN CGCE THEN WE TERMINATE SINCE THE CONVERGENCE
C     RATE IS ADJUDGED TOO SLOW.
C NDROP IS AN INTEGER VARIABLE. IF TOL HAS BEEN SET POSITIVE, ON EXIT
C     FROM MA28A/AD, NDROP WILL HOLD THE NUMBER OF ENTRIES DROPPED FROM
C     THE DATA STRUCTURE.
C MAXIT IS AN INTEGER VARIABLE. IT IS THE MAXIMUM NUMBER OF ITERATIONS
C     PERFORMED BY MA28I/ID. IT HAS A DEFAULT VALUE OF 16.
C NOITER IS AN INTEGER VARIABLE. IT IS SET BY MA28I/ID TO THE NUMBER OF
C     ITERATIVE REFINEMENT ITERATIONS ACTUALLY USED.
C NSRCH IS AN INTEGER VARIABLE. IF NSRCH IS SET TO A VALUE LESS THAN N,
C     THEN A DIFFERENT PIVOT OPTION WILL BE EMPLOYED BY MA28A/AD.  THIS
C     MAY RESULT IN DIFFERENT FILL-IN AND EXECUTION TIME FOR MA28A/AD.
C     IF NSRCH IS LESS THAN OR EQUAL TO N, THE WORKSPACE ARRAY IW CAN BE
C     REDUCED IN LENGTH.  THE DEFAULT VALUE FOR NSRCH IS 32768.
C ISTART IS AN INTEGER VARIABLE. IF ISTART IS SET TO A VALUE OTHER THAN
C     ZERO, THEN THE USER MUST SUPPLY AN ESTIMATE OF THE SOLUTION TO
C     MA28I/ID.  THE DEFAULT VALUE FOR ISTART IS ZERO.
C LBIG IS A LOGICAL VARIABLE. IF LBIG IS SET TO .TRUE., THE VALUE OF THE
C     LARGEST ELEMENT ENCOUNTERED IN THE FACTORIZATION BY MA28A/AD OR
C     MA28B/BD IS RETURNED IN BIG.  SETTING LBIG TO .TRUE.  WILL
C     INCREASE THE TIME FOR MA28A/AD MARGINALLY AND THAT FOR MA28B/BD
C     BY ABOUT 20%.  THE DEFAULT VALUE FOR LBIG IS .FALSE.
C
      DOUBLE PRECISION EPS, RMIN, RESID, TOL, THEMAX, BIG, DXMAX,
     * ERRMAX, DRES, CGCE
      LOGICAL LBLOCK, GROW, ABORT1, ABORT2, LBIG
      COMMON /MA28ED/ LP, MP, LBLOCK, GROW
      COMMON /MA28FD/ EPS, RMIN, RESID, IRNCP, ICNCP, MINIRN, MINICN,
     * IRANK, ABORT1, ABORT2
C     COMMON /MA28GD/ IDISP(2)
      COMMON /MA28HD/ TOL, THEMAX, BIG, DXMAX, ERRMAX, DRES, CGCE,
     * NDROP, MAXIT, NOITER, NSRCH, ISTART, LBIG
      DATA EPS /1.0D-4/, TOL /0.0D0/, CGCE /0.5D0/
      DATA MAXIT /16/
      DATA LP /6/, MP /6/, NSRCH /32768/, ISTART /0/
      DATA LBLOCK /.TRUE./, GROW /.TRUE./, LBIG /.FALSE./
      DATA ABORT1 /.TRUE./, ABORT2 /.TRUE./
      END
C######DATE   06 NOV 1987     COPYRIGHT UKAEA, HARWELL.
      FUNCTION FA01AS(I)                                                00000010
      COMMON/FA01ES/GL,GR                                               00000020
      EXTERNAL FA01FS
      DOUBLE PRECISION GL,GR,R,S                                        00000030
      R=GR*9228907D0/65536D0                                            00000040
      S=DINT(R)                                                         00000040
      GL=MOD(S+GL*9228907D0,65536D0)                                    00000040
      GR=R-S                                                            00000040
      IF(I.GE.0)FA01AS=(GL+GR)/65536D0                                  00000050
      IF(I.LT.0)FA01AS=(GL+GR)/32768D0-1.D0                             00000060
      GR=GR*65536D0
      RETURN                                                            00000070
      END                                                               00000080
      SUBROUTINE FA01BS(MAX,NRAND)                                      00000090
      NRAND=INT(FA01AS(1)*FLOAT(MAX))+1                                 00000100
      RETURN                                                            00000110
      END                                                               00000120
      SUBROUTINE FA01CS(IL,IR)                                          00000130
      COMMON/FA01ES/GL,GR                                               00000140
      DOUBLE PRECISION GL,GR                                            00000030
      EXTERNAL FA01FS
      IL=GL                                                             00000160
      IR=GR                                                             00000170
      RETURN                                                            00000180
      END                                                               00000190
      SUBROUTINE FA01DS(IL,IR)                                          00000200
      COMMON/FA01ES/GL,GR                                               00000140
      DOUBLE PRECISION GL,GR                                            00000030
      EXTERNAL FA01FS
      GL=IL                                                             00000220
      GR=IR                                                             00000230
      RETURN                                                            00000240
      END                                                               00000250
      BLOCK DATA FA01FS                                                 00000260
      COMMON/FA01ES/GL,GR                                               00000140
      DOUBLE PRECISION GL,GR                                            00000030
      DATA GL/21845D0/                                                  00000290
      DATA GR/21845D0/                                                  00000290
      END                                                               00000300
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MA30AD
      SUBROUTINE MA30AD(NN, ICN, A, LICN, LENR, LENRL, IDISP, IP, IQ,   0000000
     * IRN, LIRN, LENC, IFIRST, LASTR, NEXTR, LASTC, NEXTC, IPTR, IPC,  0000000
     * U, IFLAG)                                                        0000000
C IF  THE USER REQUIRES A MORE CONVENIENT DATA INTERFACE THEN THE MA28  0000000
C     PACKAGE SHOULD BE USED.  THE MA28 SUBROUTINES CALL THE MA30       0000000
C     SUBROUTINES AFTER CHECKING THE USER'S INPUT DATA AND OPTIONALLY   0000000
C     USING MC23A/AD TO PERMUTE THE MATRIX TO BLOCK TRIANGULAR FORM.    0000000
C THIS PACKAGE OF SUBROUTINES (MA30A/AD, MA30B/BD, MA30C/CD AND         0000000
C     MA30D/DD) PERFORMS OPERATIONS PERTINENT TO THE SOLUTION OF A      0000000
C     GENERAL SPARSE N BY N SYSTEM OF LINEAR EQUATIONS (I.E. SOLVE      0000000
C     AX=B). STRUCTUALLY SINGULAR MATRICES ARE PERMITTED INCLUDING      0000000
C     THOSE WITH ROW OR COLUMNS CONSISTING ENTIRELY OF ZEROS (I.E.      0000000
C     INCLUDING RECTANGULAR MATRICES).  IT IS ASSUMED THAT THE          0000000
C     NON-ZEROS OF THE MATRIX A DO NOT DIFFER WIDELY IN SIZE.  IF       0000000
C     NECESSARY A PRIOR CALL OF THE SCALING SUBROUTINE MC19A/AD MAY BE  0000000
C     MADE.                                                             0000000
C A DISCUSSION OF THE DESIGN OF THESE SUBROUTINES IS GIVEN BY DUFF AND  0000000
C     REID (ACM TRANS MATH SOFTWARE 5 PP 18-35,1979 (CSS 48)) WHILE     0000000
C     FULLER DETAILS OF THE IMPLEMENTATION ARE GIVEN IN DUFF (HARWELL   0000000
C     REPORT AERE-R 8730,1977).  THE ADDITIONAL PIVOTING OPTION IN      0000000
C     MA30A/AD AND THE USE OF DROP TOLERANCES (SEE COMMON BLOCK         0000000
C     MA30I/ID) WERE ADDED TO THE PACKAGE AFTER JOINT WORK WITH REID,   0000000
C     SCHAUMBURG, WASNIEWSKI AND ZLATEV (DUFF, REID, SCHAUMBURG,        0000000
C     WASNIEWSKI AND ZLATEV, HARWELL REPORT CSS 135, 1983).             0000000
C                                                                       0000000
C MA30A/AD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF THE  0000000
C     PERMUTATION PAQ OF A SPARSE MATRIX A, WHERE INPUT PERMUTATIONS    0000000
C     P1 AND Q1 ARE USED TO DEFINE THE DIAGONAL BLOCKS.  THERE MAY BE   0000000
C     NON-ZEROS IN THE OFF-DIAGONAL BLOCKS BUT THEY ARE UNAFFECTED BY   0000000
C     MA30A/AD. P AND P1 DIFFER ONLY WITHIN BLOCKS AS DO Q AND Q1. THE  0000000
C     PERMUTATIONS P1 AND Q1 MAY BE FOUND BY CALLING MC23A/AD OR THE    0000000
C     MATRIX MAY BE TREATED AS A SINGLE BLOCK BY USING P1=Q1=I. THE     0000000
C     MATRIX NON-ZEROS SHOULD BE HELD COMPACTLY BY ROWS, ALTHOUGH IT    0000000
C     SHOULD BE NOTED THAT THE USER CAN SUPPLY THE MATRIX BY COLUMNS    0000000
C     TO GET THE LU DECOMPOSITION OF A TRANSPOSE.                       0000000
C                                                                       0000000
C THE PARAMETERS ARE...                                                 0000000
C THIS DESCRIPTION SHOULD ALSO BE CONSULTED FOR FURTHER INFORMATION ON  0000000
C     MOST OF THE PARAMETERS OF MA30B/BD AND MA30C/CD.                  0000000
C                                                                       0000000
C N  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE ORDER
C     OF THE MATRIX.  IT IS NOT ALTERED BY MA30A/AD.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. POSITIONS IDISP(2) TO
C     LICN MUST BE SET BY THE USER TO CONTAIN THE COLUMN INDICES OF     0000000
C     THE NON-ZEROS IN THE DIAGONAL BLOCKS OF P1*A*Q1. THOSE BELONGING  0000000
C     TO A SINGLE ROW MUST BE CONTIGUOUS BUT THE ORDERING OF COLUMN     0000000
C     INDICES WITH EACH ROW IS UNIMPORTANT. THE NON-ZEROS OF ROW I      0000000
C     PRECEDE THOSE OF ROW I+1,I=1,...,N-1 AND NO WASTED SPACE IS       0000000
C     ALLOWED BETWEEN THE ROWS.  ON OUTPUT THE COLUMN INDICES OF THE    0000000
C     LU DECOMPOSITION OF PAQ ARE HELD IN POSITIONS IDISP(1) TO         0000000
C     IDISP(2), THE ROWS ARE IN PIVOTAL ORDER, AND THE COLUMN INDICES   0000000
C     OF THE L PART OF EACH ROW ARE IN PIVOTAL ORDER AND PRECEDE THOSE  0000000
C     OF U. AGAIN THERE IS NO WASTED SPACE EITHER WITHIN A ROW OR       0000000
C     BETWEEN THE ROWS. ICN(1) TO ICN(IDISP(1)-1), ARE NEITHER          0000000
C     REQUIRED NOR ALTERED. IF MC23A/AD BEEN CALLED, THESE WILL HOLD    0000000
C     INFORMATION ABOUT THE OFF-DIAGONAL BLOCKS.                        0000000
C A IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN WHOSE ENTRIES       0000000
C     IDISP(2) TO LICN MUST BE SET BY THE USER TO THE  VALUES OF THE    0000000
C     NON-ZERO ENTRIES OF THE MATRIX IN THE ORDER INDICATED BY  ICN.    0000000
C     ON OUTPUT A WILL HOLD THE LU FACTORS OF THE MATRIX WHERE AGAIN    0000000
C     THE POSITION IN THE MATRIX IS DETERMINED BY THE CORRESPONDING     0000000
C     VALUES IN ICN. A(1) TO A(IDISP(1)-1) ARE NEITHER REQUIRED NOR     0000000
C     ALTERED.                                                          0000000
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE     0000000
C     LENGTH OF ARRAYS ICN AND A. IT MUST BE BIG ENOUGH FOR A AND ICN   0000000
C     TO HOLD ALL THE NON-ZEROS OF L AND U AND LEAVE SOME "ELBOW        0000000
C     ROOM".  IT IS POSSIBLE TO CALCULATE A MINIMUM VALUE FOR LICN BY   0000000
C     A PRELIMINARY RUN OF MA30A/AD. THE ADEQUACY OF THE ELBOW ROOM     0000000
C     CAN BE JUDGED BY THE SIZE OF THE COMMON BLOCK VARIABLE ICNCP. IT  0000000
C     IS NOT ALTERED BY MA30A/AD.                                       0000000
C LENR  IS AN INTEGER ARRAY OF LENGTH N.  ON INPUT, LENR(I) SHOULD
C     EQUAL THE NUMBER OF NON-ZEROS IN ROW I, I=1,...,N OF THE          0000000
C     DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT, LENR(I) WILL EQUAL THE     0000000
C     TOTAL NUMBER OF NON-ZEROS IN ROW I OF L AND ROW I OF U.           0000000
C LENRL  IS AN INTEGER ARRAY OF LENGTH N. ON OUTPUT FROM MA30A/AD,
C     LENRL(I) WILL HOLD THE NUMBER OF NON-ZEROS IN ROW I OF L.         0000000
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. THE USER SHOULD SET IDISP(1)  0000000
C     TO BE THE FIRST AVAILABLE POSITION IN A/ICN FOR THE LU            0000000
C     DECOMPOSITION WHILE IDISP(2) IS SET TO THE POSITION IN A/ICN OF   0000000
C     THE FIRST NON-ZERO IN THE DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT,  0000000
C     IDISP(1) WILL BE UNALTERED WHILE IDISP(2) WILL BE SET TO THE      0000000
C     POSITION IN A/ICN OF THE LAST NON-ZERO OF THE LU DECOMPOSITION.   0000000
C IP  IS AN INTEGER ARRAY OF LENGTH N WHICH HOLDS A PERMUTATION OF
C     THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, THE ABSOLUTE VALUE OF 0000000
C     IP(I) MUST BE SET TO THE ROW OF A WHICH IS ROW I OF P1*A*Q1. A    0000000
C     NEGATIVE VALUE FOR IP(I) INDICATES THAT ROW I IS AT THE END OF A  0000000
C     DIAGONAL BLOCK.  ON OUTPUT FROM MA30A/AD, IP(I) INDICATES THE ROW 0000000
C     OF A WHICH IS THE I TH ROW IN PAQ. IP(I) WILL STILL BE NEGATIVE   0000000
C     FOR THE LAST ROW OF EACH BLOCK (EXCEPT THE LAST).                 0000000
C IQ IS AN INTEGER ARRAY OF LENGTH N WHICH AGAIN HOLDS A
C     PERMUTATION OF THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, IQ(J)  0000000
C     MUST BE SET TO THE COLUMN OF A WHICH IS COLUMN J OF P1*A*Q1. ON   0000000
C     OUTPUT FROM MA30A/AD, THE ABSOLUTE VALUE OF IQ(J) INDICATES THE   0000000
C     COLUMN OF A WHICH IS THE J TH IN PAQ.  FOR ROWS, I SAY, IN WHICH  0000000
C     STRUCTURAL OR NUMERICAL SINGULARITY IS DETECTED IQ(I) IS          0000000
C     NEGATED.                                                          0000000
C IRN  IS AN INTEGER ARRAY OF LENGTH LIRN USED AS WORKSPACE BY
C     MA30A/AD.                                                         0000000
C LIRN  IS AN INTEGER VARIABLE. IT SHOULD BE GREATER THAN THE           0000000
C     LARGEST NUMBER OF NON-ZEROS IN A DIAGONAL BLOCK OF P1*A*Q1 BUT    0000000
C     NEED NOT BE AS LARGE AS LICN. IT IS THE LENGTH OF ARRAY IRN AND   0000000
C     SHOULD BE LARGE ENOUGH TO HOLD THE ACTIVE PART OF ANY BLOCK,      0000000
C     PLUS SOME "ELBOW ROOM", THE  A POSTERIORI  ADEQUACY OF WHICH CAN  0000000
C     BE ESTIMATED BY EXAMINING THE SIZE OF COMMON BLOCK VARIABLE       0000000
C     IRNCP.                                                            0000000
C LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC ARE ALL INTEGER ARRAYS OF
C     LENGTH N WHICH ARE USED AS WORKSPACE BY MA30A/AD.  IF NSRCH IS    0000000
C     SET TO A VALUE LESS THAN OR EQUAL TO N, THEN ARRAYS LASTC AND     0000000
C     NEXTC ARE NOT REFERENCED BY MA30A/AD AND SO CAN BE DUMMIED IN     0000000
C     THE CALL TO MA30A/AD.                                             0000000
C IPTR,IPC ARE INTEGER ARRAYS OF LENGTH N WHICH ARE USED AS WORKSPACE   0000000
C     BY MA30A/AD.                                                      0000000
C U  IS A REAL/DOUBLE PRECISION VARIABLE WHICH SHOULD BE SET BY THE     0000000
C     USER TO A VALUE BETWEEN 0. AND 1.0. IF LESS THAN ZERO IT IS       0000000
C     RESET TO ZERO AND IF ITS VALUE IS 1.0 OR GREATER IT IS RESET TO   0000000
C     0.9999 (0.999999999 IN D VERSION).  IT DETERMINES THE BALANCE     0000000
C     BETWEEN PIVOTING FOR SPARSITY AND FOR STABILITY, VALUES NEAR      0000000
C     ZERO EMPHASIZING SPARSITY AND VALUES NEAR ONE EMPHASIZING         0000000
C     STABILITY. WE RECOMMEND U=0.1 AS A POSIBLE FIRST TRIAL VALUE.     0000000
C     THE STABILITY CAN BE JUDGED BY A LATER CALL TO MC24A/AD OR BY     0000000
C     SETTING LBIG TO .TRUE.                                            0000000
C IFLAG  IS AN INTEGER VARIABLE. IT WILL HAVE A NON-NEGATIVE VALUE IF   0000000
C     MA30A/AD IS SUCCESSFUL. NEGATIVE VALUES INDICATE ERROR            0000000
C     CONDITIONS WHILE POSITIVE VALUES INDICATE THAT THE MATRIX HAS     0000000
C     BEEN SUCCESSFULLY DECOMPOSED BUT IS SINGULAR. FOR EACH NON-ZERO   0000000
C     VALUE, AN APPROPRIATE MESSAGE IS OUTPUT ON UNIT LP.  POSSIBLE     0000000
C     NON-ZERO VALUES FOR IFLAG ARE ...                                 0000000
C                                                                       0000000
C -1  THE MATRIX IS STRUCTUALLY SINGULAR WITH RANK GIVEN BY IRANK IN    0000000
C     COMMON BLOCK MA30F/FD.                                            0000000
C +1  IF, HOWEVER, THE USER WANTS THE LU DECOMPOSITION OF A             0000000
C     STRUCTURALLY SINGULAR MATRIX AND SETS THE COMMON BLOCK VARIABLE   0000000
C     ABORT1 TO .FALSE., THEN, IN THE EVENT OF SINGULARITY AND A        0000000
C     SUCCESSFUL DECOMPOSITION, IFLAG IS RETURNED WITH THE VALUE +1     0000000
C     AND NO MESSAGE IS OUTPUT.                                         0000000
C -2  THE MATRIX IS NUMERICALLY SINGULAR (IT MAY ALSO BE STRUCTUALLY    0000000
C     SINGULAR) WITH ESTIMATED RANK GIVEN BY IRANK IN COMMON BLOCK      0000000
C     MA30F/FD.                                                         0000000
C +2  THE  USER CAN CHOOSE TO CONTINUE THE DECOMPOSITION EVEN WHEN A    0000000
C     ZERO PIVOT IS ENCOUNTERED BY SETTING COMMON BLOCK VARIABLE        0000000
C     ABORT2 TO .FALSE.  IF A SINGULARITY IS ENCOUNTERED, IFLAG WILL    0000000
C     THEN RETURN WITH A VALUE OF +2, AND NO MESSAGE IS OUTPUT IF THE   0000000
C     DECOMPOSITION HAS BEEN COMPLETED SUCCESSFULLY.                    0000000
C -3  LIRN HAS NOT BEEN LARGE ENOUGH TO CONTINUE WITH THE               0000000
C     DECOMPOSITION.  IF THE STAGE WAS ZERO THEN COMMON BLOCK VARIABLE  0000000
C     MINIRN GIVES THE LENGTH SUFFICIENT TO START THE DECOMPOSITION ON  0000000
C     THIS BLOCK.  FOR A SUCCESSFUL DECOMPOSITION ON THIS BLOCK THE     0000000
C     USER SHOULD MAKE LIRN SLIGHTLY (SAY ABOUT N/2) GREATER THAN THIS  0000000
C     VALUE.                                                            0000000
C -4  LICN NOT LARGE ENOUGH TO CONTINUE WITH THE DECOMPOSITION.         0000000
C -5  THE DECOMPOSITION HAS BEEN COMPLETED BUT SOME OF THE LU FACTORS   0000000
C     HAVE BEEN DISCARDED TO CREATE ENOUGH ROOM IN A/ICN TO CONTINUE    0000000
C     THE DECOMPOSITION. THE VARIABLE MINICN IN COMMON BLOCK MA30F/FD   0000000
C     THEN GIVES THE SIZE THAT LICN SHOULD BE TO ENABLE THE             0000000
C     FACTORIZATION TO BE SUCCESSFUL.  IF THE USER SETS COMMON BLOCK    0000000
C     VARIABLE ABORT3 TO .TRUE., THEN THE SUBROUTINE WILL EXIT          0000000
C     IMMEDIATELY INSTEAD OF DESTROYING ANY FACTORS AND CONTINUING.     0000000
C -6  BOTH LICN AND LIRN ARE TOO SMALL. TERMINATION HAS BEEN CAUSED BY  0000000
C     LACK OF SPACE IN IRN (SEE ERROR IFLAG= -3), BUT ALREADY SOME OF   0000000
C     THE LU FACTORS IN A/ICN HAVE BEEN LOST (SEE ERROR IFLAG= -5).     0000000
C     MINICN GIVES THE MINIMUM AMOUNT OF SPACE REQUIRED IN A/ICN FOR    0000000
C     DECOMPOSITION UP TO THIS POINT.                                   0000000
C                                                                       0000000
      DOUBLE PRECISION A(LICN), U, AU, UMAX, AMAX, ZERO, PIVRAT, PIVR,  0000000
     * TOL, BIG, ANEW, AANEW, SCALE                                     0000000
      INTEGER IPTR(NN), PIVOT, PIVEND, DISPC, OLDPIV, OLDEND, PIVROW,   0000000
     * ROWI, IPC(NN), IDISP(2), COLUPD                                  0000000
      INTEGER ICN(LICN), LENR(NN), LENRL(NN), IP(NN), IQ(NN),           0000000
     * LENC(NN), IRN(LIRN), IFIRST(NN), LASTR(NN), NEXTR(NN),           0000000
     * LASTC(NN), NEXTC(NN)                                             0000000
      LOGICAL ABORT1, ABORT2, ABORT3, LBIG                              0000000
C FOR COMMENTS OF COMMON BLOCK VARIABLES SEE BLOCK DATA SUBPROGRAM.
      COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3                        0000000
      COMMON /MA30FD/ IRNCP, ICNCP, IRANK, MINIRN, MINICN               0000000
      COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG                      0000000
      EXTERNAL MA30JD
C                                                                       0000000
      DATA UMAX/.999999999D0/                                           0000000
      DATA ZERO /0.0D0/                                                 0000000
      MSRCH = NSRCH                                                     0000000
      NDROP = 0                                                         0000000
      MINIRN = 0                                                        0000000
      MINICN = IDISP(1) - 1                                             0000000
      MOREI = 0                                                         0000000
      IRANK = NN                                                        0000000
      IRNCP = 0                                                         0000000
      ICNCP = 0                                                         0000000
      IFLAG = 0                                                         0000000
C RESET U IF NECESSARY.                                                 0000000
      U = DMIN1(U,UMAX)                                                 0000000
C IBEG IS THE POSITION OF THE NEXT PIVOT ROW AFTER ELIMINATION STEP     0000000
C     USING IT.                                                         0000000
      U = DMAX1(U,ZERO)                                                 0000000
      IBEG = IDISP(1)                                                   0000000
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE ACTIVE PART OF A/ICN.0000000
      IACTIV = IDISP(2)                                                 0000000
C NZROW IS CURRENT NUMBER OF NON-ZEROS IN ACTIVE AND UNPROCESSED PART   0000000
C     OF ROW FILE ICN.                                                  0000000
      NZROW = LICN - IACTIV + 1                                         0000000
      MINICN = NZROW + MINICN                                           0000000
C                                                                       0000000
C COUNT THE NUMBER OF DIAGONAL BLOCKS AND SET UP POINTERS TO THE        0000000
C     BEGINNINGS OF THE ROWS.                                           0000000
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.                                 0000000
      NUM = 1                                                           0000000
      IPTR(1) = IACTIV                                                  0000000
      IF (NN.EQ.1) GO TO 20                                             0000000
      NNM1 = NN - 1                                                     0000000
      DO 10 I=1,NNM1                                                    0000000
        IF (IP(I).LT.0) NUM = NUM + 1                                   0000000
        IPTR(I+1) = IPTR(I) + LENR(I)                                   0000000
   10 CONTINUE                                                          0000000
C ILAST IS THE LAST ROW IN THE PREVIOUS BLOCK.                          0000000
   20 ILAST = 0                                                         0000000
C                                                                       0000000
C ***********************************************                       0000000
C ****    LU DECOMPOSITION OF BLOCK NBLOCK   ****                       0000000
C ***********************************************                       0000000
C                                                                       0000000
C EACH PASS THROUGH THIS LOOP PERFORMS LU DECOMPOSITION ON ONE          0000000
C     OF THE DIAGONAL BLOCKS.                                           0000000
      DO 1000 NBLOCK=1,NUM                                              0000000
        ISTART = ILAST + 1                                              0000000
        DO 30 IROWS=ISTART,NN                                           0000000
          IF (IP(IROWS).LT.0) GO TO 40                                  0000000
   30   CONTINUE                                                        0000000
        IROWS = NN                                                      0000000
   40   ILAST = IROWS                                                   0000000
C N IS THE NUMBER OF ROWS IN THE CURRENT BLOCK.                         0000000
C ISTART IS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.            0000000
C ILAST IS THE INDEX OF THE LAST ROW IN THE CURRENT BLOCK.              0000000
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE BLOCK.               0000000
C ITOP IS THE POSITION OF THE LAST ENTRY IN THE BLOCK.                  0000000
        N = ILAST - ISTART + 1                                          0000000
        IF (N.NE.1) GO TO 90                                            0000000
C                                                                       0000000
C CODE FOR DEALING WITH 1X1 BLOCK.                                      0000000
        LENRL(ILAST) = 0                                                0000000
        ISING = ISTART                                                  0000000
        IF (LENR(ILAST).NE.0) GO TO 50                                  0000000
C BLOCK IS STRUCTURALLY SINGULAR.                                       0000000
        IRANK = IRANK - 1                                               0000000
        ISING = -ISING                                                  0000000
        IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG = 1                     0000000
        IF (.NOT.ABORT1) GO TO 80                                       0000000
        IDISP(2) = IACTIV                                               0000000
        IFLAG = -1                                                      0000000
        IF (LP.NE.0) WRITE (LP,99999)                                   0000000
C     RETURN                                                            0000000
        GO TO 1120                                                      0000000
   50   SCALE = DABS(A(IACTIV))                                         0000000
        IF (SCALE.EQ.ZERO) GO TO 60                                     0000000
        IF (LBIG) BIG = DMAX1(BIG,SCALE)                                0000000
        GO TO 70                                                        0000000
   60   ISING = -ISING                                                  0000000
        IRANK = IRANK - 1                                               0000000
        IPTR(ILAST) = 0                                                 0000000
        IF (IFLAG.NE.-5) IFLAG = 2                                      0000000
        IF (.NOT.ABORT2) GO TO 70                                       0000000
        IDISP(2) = IACTIV                                               0000000
        IFLAG = -2                                                      0000000
        IF (LP.NE.0) WRITE (LP,99998)                                   0000000
        GO TO 1120                                                      0000000
   70   A(IBEG) = A(IACTIV)                                             0000000
        ICN(IBEG) = ICN(IACTIV)                                         0000000
        IACTIV = IACTIV + 1                                             0000000
        IPTR(ISTART) = 0                                                0000000
        IBEG = IBEG + 1                                                 0000000
        NZROW = NZROW - 1                                               0000000
   80   LASTR(ISTART) = ISTART                                          0000000
        IPC(ISTART) = -ISING                                            0000000
        GO TO 1000                                                      0000000
C                                                                       0000000
C NON-TRIVIAL BLOCK.                                                    0000000
   90   ITOP = LICN                                                     0000000
        IF (ILAST.NE.NN) ITOP = IPTR(ILAST+1) - 1                       0000000
C                                                                       0000000
C SET UP COLUMN ORIENTED STORAGE.                                       0000000
        DO 100 I=ISTART,ILAST                                           0000000
          LENRL(I) = 0                                                  0000000
          LENC(I) = 0                                                   0000000
  100   CONTINUE                                                        0000000
        IF (ITOP-IACTIV.LT.LIRN) GO TO 110                              0000000
        MINIRN = ITOP - IACTIV + 1                                      0000000
        PIVOT = ISTART - 1                                              0000000
        GO TO 1100                                                      0000000
C                                                                       0000000
C CALCULATE COLUMN COUNTS.                                              0000000
  110   DO 120 II=IACTIV,ITOP                                           0000000
          I = ICN(II)                                                   0000000
          LENC(I) = LENC(I) + 1                                         0000000
  120   CONTINUE                                                        0000000
C SET UP COLUMN POINTERS SO THAT IPC(J) POINTS TO POSITION AFTER END    0000000
C     OF COLUMN J IN COLUMN FILE.                                       0000000
        IPC(ILAST) = LIRN + 1                                           0000000
        J1 = ISTART + 1                                                 0000000
        DO 130 JJ=J1,ILAST                                              0000000
          J = ILAST - JJ + J1 - 1                                       0000000
          IPC(J) = IPC(J+1) - LENC(J+1)                                 0000000
  130   CONTINUE                                                        0000000
        DO 150 INDROW=ISTART,ILAST                                      0000000
          J1 = IPTR(INDROW)                                             0000000
          J2 = J1 + LENR(INDROW) - 1                                    0000000
          IF (J1.GT.J2) GO TO 150                                       0000000
          DO 140 JJ=J1,J2                                               0000000
            J = ICN(JJ)                                                 0000000
            IPOS = IPC(J) - 1                                           0000000
            IRN(IPOS) = INDROW                                          0000000
            IPC(J) = IPOS                                               0000000
  140     CONTINUE                                                      0000000
  150   CONTINUE                                                        0000000
C DISPC IS THE LOWEST INDEXED ACTIVE LOCATION IN THE COLUMN FILE.       0000000
        DISPC = IPC(ISTART)                                             0000000
        NZCOL = LIRN - DISPC + 1                                        0000000
        MINIRN = MAX0(NZCOL,MINIRN)                                     0000000
        NZMIN = 1                                                       0000000
C                                                                       0000000
C INITIALIZE ARRAY IFIRST.  IFIRST(I) = +/- K INDICATES THAT ROW/COL    0000000
C     K HAS I NON-ZEROS.  IF IFIRST(I) = 0, THERE IS NO ROW OR COLUMN   0000000
C     WITH I NON ZEROS.                                                 0000000
        DO 160 I=1,N                                                    0000000
          IFIRST(I) = 0                                                 0000000
  160   CONTINUE                                                        0000000
C                                                                       0000000
C COMPUTE ORDERING OF ROW AND COLUMN COUNTS.                            0000000
C FIRST RUN THROUGH COLUMNS (FROM COLUMN N TO COLUMN 1).                0000000
        DO 180 JJ=ISTART,ILAST                                          0000000
          J = ILAST - JJ + ISTART                                       0000000
          NZ = LENC(J)                                                  0000000
          IF (NZ.NE.0) GO TO 170                                        0000000
          IPC(J) = 0                                                    0000000
          GO TO 180                                                     0000000
  170     IF (NSRCH.LE.NN) GO TO 180                                    0000000
          ISW = IFIRST(NZ)                                              0000000
          IFIRST(NZ) = -J                                               0000000
          LASTC(J) = 0                                                  0000000
          NEXTC(J) = -ISW                                               0000000
          ISW1 = IABS(ISW)                                              0000000
          IF (ISW.NE.0) LASTC(ISW1) = J                                 0000000
  180   CONTINUE                                                        0000000
C NOW RUN THROUGH ROWS (AGAIN FROM N TO 1).                             0000000
        DO 210 II=ISTART,ILAST                                          0000000
          I = ILAST - II + ISTART                                       0000000
          NZ = LENR(I)                                                  0000000
          IF (NZ.NE.0) GO TO 190                                        0000000
          IPTR(I) = 0                                                   0000000
          LASTR(I) = 0                                                  0000000
          GO TO 210                                                     0000000
  190     ISW = IFIRST(NZ)                                              0000000
          IFIRST(NZ) = I                                                0000000
          IF (ISW.GT.0) GO TO 200                                       0000000
          NEXTR(I) = 0                                                  0000000
          LASTR(I) = ISW                                                0000000
          GO TO 210                                                     0000000
  200     NEXTR(I) = ISW                                                0000000
          LASTR(I) = LASTR(ISW)                                         0000000
          LASTR(ISW) = I                                                0000000
  210   CONTINUE                                                        0000000
C                                                                       0000000
C                                                                       0000000
C **********************************************                        0000000
C ****    START OF MAIN ELIMINATION LOOP    ****                        0000000
C **********************************************                        0000000
        DO 980 PIVOT=ISTART,ILAST                                       0000000
C                                                                       0000000
C FIRST FIND THE PIVOT USING MARKOWITZ CRITERION WITH STABILITY         0000000
C     CONTROL.                                                          0000000
C JCOST IS THE MARKOWITZ COST OF THE BEST PIVOT SO FAR,.. THIS          0000000
C     PIVOT IS IN ROW IPIV AND COLUMN JPIV.                             0000000
          NZ2 = NZMIN                                                   0000000
          JCOST = N*N                                                   0000000
C                                                                       0000000
C EXAMINE ROWS/COLUMNS IN ORDER OF ASCENDING COUNT.                     0000000
          DO 340 L=1,2                                                  0000000
            PIVRAT = ZERO                                               0000000
            ISRCH = 1                                                   0000000
            LL = L                                                      0000000
C A PASS WITH L EQUAL TO 2 IS ONLY PERFORMED IN THE CASE OF SINGULARITY.0000000
            DO 330 NZ=NZ2,N                                             0000000
              IF (JCOST.LE.(NZ-1)**2) GO TO 420                         0000000
              IJFIR = IFIRST(NZ)                                        0000000
              IF (IJFIR) 230, 220, 240                                  0000000
  220         IF (LL.EQ.1) NZMIN = NZ + 1                               0000000
              GO TO 330                                                 0000000
  230         LL = 2                                                    0000000
              IJFIR = -IJFIR                                            0000000
              GO TO 290                                                 0000000
  240         LL = 2                                                    0000000
C SCAN ROWS WITH NZ NON-ZEROS.                                          0000000
              DO 270 IDUMMY=1,N                                         0000000
                IF (JCOST.LE.(NZ-1)**2) GO TO 420                       0000000
                IF (ISRCH.GT.MSRCH) GO TO 420                           0000000
                IF (IJFIR.EQ.0) GO TO 280                               0000000
C ROW IJFIR IS NOW EXAMINED.                                            0000000
                I = IJFIR                                               0000000
                IJFIR = NEXTR(I)                                        0000000
C FIRST CALCULATE MULTIPLIER THRESHOLD LEVEL.                           0000000
                AMAX = ZERO                                             0000000
                J1 = IPTR(I) + LENRL(I)                                 0000000
                J2 = IPTR(I) + LENR(I) - 1                              0000000
                DO 250 JJ=J1,J2                                         0000000
                  AMAX = DMAX1(AMAX,DABS(A(JJ)))                        0000000
  250           CONTINUE                                                0000000
                AU = AMAX*U                                             0000000
                ISRCH = ISRCH + 1                                       0000000
C SCAN ROW FOR POSSIBLE PIVOTS                                          0000000
                DO 260 JJ=J1,J2                                         0000000
                  IF (DABS(A(JJ)).LE.AU .AND. L.EQ.1) GO TO 260         0000000
                  J = ICN(JJ)                                           0000000
                  KCOST = (NZ-1)*(LENC(J)-1)                            0000000
                  IF (KCOST.GT.JCOST) GO TO 260                         0000000
                  PIVR = ZERO                                           0000000
                  IF (AMAX.NE.ZERO) PIVR = DABS(A(JJ))/AMAX             0000000
                  IF (KCOST.EQ.JCOST .AND. (PIVR.LE.PIVRAT .OR.         0000000
     *             NSRCH.GT.NN+1)) GO TO 260                            0000000
C BEST PIVOT SO FAR IS FOUND.                                           0000000
                  JCOST = KCOST                                         0000000
                  IJPOS = JJ                                            0000000
                  IPIV = I                                              0000000
                  JPIV = J                                              0000000
                  IF (MSRCH.GT.NN+1 .AND. JCOST.LE.(NZ-1)**2) GO TO 420 0000000
                  PIVRAT = PIVR                                         0000000
  260           CONTINUE                                                0000000
  270         CONTINUE                                                  0000000
C                                                                       0000000
C COLUMNS WITH NZ NON-ZEROS NOW EXAMINED.                               0000000
  280         IJFIR = IFIRST(NZ)                                        0000000
              IJFIR = -LASTR(IJFIR)                                     0000000
  290         IF (JCOST.LE.NZ*(NZ-1)) GO TO 420                         0000000
              IF (MSRCH.LE.NN) GO TO 330                                0000000
              DO 320 IDUMMY=1,N                                         0000000
                IF (IJFIR.EQ.0) GO TO 330                               0000000
                J = IJFIR                                               0000000
                IJFIR = NEXTC(IJFIR)                                    0000000
                I1 = IPC(J)                                             0000000
                I2 = I1 + NZ - 1                                        0000000
C SCAN COLUMN J.                                                        0000000
                DO 310 II=I1,I2                                         0000000
                  I = IRN(II)                                           0000000
                  KCOST = (NZ-1)*(LENR(I)-LENRL(I)-1)                   0000000
                  IF (KCOST.GE.JCOST) GO TO 310                         0000000
C PIVOT HAS BEST MARKOWITZ COUNT SO FAR ... NOW CHECK ITS               0000000
C     SUITABILITY ON NUMERIC GROUNDS BY EXAMINING THE OTHER NON-ZEROS   0000000
C     IN ITS ROW.                                                       0000000
                  J1 = IPTR(I) + LENRL(I)                               0000000
                  J2 = IPTR(I) + LENR(I) - 1                            0000000
C WE NEED A STABILITY CHECK ON SINGLETON COLUMNS BECAUSE OF POSSIBLE    0000000
C     PROBLEMS WITH UNDERDETERMINED SYSTEMS.                            0000000
                  AMAX = ZERO                                           0000000
                  DO 300 JJ=J1,J2                                       0000000
                    AMAX = DMAX1(AMAX,DABS(A(JJ)))                      0000000
                    IF (ICN(JJ).EQ.J) JPOS = JJ                         0000000
  300             CONTINUE                                              0000000
                  IF (DABS(A(JPOS)).LE.AMAX*U .AND. L.EQ.1) GO TO 310   0000000
                  JCOST = KCOST                                         0000000
                  IPIV = I                                              0000000
                  JPIV = J                                              0000000
                  IJPOS = JPOS                                          0000000
                  IF (AMAX.NE.ZERO) PIVRAT = DABS(A(JPOS))/AMAX         0000000
                  IF (JCOST.LE.NZ*(NZ-1)) GO TO 420                     0000000
  310           CONTINUE                                                0000000
C                                                                       0000000
  320         CONTINUE                                                  0000000
C                                                                       0000000
  330       CONTINUE                                                    0000000
C IN THE EVENT OF SINGULARITY, WE MUST MAKE SURE ALL ROWS AND COLUMNS   0000000
C ARE TESTED.                                                           0000000
            MSRCH = N                                                   0000000
C                                                                       0000000
C MATRIX IS NUMERICALLY OR STRUCTURALLY SINGULAR  ... WHICH IT IS WILL  0000000
C     BE DIAGNOSED LATER.                                               0000000
            IRANK = IRANK - 1                                           0000000
  340     CONTINUE                                                      0000000
C ASSIGN REST OF ROWS AND COLUMNS TO ORDERING ARRAY.                    0000000
C MATRIX IS STRUCTURALLY SINGULAR.                                      0000000
          IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG = 1                   0000000
          IRANK = IRANK - ILAST + PIVOT + 1                             0000000
          IF (.NOT.ABORT1) GO TO 350                                    0000000
          IDISP(2) = IACTIV                                             0000000
          IFLAG = -1                                                    0000000
          IF (LP.NE.0) WRITE (LP,99999)                                 0000000
          GO TO 1120                                                    0000000
  350     K = PIVOT - 1                                                 0000000
          DO 390 I=ISTART,ILAST                                         0000000
            IF (LASTR(I).NE.0) GO TO 390                                0000000
            K = K + 1                                                   0000000
            LASTR(I) = K                                                0000000
            IF (LENRL(I).EQ.0) GO TO 380                                0000000
            MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENRL(I))           0000000
            IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360                      0000000
            CALL MA30DD(A, ICN, IPTR(ISTART), N, IACTIV, ITOP, .TRUE.)  0000000
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.      0000000
            IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360                      0000000
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.        0000000
            MOREI = MOREI + IBEG - IDISP(1)                             0000000
            IBEG = IDISP(1)                                             0000000
            IF (LP.NE.0) WRITE (LP,99997)                               0000000
            IFLAG = -5                                                  0000000
            IF (ABORT3) GO TO 1090                                      0000000
  360       J1 = IPTR(I)                                                0000000
            J2 = J1 + LENRL(I) - 1                                      0000000
            IPTR(I) = 0                                                 0000000
            DO 370 JJ=J1,J2                                             0000000
              A(IBEG) = A(JJ)                                           0000000
              ICN(IBEG) = ICN(JJ)                                       0000000
              ICN(JJ) = 0                                               0000000
              IBEG = IBEG + 1                                           0000000
  370       CONTINUE                                                    0000000
            NZROW = NZROW - LENRL(I)                                    0000000
  380       IF (K.EQ.ILAST) GO TO 400                                   0000000
  390     CONTINUE                                                      0000000
  400     K = PIVOT - 1                                                 0000000
          DO 410 I=ISTART,ILAST                                         0000000
            IF (IPC(I).NE.0) GO TO 410                                  0000000
            K = K + 1                                                   0000000
            IPC(I) = K                                                  0000000
            IF (K.EQ.ILAST) GO TO 990                                   0000000
  410     CONTINUE                                                      0000000
C                                                                       0000000
C THE PIVOT HAS NOW BEEN FOUND IN POSITION (IPIV,JPIV) IN LOCATION      0000000
C     IJPOS IN ROW FILE.                                                0000000
C UPDATE COLUMN AND ROW ORDERING ARRAYS TO CORRESPOND WITH REMOVAL      0000000
C     OF THE ACTIVE PART OF THE MATRIX.                                 0000000
  420     ISING = PIVOT                                                 0000000
          IF (A(IJPOS).NE.ZERO) GO TO 430                               0000000
C NUMERICAL SINGULARITY IS RECORDED HERE.                               0000000
          ISING = -ISING                                                0000000
          IF (IFLAG.NE.-5) IFLAG = 2                                    0000000
          IF (.NOT.ABORT2) GO TO 430                                    0000000
          IDISP(2) = IACTIV                                             0000000
          IFLAG = -2                                                    0000000
          IF (LP.NE.0) WRITE (LP,99998)                                 0000000
          GO TO 1120                                                    0000000
  430     OLDPIV = IPTR(IPIV) + LENRL(IPIV)                             0000000
          OLDEND = IPTR(IPIV) + LENR(IPIV) - 1                          0000000
C CHANGES TO COLUMN ORDERING.                                           0000000
          IF (NSRCH.LE.NN) GO TO 460                                    0000000
          COLUPD = NN + 1
          DO 450 JJ=OLDPIV,OLDEND                                       0000000
            J = ICN(JJ)                                                 0000000
            LC = LASTC(J)                                               0000000
            NC = NEXTC(J)                                               0000000
            NEXTC(J) = -COLUPD
            IF (JJ.NE.IJPOS) COLUPD = J
            IF (NC.NE.0) LASTC(NC) = LC                                 0000000
            IF (LC.EQ.0) GO TO 440                                      0000000
            NEXTC(LC) = NC                                              0000000
            GO TO 450                                                   0000000
  440       NZ = LENC(J)                                                0000000
            ISW = IFIRST(NZ)                                            0000000
            IF (ISW.GT.0) LASTR(ISW) = -NC                              0000000
            IF (ISW.LT.0) IFIRST(NZ) = -NC                              0000000
  450     CONTINUE                                                      0000000
C CHANGES TO ROW ORDERING.                                              0000000
  460     I1 = IPC(JPIV)                                                0000000
          I2 = I1 + LENC(JPIV) - 1                                      0000000
          DO 480 II=I1,I2                                               0000000
            I = IRN(II)                                                 0000000
            LR = LASTR(I)                                               0000000
            NR = NEXTR(I)                                               0000000
            IF (NR.NE.0) LASTR(NR) = LR                                 0000000
            IF (LR.LE.0) GO TO 470                                      0000000
            NEXTR(LR) = NR                                              0000000
            GO TO 480                                                   0000000
  470       NZ = LENR(I) - LENRL(I)                                     0000000
            IF (NR.NE.0) IFIRST(NZ) = NR                                0000000
            IF (NR.EQ.0) IFIRST(NZ) = LR                                0000000
  480     CONTINUE                                                      0000000
C                                                                       0000000
C MOVE PIVOT TO POSITION LENRL+1 IN PIVOT ROW AND MOVE PIVOT ROW        0000000
C     TO THE BEGINNING OF THE AVAILABLE STORAGE.                        0000000
C THE L PART AND THE PIVOT IN THE OLD COPY OF THE PIVOT ROW IS          0000000
C     NULLIFIED WHILE, IN THE STRICTLY UPPER TRIANGULAR PART, THE       0000000
C     COLUMN INDICES, J SAY, ARE OVERWRITTEN BY THE CORRESPONDING       0000000
C     ENTRY OF IQ (IQ(J)) AND IQ(J) IS SET TO THE NEGATIVE OF THE       0000000
C     DISPLACEMENT OF THE COLUMN INDEX FROM THE PIVOT ENTRY.            0000000
          IF (OLDPIV.EQ.IJPOS) GO TO 490                                0000000
          AU = A(OLDPIV)                                                0000000
          A(OLDPIV) = A(IJPOS)                                          0000000
          A(IJPOS) = AU                                                 0000000
          ICN(IJPOS) = ICN(OLDPIV)                                      0000000
          ICN(OLDPIV) = JPIV                                            0000000
C CHECK TO SEE IF THERE IS SPACE IMMEDIATELY AVAILABLE IN A/ICN TO      0000000
C     HOLD NEW COPY OF PIVOT ROW.                                       0000000
  490     MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENR(IPIV))           0000000
          IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500                      0000000
          CALL MA30DD(A, ICN, IPTR(ISTART), N, IACTIV, ITOP, .TRUE.)    0000000
          OLDPIV = IPTR(IPIV) + LENRL(IPIV)                             0000000
          OLDEND = IPTR(IPIV) + LENR(IPIV) - 1                          0000000
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.      0000000
          IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500                      0000000
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.        0000000
          MOREI = MOREI + IBEG - IDISP(1)                               0000000
          IBEG = IDISP(1)                                               0000000
          IF (LP.NE.0) WRITE (LP,99997)                                 0000000
          IFLAG = -5                                                    0000000
          IF (ABORT3) GO TO 1090                                        0000000
          IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500                      0000000
C THERE IS STILL NOT ENOUGH ROOM IN A/ICN.                              0000000
          IFLAG = -4                                                    0000000
          GO TO 1090                                                    0000000
C COPY PIVOT ROW AND SET UP IQ ARRAY.                                   0000000
  500     IJPOS = 0                                                     0000000
          J1 = IPTR(IPIV)                                               0000000
C                                                                       0000000
          DO 530 JJ=J1,OLDEND                                           0000000
            A(IBEG) = A(JJ)                                             0000000
            ICN(IBEG) = ICN(JJ)                                         0000000
            IF (IJPOS.NE.0) GO TO 510                                   0000000
            IF (ICN(JJ).EQ.JPIV) IJPOS = IBEG                           0000000
            ICN(JJ) = 0                                                 0000000
            GO TO 520                                                   0000000
  510       K = IBEG - IJPOS                                            0000000
            J = ICN(JJ)                                                 0000000
            ICN(JJ) = IQ(J)                                             0000000
            IQ(J) = -K                                                  0000000
  520       IBEG = IBEG + 1                                             0000000
  530     CONTINUE                                                      0000000
C                                                                       0000000
          IJP1 = IJPOS + 1                                              0000000
          PIVEND = IBEG - 1                                             0000000
          LENPIV = PIVEND - IJPOS                                       0000000
          NZROW = NZROW - LENRL(IPIV) - 1                               0000000
          IPTR(IPIV) = OLDPIV + 1                                       0000000
          IF (LENPIV.EQ.0) IPTR(IPIV) = 0                               0000000
C                                                                       0000000
C REMOVE PIVOT ROW (INCLUDING PIVOT) FROM COLUMN ORIENTED FILE.         0000000
          DO 560 JJ=IJPOS,PIVEND                                        0000000
            J = ICN(JJ)                                                 0000000
            I1 = IPC(J)                                                 0000000
            LENC(J) = LENC(J) - 1                                       0000000
C I2 IS LAST POSITION IN NEW COLUMN.                                    0000000
            I2 = IPC(J) + LENC(J) - 1                                   0000000
            IF (I2.LT.I1) GO TO 550                                     0000000
            DO 540 II=I1,I2                                             0000000
              IF (IRN(II).NE.IPIV) GO TO 540                            0000000
              IRN(II) = IRN(I2+1)                                       0000000
              GO TO 550                                                 0000000
  540       CONTINUE                                                    0000000
  550       IRN(I2+1) = 0                                               0000000
  560     CONTINUE                                                      0000000
          NZCOL = NZCOL - LENPIV - 1                                    0000000
C                                                                       0000000
C GO DOWN THE PIVOT COLUMN AND FOR EACH ROW WITH A NON-ZERO ADD         0000000
C     THE APPROPRIATE MULTIPLE OF THE PIVOT ROW TO IT.                  0000000
C WE LOOP ON THE NUMBER OF NON-ZEROS IN THE PIVOT COLUMN SINCE          0000000
C     MA30D/DD MAY CHANGE ITS ACTUAL POSITION.                          0000000
C                                                                       0000000
          NZPC = LENC(JPIV)                                             0000000
          IF (NZPC.EQ.0) GO TO 900                                      0000000
          DO 840 III=1,NZPC                                             0000000
            II = IPC(JPIV) + III - 1                                    0000000
            I = IRN(II)                                                 0000000
C SEARCH ROW I FOR NON-ZERO TO BE ELIMINATED, CALCULATE MULTIPLIER,     0000000
C     AND PLACE IT IN POSITION LENRL+1 IN ITS ROW.                      0000000
C  IDROP IS THE NUMBER OF NON-ZERO ENTRIES DROPPED FROM ROW    I        0000000
C        BECAUSE THESE FALL BENEATH TOLERANCE LEVEL.                    0000000
C                                                                       0000000
            IDROP = 0                                                   0000000
            J1 = IPTR(I) + LENRL(I)                                     0000000
            IEND = IPTR(I) + LENR(I) - 1                                0000000
            DO 570 JJ=J1,IEND                                           0000000
              IF (ICN(JJ).NE.JPIV) GO TO 570                            0000000
C IF PIVOT IS ZERO, REST OF COLUMN IS AND SO MULTIPLIER IS ZERO.        0000000
              AU = ZERO                                                 0000000
              IF (A(IJPOS).NE.ZERO) AU = -A(JJ)/A(IJPOS)                0000000
              IF (LBIG) BIG = DMAX1(BIG,DABS(AU))                       0000000
              A(JJ) = A(J1)                                             0000000
              A(J1) = AU                                                0000000
              ICN(JJ) = ICN(J1)                                         0000000
              ICN(J1) = JPIV                                            0000000
              LENRL(I) = LENRL(I) + 1                                   0000000
              GO TO 580                                                 0000000
  570       CONTINUE                                                    0000000
C JUMP IF PIVOT ROW IS A SINGLETON.                                     0000000
  580       IF (LENPIV.EQ.0) GO TO 840                                  0000000
C NOW PERFORM NECESSARY OPERATIONS ON REST OF NON-PIVOT ROW I.          0000000
            ROWI = J1 + 1                                               0000000
            IOP = 0                                                     0000000
C JUMP IF ALL THE PIVOT ROW CAUSES FILL-IN.                             0000000
            IF (ROWI.GT.IEND) GO TO 650                                 0000000
C PERFORM OPERATIONS ON CURRENT NON-ZEROS IN ROW I.                     0000000
C INNERMOST LOOP.                                                       0000000
            DO 590 JJ=ROWI,IEND                                         0000000
              J = ICN(JJ)                                               0000000
              IF (IQ(J).GT.0) GO TO 590                                 0000000
              IOP = IOP + 1                                             0000000
              PIVROW = IJPOS - IQ(J)                                    0000000
              A(JJ) = A(JJ) + AU*A(PIVROW)                              0000000
              IF (LBIG) BIG = DMAX1(DABS(A(JJ)),BIG)                    0000000
              ICN(PIVROW) = -ICN(PIVROW)                                0000000
              IF (DABS(A(JJ)).LT.TOL) IDROP = IDROP + 1                 0000000
  590       CONTINUE                                                    0000000
C                                                                       0000000
C  JUMP IF NO NON-ZEROS IN NON-PIVOT ROW HAVE BEEN REMOVED              0000000
C       BECAUSE THESE ARE BENEATH THE DROP-TOLERANCE  TOL.              0000000
C                                                                       0000000
            IF (IDROP.EQ.0) GO TO 650                                   0000000
C                                                                       0000000
C  RUN THROUGH NON-PIVOT ROW COMPRESSING ROW SO THAT ONLY               0000000
C      NON-ZEROS GREATER THAN   TOL   ARE STORED.  ALL NON-ZEROS        0000000
C      LESS THAN   TOL   ARE ALSO REMOVED FROM THE COLUMN STRUCTURE.    0000000
C                                                                       0000000
            JNEW = ROWI                                                 0000000
            DO 630 JJ=ROWI,IEND                                         0000000
              IF (DABS(A(JJ)).LT.TOL) GO TO 600                         0000000
              A(JNEW) = A(JJ)                                           0000000
              ICN(JNEW) = ICN(JJ)                                       0000000
              JNEW = JNEW + 1                                           0000000
              GO TO 630                                                 0000000
C                                                                       0000000
C  REMOVE NON-ZERO ENTRY FROM COLUMN STRUCTURE.                         0000000
C                                                                       0000000
  600         J = ICN(JJ)                                               0000000
              I1 = IPC(J)                                               0000000
              I2 = I1 + LENC(J) - 1                                     0000000
              DO 610 II=I1,I2                                           0000000
                IF (IRN(II).EQ.I) GO TO 620                             0000000
  610         CONTINUE                                                  0000000
  620         IRN(II) = IRN(I2)                                         0000000
              IRN(I2) = 0                                               0000000
              LENC(J) = LENC(J) - 1                                     0000000
              IF (NSRCH.LE.NN) GO TO 630
C REMOVE COLUMN FROM COLUMN CHAIN AND PLACE IN UPDATE CHAIN.
              IF (NEXTC(J).LT.0) GO TO 630
C JUMP IF COLUMN ALREADY IN UPDATE CHAIN.
              LC = LASTC(J)                                             0000000
              NC = NEXTC(J)                                             0000000
              NEXTC(J) = -COLUPD
              COLUPD = J
              IF (NC.NE.0) LASTC(NC) = LC                               0000000
              IF (LC.EQ.0) GO TO 622                                    0000000
              NEXTC(LC) = NC                                            0000000
              GO TO 630                                                 0000000
  622         NZ = LENC(J) + 1                                          0000000
              ISW = IFIRST(NZ)                                          0000000
              IF (ISW.GT.0) LASTR(ISW) = -NC                            0000000
              IF (ISW.LT.0) IFIRST(NZ) = -NC                            0000000
  630       CONTINUE                                                    0000000
            DO 640 JJ=JNEW,IEND                                         0000000
              ICN(JJ) = 0                                               0000000
  640       CONTINUE                                                    0000000
C THE VALUE OF IDROP MIGHT BE DIFFERENT FROM THAT CALCULATED EARLIER    0000000
C     BECAUSE, WE MAY NOW HAVE DROPPED SOME NON-ZEROS WHICH WERE NOT    0000000
C     MODIFIED BY THE PIVOT ROW.                                        0000000
            IDROP = IEND + 1 - JNEW                                     0000000
            IEND = JNEW - 1                                             0000000
            LENR(I) = LENR(I) - IDROP                                   0000000
            NZROW = NZROW - IDROP                                       0000000
            NZCOL = NZCOL - IDROP                                       0000000
            NDROP = NDROP + IDROP                                       0000000
  650       IFILL = LENPIV - IOP                                        0000000
C JUMP IS IF THERE IS NO FILL-IN.                                       0000000
            IF (IFILL.EQ.0) GO TO 750                                   0000000
C NOW FOR THE FILL-IN.                                                  0000000
            MINICN = MAX0(MINICN,MOREI+IBEG-1+NZROW+IFILL+LENR(I))      0000000
C SEE IF THERE IS ROOM FOR FILL-IN.                                     0000000
C GET MAXIMUM SPACE FOR ROW I IN SITU.                                  0000000
            DO 660 JDIFF=1,IFILL                                        0000000
              JNPOS = IEND + JDIFF                                      0000000
              IF (JNPOS.GT.LICN) GO TO 670                              0000000
              IF (ICN(JNPOS).NE.0) GO TO 670                            0000000
  660       CONTINUE                                                    0000000
C THERE IS ROOM FOR ALL THE FILL-IN AFTER THE END OF THE ROW SO IT      0000000
C     CAN BE LEFT IN SITU.                                              0000000
C NEXT AVAILABLE SPACE FOR FILL-IN.                                     0000000
            IEND = IEND + 1                                             0000000
            GO TO 750                                                   0000000
C JMORE SPACES FOR FILL-IN ARE REQUIRED IN FRONT OF ROW.                0000000
  670       JMORE = IFILL - JDIFF + 1                                   0000000
            I1 = IPTR(I)                                                0000000
C WE NOW LOOK IN FRONT OF THE ROW TO SEE IF THERE IS SPACE FOR          0000000
C     THE REST OF THE FILL-IN.                                          0000000
            DO 680 JDIFF=1,JMORE                                        0000000
              JNPOS = I1 - JDIFF                                        0000000
              IF (JNPOS.LT.IACTIV) GO TO 690                            0000000
              IF (ICN(JNPOS).NE.0) GO TO 700                            0000000
  680       CONTINUE                                                    0000000
  690       JNPOS = I1 - JMORE                                          0000000
            GO TO 710                                                   0000000
C WHOLE ROW MUST BE MOVED TO THE BEGINNING OF AVAILABLE STORAGE.        0000000
  700       JNPOS = IACTIV - LENR(I) - IFILL                            0000000
C JUMP IF THERE IS SPACE IMMEDIATELY AVAILABLE FOR THE SHIFTED ROW.     0000000
  710       IF (JNPOS.GE.IBEG) GO TO 730                                0000000
            CALL MA30DD(A, ICN, IPTR(ISTART), N, IACTIV, ITOP, .TRUE.)  0000000
            I1 = IPTR(I)                                                0000000
            IEND = I1 + LENR(I) - 1                                     0000000
            JNPOS = IACTIV - LENR(I) - IFILL                            0000000
            IF (JNPOS.GE.IBEG) GO TO 730                                0000000
C NO SPACE AVAILABLE SO TRY TO CREATE SOME BY THROWING AWAY PREVIOUS    0000000
C     LU DECOMPOSITION.                                                 0000000
            MOREI = MOREI + IBEG - IDISP(1) - LENPIV - 1                0000000
            IF (LP.NE.0) WRITE (LP,99997)                               0000000
            IFLAG = -5                                                  0000000
            IF (ABORT3) GO TO 1090                                      0000000
C KEEP RECORD OF CURRENT PIVOT ROW.                                     0000000
            IBEG = IDISP(1)                                             0000000
            ICN(IBEG) = JPIV                                            0000000
            A(IBEG) = A(IJPOS)                                          0000000
            IJPOS = IBEG                                                0000000
            DO 720 JJ=IJP1,PIVEND                                       0000000
              IBEG = IBEG + 1                                           0000000
              A(IBEG) = A(JJ)                                           0000000
              ICN(IBEG) = ICN(JJ)                                       0000000
  720       CONTINUE                                                    0000000
            IJP1 = IJPOS + 1                                            0000000
            PIVEND = IBEG                                               0000000
            IBEG = IBEG + 1                                             0000000
            IF (JNPOS.GE.IBEG) GO TO 730                                0000000
C THIS STILL DOES NOT GIVE ENOUGH ROOM.                                 0000000
            IFLAG = -4                                                  0000000
            GO TO 1090                                                  0000000
  730       IACTIV = MIN0(IACTIV,JNPOS)                                 0000000
C MOVE NON-PIVOT ROW I.                                                 0000000
            IPTR(I) = JNPOS                                             0000000
            DO 740 JJ=I1,IEND                                           0000000
              A(JNPOS) = A(JJ)                                          0000000
              ICN(JNPOS) = ICN(JJ)                                      0000000
              JNPOS = JNPOS + 1                                         0000000
              ICN(JJ) = 0                                               0000000
  740       CONTINUE                                                    0000000
C FIRST NEW AVAILABLE SPACE.                                            0000000
            IEND = JNPOS                                                0000000
  750       NZROW = NZROW + IFILL                                       0000000
C INNERMOST FILL-IN LOOP WHICH ALSO RESETS ICN.                         0000000
            IDROP = 0
            DO 830 JJ=IJP1,PIVEND                                       0000000
              J = ICN(JJ)                                               0000000
              IF (J.LT.0) GO TO 820                                     0000000
              ANEW = AU*A(JJ)                                           0000000
              AANEW = DABS(ANEW)                                        0000000
              IF (AANEW.GE.TOL) GO TO 760                               0000000
              IDROP = IDROP + 1                                         0000000
              NDROP = NDROP + 1                                         0000000
              NZROW = NZROW - 1                                         0000000
              MINICN = MINICN - 1                                       0000000
              IFILL = IFILL - 1                                         0000000
              GO TO 830                                                 0000000
  760         IF (LBIG) BIG = DMAX1(AANEW,BIG)                          0000000
              A(IEND) = ANEW                                            0000000
              ICN(IEND) = J                                             0000000
              IEND = IEND + 1                                           0000000
C                                                                       0000000
C PUT NEW ENTRY IN COLUMN FILE.                                         0000000
              MINIRN = MAX0(MINIRN,NZCOL+LENC(J)+1)                     0000000
              JEND = IPC(J) + LENC(J)                                   0000000
              JROOM = NZPC - III + 1 + LENC(J)                          0000000
              IF (JEND.GT.LIRN) GO TO 770                               0000000
              IF (IRN(JEND).EQ.0) GO TO 810                             0000000
  770         IF (JROOM.LT.DISPC) GO TO 780                             0000000
C COMPRESS COLUMN FILE TO OBTAIN SPACE FOR NEW COPY OF COLUMN.          0000000
              CALL MA30DD(A, IRN, IPC(ISTART), N, DISPC, LIRN, .FALSE.) 0000000
              IF (JROOM.LT.DISPC) GO TO 780                             0000000
              JROOM = DISPC - 1                                         0000000
              IF (JROOM.GE.LENC(J)+1) GO TO 780                         0000000
C COLUMN FILE IS NOT LARGE ENOUGH.                                      0000000
              GO TO 1100                                                0000000
C COPY COLUMN TO BEGINNING OF FILE.                                     0000000
  780         JBEG = IPC(J)                                             0000000
              JEND = IPC(J) + LENC(J) - 1                               0000000
              JZERO = DISPC - 1                                         0000000
              DISPC = DISPC - JROOM                                     0000000
              IDISPC = DISPC                                            0000000
              DO 790 II=JBEG,JEND                                       0000000
                IRN(IDISPC) = IRN(II)                                   0000000
                IRN(II) = 0                                             0000000
                IDISPC = IDISPC + 1                                     0000000
  790         CONTINUE                                                  0000000
              IPC(J) = DISPC                                            0000000
              JEND = IDISPC                                             0000000
              DO 800 II=JEND,JZERO                                      0000000
                IRN(II) = 0                                             0000000
  800         CONTINUE                                                  0000000
  810         IRN(JEND) = I                                             0000000
              NZCOL = NZCOL + 1                                         0000000
              LENC(J) = LENC(J) + 1                                     0000000
C END OF ADJUSTMENT TO COLUMN FILE.                                     0000000
              GO TO 830                                                 0000000
C                                                                       0000000
  820         ICN(JJ) = -J                                              0000000
  830       CONTINUE                                                    0000000
            IF (IDROP.EQ.0) GO TO 834
            DO 832 KDROP=1,IDROP
            ICN(IEND) = 0
            IEND = IEND + 1
  832       CONTINUE
  834       LENR(I) = LENR(I) + IFILL                                   0000000
C END OF SCAN OF PIVOT COLUMN.                                          0000000
  840     CONTINUE                                                      0000000
C                                                                       0000000
C                                                                       0000000
C REMOVE PIVOT COLUMN FROM COLUMN ORIENTED STORAGE AND UPDATE ROW       0000000
C     ORDERING ARRAYS.                                                  0000000
          I1 = IPC(JPIV)                                                0000000
          I2 = IPC(JPIV) + LENC(JPIV) - 1                               0000000
          NZCOL = NZCOL - LENC(JPIV)                                    0000000
          DO 890 II=I1,I2                                               0000000
            I = IRN(II)                                                 0000000
            IRN(II) = 0                                                 0000000
            NZ = LENR(I) - LENRL(I)                                     0000000
            IF (NZ.NE.0) GO TO 850                                      0000000
            LASTR(I) = 0                                                0000000
            GO TO 890                                                   0000000
  850       IFIR = IFIRST(NZ)                                           0000000
            IFIRST(NZ) = I                                              0000000
            IF (IFIR) 860, 880, 870                                     0000000
  860       LASTR(I) = IFIR                                             0000000
            NEXTR(I) = 0                                                0000000
            GO TO 890                                                   0000000
  870       LASTR(I) = LASTR(IFIR)                                      0000000
            NEXTR(I) = IFIR                                             0000000
            LASTR(IFIR) = I                                             0000000
            GO TO 890                                                   0000000
  880       LASTR(I) = 0                                                0000000
            NEXTR(I) = 0                                                0000000
            NZMIN = MIN0(NZMIN,NZ)                                      0000000
  890     CONTINUE                                                      0000000
C RESTORE IQ AND NULLIFY U PART OF OLD PIVOT ROW.                       0000000
C    RECORD THE COLUMN PERMUTATION IN LASTC(JPIV) AND THE ROW           0000000
C    PERMUTATION IN LASTR(IPIV).                                        0000000
  900     IPC(JPIV) = -ISING                                            0000000
          LASTR(IPIV) = PIVOT                                           0000000
          IF (LENPIV.EQ.0) GO TO 980                                    0000000
          NZROW = NZROW - LENPIV                                        0000000
          JVAL = IJP1                                                   0000000
          JZER = IPTR(IPIV)                                             0000000
          IPTR(IPIV) = 0                                                0000000
          DO 910 JCOUNT=1,LENPIV                                        0000000
            J = ICN(JVAL)                                               0000000
            IQ(J) = ICN(JZER)                                           0000000
            ICN(JZER) = 0                                               0000000
            JVAL = JVAL + 1                                             0000000
            JZER = JZER + 1                                             0000000
  910     CONTINUE                                                      0000000
C ADJUST COLUMN ORDERING ARRAYS.                                        00091000
          IF (NSRCH.GT.NN) GO TO 920                                    00091010
          DO 916 JJ=IJP1,PIVEND                                         00091100
            J = ICN(JJ)                                                 00091200
            NZ = LENC(J)                                                00091300
            IF (NZ.NE.0) GO TO 914                                      00091400
            IPC(J) = 0                                                  00091500
            GO TO 916                                                   00091600
  914       NZMIN = MIN0(NZMIN,NZ)                                      00091700
  916     CONTINUE                                                      00091710
          GO TO 980
  920     JJ = COLUPD                                                   00091720
          DO 970 JDUMMY=1,NN                                            00091730
            J = JJ                                                      00091740
            IF (J.EQ.NN+1) GO TO 980                                    00091760
            JJ = -NEXTC(J)                                              00091761
            NZ = LENC(J)                                                00091770
            IF (NZ.NE.0) GO TO 924                                      00091780
            IPC(J) = 0                                                  00091790
            GO TO 970                                                   00091791
  924       IFIR = IFIRST(NZ)                                           00091800
            LASTC(J) = 0                                                00091900
            IF (IFIR) 930, 940, 950                                     00092000
  930       IFIRST(NZ) = -J                                             00092100
            IFIR = -IFIR                                                00092200
            LASTC(IFIR) = J                                             00092300
            NEXTC(J) = IFIR                                             00092400
            GO TO 970                                                   00092500
  940       IFIRST(NZ) = -J                                             00092600
            NEXTC(J) = 0                                                00092700
            GO TO 960                                                   00092800
  950       LC = -LASTR(IFIR)                                           00092900
            LASTR(IFIR) = -J                                            00093000
            NEXTC(J) = LC                                               00093100
            IF (LC.NE.0) LASTC(LC) = J                                  00093200
  960       NZMIN = MIN0(NZMIN,NZ)                                      00093300
  970     CONTINUE                                                      00093400
  980   CONTINUE                                                        0000000
C ********************************************                          0000000
C ****    END OF MAIN ELIMINATION LOOP    ****                          0000000
C ********************************************                          0000000
C                                                                       0000000
C RESET IACTIV TO POINT TO THE BEGINNING OF THE NEXT BLOCK.             0000000
  990   IF (ILAST.NE.NN) IACTIV = IPTR(ILAST+1)                         0000000
 1000 CONTINUE                                                          0000000
C                                                                       0000000
C ********************************************                          0000000
C ****    END OF DEOMPOSITION OF BLOCK    ****                          0000000
C ********************************************                          0000000
C                                                                       0000000
C RECORD SINGULARITY (IF ANY) IN IQ ARRAY.                              0000000
      IF (IRANK.EQ.NN) GO TO 1020                                       0000000
      DO 1010 I=1,NN                                                    0000000
        IF (IPC(I).LT.0) GO TO 1010                                     0000000
        ISING = IPC(I)                                                  0000000
        IQ(ISING) = -IQ(ISING)                                          0000000
        IPC(I) = -ISING                                                 0000000
 1010 CONTINUE                                                          0000000
C                                                                       0000000
C RUN THROUGH LU DECOMPOSITION CHANGING COLUMN INDICES TO THAT OF NEW   0000000
C     ORDER AND PERMUTING LENR AND LENRL ARRAYS ACCORDING TO PIVOT      0000000
C     PERMUTATIONS.                                                     0000000
 1020 ISTART = IDISP(1)                                                 0000000
      IEND = IBEG - 1                                                   0000000
      IF (IEND.LT.ISTART) GO TO 1040                                    0000000
      DO 1030 JJ=ISTART,IEND                                            0000000
        JOLD = ICN(JJ)                                                  0000000
        ICN(JJ) = -IPC(JOLD)                                            0000000
 1030 CONTINUE                                                          0000000
 1040 DO 1050 II=1,NN                                                   0000000
        I = LASTR(II)                                                   0000000
        NEXTR(I) = LENR(II)                                             0000000
        IPTR(I) = LENRL(II)                                             0000000
 1050 CONTINUE                                                          0000000
      DO 1060 I=1,NN                                                    0000000
        LENRL(I) = IPTR(I)                                              0000000
        LENR(I) = NEXTR(I)                                              0000000
 1060 CONTINUE                                                          0000000
C                                                                       0000000
C UPDATE PERMUTATION ARRAYS IP AND IQ.                                  0000000
      DO 1070 II=1,NN                                                   0000000
        I = LASTR(II)                                                   0000000
        J = -IPC(II)                                                    0000000
        NEXTR(I) = IABS(IP(II)+0)                                       0000000
        IPTR(J) = IABS(IQ(II)+0)                                        0000000
 1070 CONTINUE                                                          0000000
      DO 1080 I=1,NN                                                    0000000
        IF (IP(I).LT.0) NEXTR(I) = -NEXTR(I)                            0000000
        IP(I) = NEXTR(I)                                                0000000
        IF (IQ(I).LT.0) IPTR(I) = -IPTR(I)                              0000000
        IQ(I) = IPTR(I)                                                 0000000
 1080 CONTINUE                                                          0000000
      IP(NN) = IABS(IP(NN)+0)                                           0000000
      IDISP(2) = IEND                                                   0000000
      GO TO 1120                                                        0000000
C                                                                       0000000
C   ***    ERROR RETURNS    ***                                         0000000
 1090 IDISP(2) = IACTIV                                                 0000000
      IF (LP.EQ.0) GO TO 1120                                           0000000
      WRITE (LP,99996)                                                  0000000
      GO TO 1110                                                        0000000
 1100 IF (IFLAG.EQ.-5) IFLAG = -6                                       0000000
      IF (IFLAG.NE.-6) IFLAG = -3                                       0000000
      IDISP(2) = IACTIV                                                 0000000
      IF (LP.EQ.0) GO TO 1120                                           0000000
      IF (IFLAG.EQ.-3) WRITE (LP,99995)                                 0000000
      IF (IFLAG.EQ.-6) WRITE (LP,99994)                                 0000000
 1110 PIVOT = PIVOT - ISTART + 1                                        0000000
      WRITE (LP,99993) PIVOT, NBLOCK, ISTART, ILAST                     0000000
      IF (PIVOT.EQ.0) WRITE (LP,99992) MINIRN                           0000000
C                                                                       0000000
C                                                                       0000000
 1120 RETURN                                                            0000000
99999 FORMAT (54H ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS STRUCTUR,0000000
     * 13HALLY SINGULAR)                                                0000000
99998 FORMAT (54H ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS NUMERICA,0000000
     * 12HLLY SINGULAR)                                                 0000000
99997 FORMAT (48H LU DECOMPOSITION DESTROYED TO CREATE MORE SPACE)      0000000
99996 FORMAT (54H ERROR RETURN FROM MA30A/AD BECAUSE LICN NOT BIG ENOUG,0000000
     * 1HH)                                                             0000000
99995 FORMAT (54H ERROR RETURN FROM MA30A/AD BECAUSE LIRN NOT BIG ENOUG,0000000
     * 1HH)                                                             0000000
99994 FORMAT (51H ERROR RETURN FROM MA30A/AD LIRN AND LICN TOO SMALL)   0000000
99993 FORMAT (10H AT STAGE , I5, 10H IN BLOCK , I5, 16H WITH FIRST ROW ,0000000
     * I5, 14H AND LAST ROW , I5)                                       0000000
99992 FORMAT (34H TO CONTINUE SET LIRN TO AT LEAST , I8)                0000000
      END                                                               0000000
      SUBROUTINE MA30DD(A, ICN, IPTR, N, IACTIV, ITOP, REALS)           0000000
C THIS SUBROUTINE PERFORMS GARBAGE COLLECTION OPERATIONS ON THE         0000000
C     ARRAYS A, ICN AND IRN.                                            0000000
C IACTIV IS THE FIRST POSITION IN ARRAYS A/ICN FROM WHICH THE COMPRESS  0000000
C     STARTS.  ON EXIT, IACTIV EQUALS THE POSITION OF THE FIRST ENTRY   0000000
C     IN THE COMPRESSED PART OF A/ICN                                   0000000
C                                                                       0000000
      DOUBLE PRECISION A(ITOP)                                          0000000
      LOGICAL REALS                                                     0000000
      INTEGER IPTR(N)                                                   0000000
      INTEGER ICN(ITOP)                                                 0000000
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
      COMMON /MA30FD/ IRNCP, ICNCP, IRANK, MINIRN, MINICN               0000000
C                                                                       0000000
      IF (REALS) ICNCP = ICNCP + 1                                      0000000
      IF (.NOT.REALS) IRNCP = IRNCP + 1                                 0000000
C SET THE FIRST NON-ZERO ENTRY IN EACH ROW TO THE NEGATIVE OF THE       0000000
C     ROW/COL NUMBER AND HOLD THIS ROW/COL INDEX IN THE ROW/COL         0000000
C     POINTER.  THIS IS SO THAT THE BEGINNING OF EACH ROW/COL CAN       0000000
C     BE RECOGNIZED IN THE SUBSEQUENT SCAN.                             0000000
      DO 10 J=1,N                                                       0000000
        K = IPTR(J)                                                     0000000
        IF (K.LT.IACTIV) GO TO 10                                       0000000
        IPTR(J) = ICN(K)                                                0000000
        ICN(K) = -J                                                     0000000
   10 CONTINUE                                                          0000000
      KN = ITOP + 1                                                     0000000
      KL = ITOP - IACTIV + 1                                            0000000
C GO THROUGH ARRAYS IN REVERSE ORDER COMPRESSING TO THE BACK SO         0000000
C     THAT THERE ARE NO ZEROS HELD IN POSITIONS IACTIV TO ITOP IN ICN.  0000000
C     RESET FIRST ENTRY OF EACH ROW/COL AND POINTER ARRAY IPTR.         0000000
      DO 30 K=1,KL                                                      0000000
        JPOS = ITOP - K + 1                                             0000000
        IF (ICN(JPOS).EQ.0) GO TO 30                                    0000000
        KN = KN - 1                                                     0000000
        IF (REALS) A(KN) = A(JPOS)                                      0000000
        IF (ICN(JPOS).GE.0) GO TO 20                                    0000000
C FIRST NON-ZERO OF ROW/COL HAS BEEN LOCATED                            0000000
        J = -ICN(JPOS)                                                  0000000
        ICN(JPOS) = IPTR(J)                                             0000000
        IPTR(J) = KN                                                    0000000
   20   ICN(KN) = ICN(JPOS)                                             0000000
   30 CONTINUE                                                          0000000
      IACTIV = KN                                                       0000000
      RETURN                                                            0000000
      END                                                               0000000
      SUBROUTINE MA30BD(N, ICN, A, LICN, LENR, LENRL, IDISP, IP, IQ, W, 0000000
     * IW, IFLAG)                                                       0000000
C MA30B/BD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF A    0000000
C     NEW MATRIX PAQ OF THE SAME SPARSITY PATTERN, USING INFORMATION    0000000
C     FROM A PREVIOUS CALL TO MA30A/AD. THE ENTRIES OF THE INPUT        0000000
C     MATRIX  MUST ALREADY BE IN THEIR FINAL POSITIONS IN THE LU        0000000
C     DECOMPOSITION STRUCTURE.  THIS ROUTINE EXECUTES ABOUT FIVE TIMES  0000000
C     FASTER THAN MA30A/AD.                                             0000000
C                                                                       0000000
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30B/BD. CONSULT MA30A/AD FOR  0000000
C     FURTHER INFORMATION ON THESE PARAMETERS.                          0000000
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX.             0000000
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. IT SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.   0000000
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN THE USER MUST SET  0000000
C     ENTRIES IDISP(1) TO IDISP(2) TO CONTAIN THE ENTRIES IN THE        0000000
C     DIAGONAL BLOCKS OF THE MATRIX PAQ WHOSE COLUMN NUMBERS ARE HELD   0000000
C     IN ICN, USING CORRESPONDING POSITIONS. NOTE THAT SOME ZEROS MAY   0000000
C     NEED TO BE HELD EXPLICITLY. ON OUTPUT ENTRIES IDISP(1) TO         0000000
C     IDISP(2) OF ARRAY A CONTAIN THE LU DECOMPOSITION OF THE DIAGONAL  0000000
C     BLOCKS OF PAQ. ENTRIES A(1) TO A(IDISP(1)-1) ARE NEITHER          0000000
C     REQUIRED NOR ALTERED BY MA30B/BD.                                 0000000
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE     0000000
C     LENGTH OF ARRAYS A AND ICN. IT IS NOT ALTERED BY MA30B/BD.        0000000
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED   0000000
C     BY MA30B/BD.                                                      0000000
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. IT SHOULD BE UNCHANGED SINCE  0000000
C     THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.         0000000
C IP,IQ  ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY          0000000
C     MA30B/BD.                                                         0000000
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS      0000000
C     WORKSPACE BY MA30B/BD.                                            0000000
C IW  IS AN INTEGER ARRAY OF LENGTH N WHICH IS USED AS WORKSPACE BY     0000000
C     MA30B/BD.                                                         0000000
C IFLAG  IS AN INTEGER VARIABLE. ON OUTPUT FROM MA30B/BD, IFLAG HAS     0000000
C     THE VALUE ZERO IF THE FACTORIZATION WAS SUCCESSFUL, HAS THE       0000000
C     VALUE I IF PIVOT I WAS VERY SMALL AND HAS THE VALUE -I IF AN      0000000
C     UNEXPECTED SINGULARITY WAS DETECTED AT STAGE I OF THE             0000000
C     DECOMPOSITION.                                                    0000000
C                                                                       0000000
      DOUBLE PRECISION A(LICN), W(N), AU, EPS, ROWMAX, ZERO, ONE, RMIN, 0000000
     * TOL, BIG                                                         0000000
      LOGICAL ABORT1, ABORT2, ABORT3, STAB, LBIG                        0000000
      INTEGER IW(N), IDISP(2), PIVPOS                                   0000000
      INTEGER ICN(LICN), LENR(N), LENRL(N), IP(N), IQ(N)                0000000
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
      COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3                        0000000
      COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG                      0000000
      COMMON /MA30GD/ EPS, RMIN                                         0000000
      DATA ZERO /0.0D0/, ONE /1.0D0/                                    0000000
      STAB = EPS.LE.ONE                                                 0000000
      RMIN = EPS                                                        0000000
      ISING = 0                                                         0000000
      IFLAG = 0                                                         0000000
      DO 10 I=1,N                                                       0000000
        W(I) = ZERO                                                     0000000
   10 CONTINUE                                                          0000000
C SET UP POINTERS TO THE BEGINNING OF THE ROWS.                         0000000
      IW(1) = IDISP(1)                                                  0000000
      IF (N.EQ.1) GO TO 25                                              0000000
      DO 20 I=2,N                                                       0000000
        IW(I) = IW(I-1) + LENR(I-1)                                     0000000
   20 CONTINUE                                                          0000000
C                                                                       0000000
C   ****   START  OF MAIN LOOP    ****                                  0000000
C AT STEP I, ROW I OF A IS TRANSFORMED TO ROW I OF L/U BY ADDING        0000000
C     APPROPRIATE MULTIPLES OF ROWS 1 TO I-1.                           0000000
C     .... USING ROW-GAUSS ELIMINATION.                                 0000000
   25 DO 160 I=1,N                                                      0000000
C ISTART IS BEGINNING OF ROW I OF A AND ROW I OF L.                     0000000
        ISTART = IW(I)                                                  0000000
C IFIN IS END OF ROW I OF A AND ROW I OF U.                             0000000
        IFIN = ISTART + LENR(I) - 1                                     0000000
C ILEND IS END OF ROW I OF L.                                           0000000
        ILEND = ISTART + LENRL(I) - 1                                   0000000
        IF (ISTART.GT.ILEND) GO TO 90                                   0000000
C LOAD ROW I OF A INTO VECTOR W.                                        0000000
        DO 30 JJ=ISTART,IFIN                                            0000000
          J = ICN(JJ)                                                   0000000
          W(J) = A(JJ)                                                  0000000
   30   CONTINUE                                                        0000000
C                                                                       0000000
C ADD MULTIPLES OF APPROPRIATE ROWS OF  I TO I-1  TO ROW I.             0000000
        DO 70 JJ=ISTART,ILEND                                           0000000
          J = ICN(JJ)                                                   0000000
C IPIVJ IS POSITION OF PIVOT IN ROW J.                                  0000000
          IPIVJ = IW(J) + LENRL(J)                                      0000000
C FORM MULTIPLIER AU.                                                   0000000
          AU = -W(J)/A(IPIVJ)                                           0000000
          IF (LBIG) BIG = DMAX1(DABS(AU),BIG)                           0000000
          W(J) = AU                                                     0000000
C AU * ROW J (U PART) IS ADDED TO ROW I.                                0000000
          IPIVJ = IPIVJ + 1                                             0000000
          JFIN = IW(J) + LENR(J) - 1                                    0000000
          IF (IPIVJ.GT.JFIN) GO TO 70                                   0000000
C INNERMOST LOOP.                                                       0000000
          IF (LBIG) GO TO 50                                            0000000
          DO 40 JAYJAY=IPIVJ,JFIN                                       0000000
            JAY = ICN(JAYJAY)                                           0000000
            W(JAY) = W(JAY) + AU*A(JAYJAY)                              0000000
   40     CONTINUE                                                      0000000
          GO TO 70                                                      0000000
   50     DO 60 JAYJAY=IPIVJ,JFIN                                       0000000
            JAY = ICN(JAYJAY)                                           0000000
            W(JAY) = W(JAY) + AU*A(JAYJAY)                              0000000
            BIG = DMAX1(DABS(W(JAY)),BIG)                               0000000
   60     CONTINUE                                                      0000000
   70   CONTINUE                                                        0000000
C                                                                       0000000
C RELOAD W BACK INTO A (NOW L/U)                                        0000000
        DO 80 JJ=ISTART,IFIN                                            0000000
          J = ICN(JJ)                                                   0000000
          A(JJ) = W(J)                                                  0000000
          W(J) = ZERO                                                   0000000
   80   CONTINUE                                                        0000000
C WE NOW PERFORM THE STABILITY CHECKS.                                  0000000
   90   PIVPOS = ILEND + 1                                              0000000
        IF (IQ(I).GT.0) GO TO 140                                       0000000
C MATRIX HAD SINGULARITY AT THIS POINT IN MA30A/AD.                     0000000
C IS IT THE FIRST SUCH PIVOT IN CURRENT BLOCK ?                         0000000
        IF (ISING.EQ.0) ISING = I                                       0000000
C DOES CURRENT MATRIX HAVE A SINGULARITY IN THE SAME PLACE ?            0000000
        IF (PIVPOS.GT.IFIN) GO TO 100                                   0000000
        IF (A(PIVPOS).NE.ZERO) GO TO 170                                0000000
C IT DOES .. SO SET ISING IF IT IS NOT THE END OF THE CURRENT BLOCK     0000000
C CHECK TO SEE THAT APPROPRIATE PART OF L/U IS ZERO OR NULL.            0000000
  100   IF (ISTART.GT.IFIN) GO TO 120                                   0000000
        DO 110 JJ=ISTART,IFIN                                           0000000
          IF (ICN(JJ).LT.ISING) GO TO 110                               0000000
          IF (A(JJ).NE.ZERO) GO TO 170                                  0000000
  110   CONTINUE                                                        0000000
  120   IF (PIVPOS.LE.IFIN) A(PIVPOS) = ONE                             0000000
        IF (IP(I).GT.0 .AND. I.NE.N) GO TO 160                          0000000
C END OF CURRENT BLOCK ... RESET ZERO PIVOTS AND ISING.                 0000000
        DO 130 J=ISING,I                                                0000000
          IF ((LENR(J)-LENRL(J)).EQ.0) GO TO 130                        0000000
          JJ = IW(J) + LENRL(J)                                         0000000
          A(JJ) = ZERO                                                  0000000
  130   CONTINUE                                                        0000000
        ISING = 0                                                       0000000
        GO TO 160                                                       0000000
C MATRIX HAD NON-ZERO PIVOT IN MA30A/AD AT THIS STAGE.                  0000000
  140   IF (PIVPOS.GT.IFIN) GO TO 170                                   0000000
        IF (A(PIVPOS).EQ.ZERO) GO TO 170                                0000000
        IF (.NOT.STAB) GO TO 160                                        0000000
        ROWMAX = ZERO                                                   0000000
        DO 150 JJ=PIVPOS,IFIN                                           0000000
          ROWMAX = DMAX1(ROWMAX,DABS(A(JJ)))                            0000000
  150   CONTINUE                                                        0000000
        IF (DABS(A(PIVPOS))/ROWMAX.GE.RMIN) GO TO 160                   0000000
        IFLAG = I                                                       0000000
        RMIN = DABS(A(PIVPOS))/ROWMAX                                   0000000
C   ****    END OF MAIN LOOP    ****                                    0000000
  160 CONTINUE                                                          0000000
C                                                                       0000000
      GO TO 180                                                         0000000
C   ***   ERROR RETURN   ***                                            0000000
  170 IF (LP.NE.0) WRITE (LP,99999) I                                   0000000
      IFLAG = -I                                                        0000000
C                                                                       0000000
  180 RETURN                                                            0000000
99999 FORMAT (54H ERROR RETURN FROM MA30B/BD SINGULARITY DETECTED IN RO,0000000
     * 1HW, I8)                                                         0000000
      END                                                               0000000
      SUBROUTINE MA30CD(N, ICN, A, LICN, LENR, LENRL, LENOFF, IDISP, IP,0000000
     * IQ, X, W, MTYPE)                                                 0000000
C MA30C/CD USES THE FACTORS PRODUCED BY MA30A/AD OR MA30B/BD TO SOLVE   0000000
C     AX=B OR A TRANSPOSE X=B WHEN THE MATRIX P1*A*Q1 (PAQ) IS BLOCK    0000000
C     LOWER TRIANGULAR (INCLUDING THE CASE OF ONLY ONE DIAGONAL         0000000
C     BLOCK).                                                           0000000
C                                                                       0000000
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30C/CD.                       0000000
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX. IT IS NOT   0000000
C     ALTERED BY THE SUBROUTINE.                                        0000000
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. ENTRIES IDISP(1) TO
C     IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO MA30A/AD. IF  0000000
C     THE MATRIX HAS MORE THAN ONE DIAGONAL BLOCK, THEN COLUMN INDICES  0000000
C     CORRESPONDING TO NON-ZEROS IN SUB-DIAGONAL BLOCKS OF PAQ MUST     0000000
C     APPEAR IN POSITIONS 1 TO IDISP(1)-1. FOR THE SAME ROW THOSE       0000000
C     ENTRIES MUST BE CONTIGUOUS, WITH THOSE IN ROW I PRECEDING THOSE   0000000
C     IN ROW I+1 (I=1,...,N-1) AND NO WASTED SPACE BETWEEN ROWS.        0000000
C     ENTRIES MAY BE IN ANY ORDER WITHIN EACH ROW. IT IS NOT ALTERED    0000000
C     BY MA30C/CD.                                                      0000000
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN.  ENTRIES          0000000
C     IDISP(1) TO IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO   0000000
C     MA30A/AD OR MA30B/BD.  IF THE MATRIX HAS MORE THAN ONE DIAGONAL   0000000
C     BLOCK, THEN THE VALUES OF THE NON-ZEROS IN SUB-DIAGONAL BLOCKS    0000000
C     MUST BE IN POSITIONS 1 TO IDISP(1)-1 IN THE ORDER GIVEN BY ICN.   0000000
C     IT IS NOT ALTERED BY MA30C/CD.                                    0000000
C LICN  IS AN INTEGER VARIABLE SET TO THE SIZE OF ARRAYS ICN AND A.     0000000
C     IT IS NOT ALTERED BY MA30C/CD.                                    0000000
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED   0000000
C     BY MA30C/CD.                                                      0000000
C LENOFF  IS AN INTEGER ARRAY OF LENGTH N. IF THE MATRIX PAQ (OR
C     P1*A*Q1) HAS MORE THAN ONE DIAGONAL BLOCK, THEN LENOFF(I),        0000000
C     I=1,...,N SHOULD BE SET TO THE NUMBER OF NON-ZEROS IN ROW I OF    0000000
C     THE MATRIX PAQ WHICH ARE IN SUB-DIAGONAL BLOCKS.  IF THERE IS     0000000
C     ONLY ONE DIAGONAL BLOCK THEN LENOFF(1) MAY BE SET TO -1, IN       0000000
C     WHICH CASE THE OTHER ENTRIES OF LENOFF ARE NEVER ACCESSED. IT IS  0000000
C     NOT ALTERED BY MA30C/CD.                                          0000000
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2 WHICH SHOULD BE UNCHANGED      0000000
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30C/CD.   0000000
C IP,IQ ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY          0000000
C     MA30C/CD.                                                         0000000
C X IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N. IT MUST BE SET BY     0000000
C     THE USER TO THE VALUES OF THE RIGHT HAND SIDE VECTOR B FOR THE    0000000
C     EQUATIONS BEING SOLVED.  ON EXIT FROM MA30C/CD IT WILL BE EQUAL   0000000
C     TO THE SOLUTION X REQUIRED.                                       0000000
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS      0000000
C     WORKSPACE BY MA30C/CD.                                            0000000
C MTYPE IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER. IF        0000000
C     MTYPE=1, THEN THE SOLUTION TO THE SYSTEM AX=B IS RETURNED; ANY    0000000
C     OTHER VALUE FOR MTYPE WILL RETURN THE SOLUTION TO THE SYSTEM A    0000000
C     TRANSPOSE X=B. IT IS NOT ALTERED BY MA30C/CD.                     0000000
C                                                                       0000000
      DOUBLE PRECISION A(LICN), X(N), W(N), WII, WI, RESID, ZERO        0000000
      LOGICAL NEG, NOBLOC                                               0000000
      INTEGER IDISP(2)                                                  0000000
      INTEGER ICN(LICN), LENR(N), LENRL(N), LENOFF(N), IP(N), IQ(N)     0000000
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
      COMMON /MA30HD/ RESID                                             0000000
      DATA ZERO /0.0D0/                                                 0000000
C                                                                       0000000
C THE FINAL VALUE OF RESID IS THE MAXIMUM RESIDUAL FOR AN INCONSISTENT  0000000
C     SET OF EQUATIONS.                                                 0000000
      RESID = ZERO                                                      0000000
C NOBLOC IS .TRUE. IF SUBROUTINE BLOCK HAS BEEN USED PREVIOUSLY AND     0000000
C     IS .FALSE. OTHERWISE.  THE VALUE .FALSE. MEANS THAT LENOFF        0000000
C     WILL NOT BE SUBSEQUENTLY ACCESSED.                                0000000
      NOBLOC = LENOFF(1).LT.0                                           0000000
      IF (MTYPE.NE.1) GO TO 140                                         0000000
C                                                                       0000000
C WE NOW SOLVE   A * X = B.                                             0000000
C NEG IS USED TO INDICATE WHEN THE LAST ROW IN A BLOCK HAS BEEN         0000000
C     REACHED.  IT IS THEN SET TO TRUE WHEREAFTER BACKSUBSTITUTION IS   0000000
C     PERFORMED ON THE BLOCK.                                           0000000
      NEG = .FALSE.                                                     0000000
C IP(N) IS NEGATED SO THAT THE LAST ROW OF THE LAST BLOCK CAN BE        0000000
C     RECOGNISED.  IT IS RESET TO ITS POSITIVE VALUE ON EXIT.           0000000
      IP(N) = -IP(N)                                                    0000000
C PREORDER VECTOR ... W(I) = X(IP(I))                                   0000000
      DO 10 II=1,N                                                      0000000
        I = IP(II)                                                      0000000
        I = IABS(I)                                                     0000000
        W(II) = X(I)                                                    0000000
   10 CONTINUE                                                          0000000
C LT HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW OF THE 0000000
C     OFF-DIAGONAL BLOCKS.                                              0000000
      LT = 1                                                            0000000
C IFIRST HOLDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.         0000000
      IFIRST = 1                                                        0000000
C IBLOCK HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW    0000000
C     OF THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS.                   0000000
      IBLOCK = IDISP(1)                                                 0000000
C IF I IS NOT THE LAST ROW OF A BLOCK, THEN A PASS THROUGH THIS LOOP    0000000
C     ADDS THE INNER PRODUCT OF ROW I OF THE OFF-DIAGONAL BLOCKS AND W  0000000
C     TO W AND PERFORMS FORWARD ELIMINATION USING ROW I OF THE LU       0000000
C     DECOMPOSITION.   IF I IS THE LAST ROW OF A BLOCK THEN, AFTER      0000000
C     PERFORMING THESE AFOREMENTIONED OPERATIONS, BACKSUBSTITUTION IS   0000000
C     PERFORMED USING THE ROWS OF THE BLOCK.                            0000000
      DO 120 I=1,N                                                      0000000
        WI = W(I)                                                       0000000
        IF (NOBLOC) GO TO 30                                            0000000
        IF (LENOFF(I).EQ.0) GO TO 30                                    0000000
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.                             0000000
C LTEND IS THE END OF ROW I IN THE OFF-DIAGONAL BLOCKS.                 0000000
        LTEND = LT + LENOFF(I) - 1                                      0000000
        DO 20 JJ=LT,LTEND                                               0000000
          J = ICN(JJ)                                                   0000000
          WI = WI - A(JJ)*W(J)                                          0000000
   20   CONTINUE                                                        0000000
C LT IS SET THE BEGINNING OF THE NEXT OFF-DIAGONAL ROW.                 0000000
        LT = LTEND + 1                                                  0000000
C SET NEG TO .TRUE. IF WE ARE ON THE LAST ROW OF THE BLOCK.             0000000
   30   IF (IP(I).LT.0) NEG = .TRUE.                                    0000000
        IF (LENRL(I).EQ.0) GO TO 50                                     0000000
C FORWARD ELIMINATION PHASE.                                            0000000
C IEND IS THE END OF THE L PART OF ROW I IN THE LU DECOMPOSITION.       0000000
        IEND = IBLOCK + LENRL(I) - 1                                    0000000
        DO 40 JJ=IBLOCK,IEND                                            0000000
          J = ICN(JJ)                                                   0000000
          WI = WI + A(JJ)*W(J)                                          0000000
   40   CONTINUE                                                        0000000
C IBLOCK IS ADJUSTED TO POINT TO THE START OF THE NEXT ROW.             0000000
   50   IBLOCK = IBLOCK + LENR(I)                                       0000000
        W(I) = WI                                                       0000000
        IF (.NOT.NEG) GO TO 120                                         0000000
C BACK SUBSTITUTION PHASE.                                              0000000
C J1 IS POSITION IN A/ICN AFTER END OF BLOCK BEGINNING IN ROW IFIRST    0000000
C     AND ENDING IN ROW I.                                              0000000
        J1 = IBLOCK                                                     0000000
C ARE THERE ANY SINGULARITIES IN THIS BLOCK?  IF NOT, CONTINUE WITH     0000000
C     THE BACKSUBSTITUTION.                                             0000000
        IB = I                                                          0000000
        IF (IQ(I).GT.0) GO TO 70                                        0000000
        DO 60 III=IFIRST,I                                              0000000
          IB = I - III + IFIRST                                         0000000
          IF (IQ(IB).GT.0) GO TO 70                                     0000000
          J1 = J1 - LENR(IB)                                            0000000
          RESID = DMAX1(RESID,DABS(W(IB)))                              0000000
          W(IB) = ZERO                                                  0000000
   60   CONTINUE                                                        0000000
C ENTIRE BLOCK IS SINGULAR.                                             0000000
        GO TO 110                                                       0000000
C EACH PASS THROUGH THIS LOOP PERFORMS THE BACK-SUBSTITUTION            0000000
C     OPERATIONS FOR A SINGLE ROW, STARTING AT THE END OF THE BLOCK AND 0000000
C     WORKING THROUGH IT IN REVERSE ORDER.                              0000000
   70   DO 100 III=IFIRST,IB                                            0000000
          II = IB - III + IFIRST                                        0000000
C J2 IS END OF ROW II.                                                  0000000
          J2 = J1 - 1                                                   0000000
C J1 IS BEGINNING OF ROW II.                                            0000000
          J1 = J1 - LENR(II)                                            0000000
C JPIV IS THE POSITION OF THE PIVOT IN ROW II.                          0000000
          JPIV = J1 + LENRL(II)                                         0000000
          JPIVP1 = JPIV + 1                                             0000000
C JUMP IF ROW  II OF U HAS NO NON-ZEROS.                                0000000
          IF (J2.LT.JPIVP1) GO TO 90                                    0000000
          WII = W(II)                                                   0000000
          DO 80 JJ=JPIVP1,J2                                            0000000
            J = ICN(JJ)                                                 0000000
            WII = WII - A(JJ)*W(J)                                      0000000
   80     CONTINUE                                                      0000000
          W(II) = WII                                                   0000000
   90     W(II) = W(II)/A(JPIV)                                         0000000
  100   CONTINUE                                                        0000000
  110   IFIRST = I + 1                                                  0000000
        NEG = .FALSE.                                                   0000000
  120 CONTINUE                                                          0000000
C                                                                       0000000
C REORDER SOLUTION VECTOR ... X(I) = W(IQINVERSE(I))                    0000000
      DO 130 II=1,N                                                     0000000
        I = IQ(II)                                                      0000000
        I = IABS(I)                                                     0000000
        X(I) = W(II)                                                    0000000
  130 CONTINUE                                                          0000000
      IP(N) = -IP(N)                                                    0000000
      GO TO 320                                                         0000000
C                                                                       0000000
C                                                                       0000000
C WE NOW SOLVE   ATRANSPOSE * X = B.                                    0000000
C PREORDER VECTOR ... W(I)=X(IQ(I))                                     0000000
  140 DO 150 II=1,N                                                     0000000
        I = IQ(II)                                                      0000000
        I = IABS(I)                                                     0000000
        W(II) = X(I)                                                    0000000
  150 CONTINUE                                                          0000000
C LJ1 POINTS TO THE BEGINNING THE CURRENT ROW IN THE OFF-DIAGONAL       0000000
C     BLOCKS.                                                           0000000
      LJ1 = IDISP(1)                                                    0000000
C IBLOCK IS INITIALIZED TO POINT TO THE BEGINNING OF THE BLOCK AFTER    0000000
C     THE LAST ONE !                                                    0000000
      IBLOCK = IDISP(2) + 1                                             0000000
C ILAST IS THE LAST ROW IN THE CURRENT BLOCK.                           0000000
      ILAST = N                                                         0000000
C IBLEND POINTS TO THE POSITION AFTER THE LAST NON-ZERO IN THE          0000000
C     CURRENT BLOCK.                                                    0000000
      IBLEND = IBLOCK                                                   0000000
C EACH PASS THROUGH THIS LOOP OPERATES WITH ONE DIAGONAL BLOCK AND      0000000
C     THE OFF-DIAGONAL PART OF THE MATRIX CORRESPONDING TO THE ROWS     0000000
C     OF THIS BLOCK.  THE BLOCKS ARE TAKEN IN REVERSE ORDER AND THE     0000000
C     NUMBER OF TIMES THE LOOP IS ENTERED IS MIN(N,NO. BLOCKS+1).       0000000
      DO 290 NUMBLK=1,N                                                 0000000
        IF (ILAST.EQ.0) GO TO 300                                       0000000
        IBLOCK = IBLOCK - LENR(ILAST)                                   0000000
C THIS LOOP FINDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK..     0000000
C     IT IS FIRST AND IBLOCK IS SET TO THE POSITION OF THE BEGINNING    0000000
C     OF THIS FIRST ROW.                                                0000000
        DO 160 K=1,N                                                    0000000
          II = ILAST - K                                                0000000
          IF (II.EQ.0) GO TO 170                                        0000000
          IF (IP(II).LT.0) GO TO 170                                    0000000
          IBLOCK = IBLOCK - LENR(II)                                    0000000
  160   CONTINUE                                                        0000000
  170   IFIRST = II + 1                                                 0000000
C J1 POINTS TO THE POSITION OF THE BEGINNING OF ROW I (LT PART) OR PIVOT0000000
        J1 = IBLOCK                                                     0000000
C FORWARD ELIMINATION.                                                  0000000
C EACH PASS THROUGH THIS LOOP PERFORMS THE OPERATIONS FOR ONE ROW OF THE0000000
C     BLOCK.  IF THE CORRESPONDING ENTRY OF W IS ZERO THEN THE          0000000
C     OPERATIONS CAN BE AVOIDED.                                        0000000
        DO 210 I=IFIRST,ILAST                                           0000000
          IF (W(I).EQ.ZERO) GO TO 200                                   0000000
C JUMP IF ROW I SINGULAR.                                               0000000
          IF (IQ(I).LT.0) GO TO 220                                     0000000
C J2 FIRST POINTS TO THE PIVOT IN ROW I AND THEN IS MADE TO POINT TO THE0000000
C     FIRST NON-ZERO IN THE U TRANSPOSE PART OF THE ROW.                0000000
          J2 = J1 + LENRL(I)                                            0000000
          WI = W(I)/A(J2)                                               0000000
          IF (LENR(I)-LENRL(I).EQ.1) GO TO 190                          0000000
          J2 = J2 + 1                                                   0000000
C J3 POINTS TO THE END OF ROW I.                                        0000000
          J3 = J1 + LENR(I) - 1                                         0000000
          DO 180 JJ=J2,J3                                               0000000
            J = ICN(JJ)                                                 0000000
            W(J) = W(J) - A(JJ)*WI                                      0000000
  180     CONTINUE                                                      0000000
  190     W(I) = WI                                                     0000000
  200     J1 = J1 + LENR(I)                                             0000000
  210   CONTINUE                                                        0000000
        GO TO 240                                                       0000000
C DEALS WITH REST OF BLOCK WHICH IS SINGULAR.                           0000000
  220   DO 230 II=I,ILAST                                               0000000
          RESID = DMAX1(RESID,DABS(W(II)))                              0000000
          W(II) = ZERO                                                  0000000
  230   CONTINUE                                                        0000000
C BACK SUBSTITUTION.                                                    0000000
C THIS LOOP DOES THE BACK SUBSTITUTION ON THE ROWS OF THE BLOCK IN      0000000
C     THE REVERSE ORDER DOING IT SIMULTANEOUSLY ON THE L TRANSPOSE PART 0000000
C     OF THE DIAGONAL BLOCKS AND THE OFF-DIAGONAL BLOCKS.               0000000
  240   J1 = IBLEND                                                     0000000
        DO 280 IBACK=IFIRST,ILAST                                       0000000
          I = ILAST - IBACK + IFIRST                                    0000000
C J1 POINTS TO THE BEGINNING OF ROW I.                                  0000000
          J1 = J1 - LENR(I)                                             0000000
          IF (LENRL(I).EQ.0) GO TO 260                                  0000000
C J2 POINTS TO THE END OF THE L TRANSPOSE PART OF ROW I.                0000000
          J2 = J1 + LENRL(I) - 1                                        0000000
          DO 250 JJ=J1,J2                                               0000000
            J = ICN(JJ)                                                 0000000
            W(J) = W(J) + A(JJ)*W(I)                                    0000000
  250     CONTINUE                                                      0000000
  260     IF (NOBLOC) GO TO 280                                         0000000
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.                             0000000
          IF (LENOFF(I).EQ.0) GO TO 280                                 0000000
C LJ2 POINTS TO THE END OF ROW I OF THE OFF-DIAGONAL BLOCKS.            0000000
          LJ2 = LJ1 - 1                                                 0000000
C LJ1 POINTS TO THE BEGINNING OF ROW I OF THE OFF-DIAGONAL BLOCKS.      0000000
          LJ1 = LJ1 - LENOFF(I)                                         0000000
          DO 270 JJ=LJ1,LJ2                                             0000000
            J = ICN(JJ)                                                 0000000
            W(J) = W(J) - A(JJ)*W(I)                                    0000000
  270     CONTINUE                                                      0000000
  280   CONTINUE                                                        0000000
        IBLEND = J1                                                     0000000
        ILAST = IFIRST - 1                                              0000000
  290 CONTINUE                                                          0000000
C REORDER SOLUTION VECTOR ... X(I)=W(IPINVERSE(I))                      0000000
  300 DO 310 II=1,N                                                     0000000
        I = IP(II)                                                      0000000
        I = IABS(I)                                                     0000000
        X(I) = W(II)                                                    0000000
  310 CONTINUE                                                          0000000
C                                                                       0000000
  320 RETURN                                                            0000000
      END                                                               0000000
      BLOCK DATA MA30JD                                                 0000000
C ALTHOUGH ALL COMMON BLOCK VARIABLES DO NOT HAVE DEFAULT VALUES,       0000000
C     WE COMMENT ON ALL THE COMMON BLOCK VARIABLES HERE.                0000000
C                                                                       0000000
C COMMON BLOCK MA30E/ED HOLDS CONTROL PARAMETERS ....                   0000000
C     COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3                        0000000
C THE INTEGER LP IS THE UNIT NUMBER TO WHICH THE ERROR MESSAGES ARE     0000000
C     SENT. LP HAS A DEFAULT VALUE OF 6.  THIS DEFAULT VALUE CAN BE     0000000
C     RESET BY THE USER, IF DESIRED.  A VALUE OF 0 SUPPRESSES ALL       0000000
C     MESSAGES.                                                         0000000
C THE LOGICAL VARIABLES ABORT1,ABORT2,ABORT3 ARE USED TO CONTROL THE    0000000
C     CONDITIONS UNDER WHICH THE SUBROUTINE WILL TERMINATE.             0000000
C IF ABORT1 IS .TRUE. THEN THE SUBROUTINE WILL EXIT  IMMEDIATELY ON     0000000
C     DETECTING STRUCTURAL SINGULARITY.                                 0000000
C IF ABORT2 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY ON      0000000
C     DETECTING NUMERICAL SINGULARITY.                                  0000000
C IF ABORT3 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY WHEN    0000000
C     THE AVAILABLE SPACE IN A/ICN IS FILLED UP BY THE PREVIOUSLY       0000000
C     DECOMPOSED, ACTIVE, AND UNDECOMPOSED PARTS OF THE MATRIX.         0000000
C THE DEFAULT VALUES FOR ABORT1,ABORT2,ABORT3 ARE SET TO .TRUE.,.TRUE.  0000000
C     AND .FALSE. RESPECTIVELY.                                         0000000
C                                                                       0000000
C THE VARIABLES IN THE COMMON BLOCK MA30F/FD ARE USED TO PROVIDE THE    0000000
C     USER WITH INFORMATION ON THE DECOMPOSITION.                       0000000
C     COMMON /MA30FD/ IRNCP, ICNCP, IRANK, MINIRN, MINICN               0000000
C IRNCP AND ICNCP ARE INTEGER VARIABLES USED TO MONITOR THE ADEQUACY    0000000
C     OF THE ALLOCATED SPACE IN ARRAYS IRN AND A/ICN RESPECTIVELY, BY   0000000
C     TAKING ACCOUNT OF THE NUMBER OF DATA MANAGEMENT COMPRESSES        0000000
C     REQUIRED ON THESE ARRAYS. IF IRNCP OR ICNCP IS FAIRLY LARGE (SAY  0000000
C     GREATER THAN N/10), IT MAY BE ADVANTAGEOUS TO INCREASE THE SIZE   0000000
C     OF THE CORRESPONDING ARRAY(S).  IRNCP AND ICNCP ARE INITIALIZED   0000000
C     TO ZERO ON ENTRY TO MA30A/AD AND ARE INCREMENTED EACH TIME THE    0000000
C     COMPRESSING ROUTINE MA30D/DD IS ENTERED.                          0000000
C ICNCP IS THE NUMBER OF COMPRESSES ON A/ICN.                           0000000
C IRNCP IS THE NUMBER OF COMPRESSES ON IRN.                             0000000
C IRANK IS AN INTEGER VARIABLE WHICH GIVES AN ESTIMATE (ACTUALLY AN     0000000
C     UPPER BOUND) OF THE RANK OF THE MATRIX. ON AN EXIT WITH IFLAG     0000000
C     EQUAL TO 0, THIS WILL BE EQUAL TO N.                              0000000
C MINIRN IS AN INTEGER VARIABLE WHICH, AFTER A SUCCESSFUL CALL TO       0000000
C     MA30A/AD, INDICATES THE MINIMUM LENGTH TO WHICH IRN CAN BE        0000000
C     REDUCED WHILE STILL PERMITTING A SUCCESSFUL DECOMPOSITION OF THE  0000000
C     SAME MATRIX. IF, HOWEVER, THE USER WERE TO DECREASE THE LENGTH    0000000
C     OF IRN TO THAT SIZE, THE NUMBER OF COMPRESSES (IRNCP) MAY BE      0000000
C     VERY HIGH AND QUITE COSTLY. IF LIRN IS NOT LARGE ENOUGH TO BEGIN  0000000
C     THE DECOMPOSITION ON A DIAGONAL BLOCK, MINIRN WILL BE EQUAL TO    0000000
C     THE VALUE REQUIRED TO CONTINUE THE DECOMPOSITION AND IFLAG WILL   0000000
C     BE SET TO -3 OR -6. A VALUE OF LIRN SLIGHTLY GREATER THAN THIS    0000000
C     (SAY ABOUT N/2) WILL USUALLY PROVIDE ENOUGH SPACE TO COMPLETE     0000000
C     THE DECOMPOSITION ON THAT BLOCK. IN THE EVENT OF ANY OTHER        0000000
C     FAILURE MINIRN GIVES THE MINIMUM SIZE OF IRN REQUIRED FOR A       0000000
C     SUCCESSFUL DECOMPOSITION UP TO THAT POINT.                        0000000
C MINICN IS AN INTEGER VARIABLE WHICH AFTER A SUCCESSFUL CALL TO        0000000
C     MA30A/AD, INDICATES THE MINIMUM SIZE OF LICN REQUIRED TO ENABLE   0000000
C     A SUCCESSFUL DECOMPOSITION. IN THE EVENT OF FAILURE WITH IFLAG=   0000000
C     -5, MINICN WILL, IF ABORT3 IS LEFT SET TO .FALSE., INDICATE THE   0000000
C     MINIMUM LENGTH THAT WOULD BE SUFFICIENT TO PREVENT THIS ERROR IN  0000000
C     A SUBSEQUENT RUN ON AN IDENTICAL MATRIX. AGAIN THE USER MAY       0000000
C     PREFER TO USE A VALUE OF ICN SLIGHTLY GREATER THAN MINICN FOR     0000000
C     SUBSEQUENT RUNS TO AVOID TOO MANY CONPRESSES (ICNCP). IN THE      0000000
C     EVENT OF FAILURE WITH IFLAG EQUAL TO ANY NEGATIVE VALUE EXCEPT    0000000
C     -4, MINICN WILL GIVE THE MINIMUM LENGTH TO WHICH LICN COULD BE    0000000
C     REDUCED TO ENABLE A SUCCESSFUL DECOMPOSITION TO THE POINT AT      0000000
C     WHICH FAILURE OCCURRED.  NOTICE THAT, ON A SUCCESSFUL ENTRY       0000000
C     IDISP(2) GIVES THE AMOUNT OF SPACE IN A/ICN REQUIRED FOR THE      0000000
C     DECOMPOSITION WHILE MINICN WILL USUALLY BE SLIGHTLY GREATER       0000000
C     BECAUSE OF THE NEED FOR "ELBOW ROOM".  IF THE USER IS VERY        0000000
C     UNSURE HOW LARGE TO MAKE LICN, THE VARIABLE MINICN CAN BE USED    0000000
C     TO PROVIDE THAT INFORMATION. A PRELIMINARY RUN SHOULD BE          0000000
C     PERFORMED WITH ABORT3 LEFT SET TO .FALSE. AND LICN ABOUT 3/2      0000000
C     TIMES AS BIG AS THE NUMBER OF NON-ZEROS IN THE ORIGINAL MATRIX.   0000000
C     UNLESS THE INITIAL PROBLEM IS VERY SPARSE (WHEN THE RUN WILL BE   0000000
C     SUCCESSFUL) OR FILLS IN EXTREMELY BADLY (GIVING AN ERROR RETURN   0000000
C     WITH IFLAG EQUAL TO -4), AN ERROR RETURN WITH IFLAG EQUAL TO -5   0000000
C     SHOULD RESULT AND MINICN WILL GIVE THE AMOUNT OF SPACE REQUIRED   0000000
C     FOR A SUCCESSFUL DECOMPOSITION.                                   0000000
C                                                                       0000000
C COMMON BLOCK MA30G/GD IS USED BY THE MA30B/BD ENTRY ONLY.             0000000
C     COMMON /MA30GD/ EPS, RMIN                                         0000000
C EPS IS A REAL/DOUBLE PRECISION VARIABLE. IT IS USED TO TEST FOR       0000000
C     SMALL PIVOTS. ITS DEFAULT VALUE IS 1.0E-4 (1.0D-4 IN D VERSION).  0000000
C     IF THE USER SETS EPS TO ANY VALUE GREATER THAN 1.0, THEN NO       0000000
C     CHECK IS MADE ON THE SIZE OF THE PIVOTS. ALTHOUGH THE ABSENCE OF  0000000
C     SUCH A CHECK WOULD FAIL TO WARN THE USER OF BAD INSTABILITY, ITS  0000000
C     ABSENCE WILL ENABLE MA30B/BD TO RUN SLIGHTLY FASTER. AN  A        0000000
C     POSTERIORI  CHECK ON THE STABILITY OF THE FACTORIZATION CAN BE    0000000
C     OBTAINED FROM MC24A/AD.                                           0000000
C RMIN IS A REAL/DOUBLE PRECISION VARIABLE WHICH GIVES THE USER SOME    0000000
C     INFORMATION ABOUT THE STABILITY OF THE DECOMPOSITION.  AT EACH    0000000
C     STAGE OF THE LU DECOMPOSITION THE MAGNITUDE OF THE PIVOT APIV     0000000
C     IS COMPARED WITH THE LARGEST OFF-DIAGONAL ENTRY CURRENTLY IN ITS  0000000
C     ROW (ROW OF U), ROWMAX SAY. IF THE RATIO                          0000000
C                       MIN (APIV/ROWMAX)                               0000000
C     WHERE THE MINIMUM IS TAKEN OVER ALL THE ROWS, IS LESS THAN EPS    0000000
C     THEN RMIN IS SET TO THIS MINIMUM VALUE AND IFLAG IS RETURNED      0000000
C     WITH THE VALUE +I WHERE I IS THE ROW IN WHICH THIS MINIMUM        0000000
C     OCCURS.  IF THE USER SETS EPS GREATER THAN ONE, THEN THIS TEST    0000000
C     IS NOT PERFORMED. IN THIS CASE, AND WHEN THERE ARE NO SMALL       0000000
C     PIVOTS RMIN WILL BE SET EQUAL TO EPS.                             0000000
C                                                                       0000000
C COMMON BLOCK MA30H/HD IS USED BY MA30C/CD ONLY.                       0000000
C     COMMON /MA30HD/ RESID                                             0000000
C RESID IS A REAL/DOUBLE PRECISION VARIABLE. IN THE CASE OF SINGULAR    0000000
C     OR RECTANGULAR MATRICES ITS FINAL VALUE WILL BE EQUAL TO THE      0000000
C     MAXIMUM RESIDUAL FOR THE UNSATISFIED EQUATIONS; OTHERWISE ITS     0000000
C     VALUE WILL BE SET TO ZERO.                                        0000000
C                                                                       0000000
C COMMON  BLOCK MA30I/ID CONTROLS THE USE OF DROP TOLERANCES, THE       0000000
C     MODIFIED PIVOT OPTION AND THE THE CALCULATION OF THE LARGEST      0000000
C     ENTRY IN THE FACTORIZATION PROCESS. THIS COMMON BLOCK WAS ADDED   0000000
C     TO THE MA30 PACKAGE IN FEBRUARY, 1983.                            0000000
C     COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG                      0000000
C TOL IS A REAL/DOUBLE PRECISION VARIABLE.  IF IT IS SET TO A POSITIVE  0000000
C     VALUE, THEN MA30A/AD WILL DROP FROM THE FACTORS ANY NON-ZERO      0000000
C     WHOSE MODULUS IS LESS THAN TOL.  THE FACTORIZATION WILL THEN      0000000
C     REQUIRE LESS STORAGE BUT WILL BE INACCURATE.  AFTER A RUN OF      0000000
C     MA30A/AD WHERE ENTRIES HAVE BEEN DROPPED, MA30B/BD  SHOULD NOT    0000000
C     BE CALLED.  THE DEFAULT VALUE FOR TOL IS 0.0.                     0000000
C BIG IS A REAL/DOUBLE PRECISION VARIABLE.  IF LBIG HAS BEEN SET TO     0000000
C     .TRUE., BIG WILL BE SET TO THE LARGEST ENTRY ENCOUNTERED DURING   0000000
C     THE FACTORIZATION.                                                0000000
C NDROP IS AN INTEGER VARIABLE. IF TOL HAS BEEN SET POSITIVE, ON EXIT   0000000
C     FROM MA30A/AD, NDROP WILL HOLD THE NUMBER OF ENTRIES DROPPED      0000000
C     FROM THE DATA STRUCTURE.                                          0000000
C NSRCH IS AN INTEGER VARIABLE. IF NSRCH IS SET TO A VALUE LESS THAN    0000000
C     OR EQUAL TO N, THEN A DIFFERENT PIVOT OPTION WILL BE EMPLOYED BY  0000000
C     MA30A/AD.  THIS MAY RESULT IN DIFFERENT FILL-IN AND EXECUTION     0000000
C     TIME FOR MA30A/AD. IF NSRCH IS LESS THAN OR EQUAL TO N, THE       0000000
C     WORKSPACE ARRAYS LASTC AND NEXTC ARE NOT REFERENCED BY MA30A/AD.  0000000
C     THE DEFAULT VALUE FOR NSRCH IS 32768.                             0000000
C LBIG IS A LOGICAL VARIABLE. IF LBIG IS SET TO .TRUE., THE VALUE OF    0000000
C     THE LARGEST ENTRY ENCOUNTERED IN THE FACTORIZATION BY MA30A/AD    0000000
C     IS RETURNED IN BIG.  SETTING LBIG TO .TRUE.  WILL MARGINALLY      0000000
C     INCREASE THE FACTORIZATION TIME FOR MA30A/AD AND WILL INCREASE    0000000
C     THAT FOR MA30B/BD BY ABOUT 20%.  THE DEFAULT VALUE FOR LBIG IS    0000000
C     .FALSE.                                                           0000000
C                                                                       0000000
      DOUBLE PRECISION EPS, RMIN, TOL, BIG                              0000000
      LOGICAL ABORT1, ABORT2, ABORT3, LBIG                              0000000
      COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3                        0000000
      COMMON /MA30GD/ EPS, RMIN                                         0000000
      COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG                      0000000
      DATA EPS /1.0D-4/, TOL /0.0D0/, BIG /0.0D0/                       0000000
      DATA LP /6/, NSRCH /32768/                                        0000000
      DATA LBIG /.FALSE./                                               0000000
      DATA ABORT1 /.TRUE./, ABORT2 /.TRUE./, ABORT3 /.FALSE./           0000000
      END                                                               0000000
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC20AD MC20BD
      SUBROUTINE MC20AD(NC,MAXA,A,INUM,JPTR,JNUM,JDISP)
C
      INTEGER   INUM(MAXA),JNUM(MAXA)
      DOUBLE PRECISION A(MAXA),ACE,ACEP
      DIMENSION JPTR(NC)
C
C     ******************************************************************
C
      NULL=-JDISP
C**      CLEAR JPTR
      DO 60 J=1,NC
   60 JPTR(J)=0
C**      COUNT THE NUMBER OF ELEMENTS IN EACH COLUMN.
      DO 120 K=1,MAXA
      J=JNUM(K)+JDISP
      JPTR(J)=JPTR(J)+1
  120 CONTINUE
C**      SET THE JPTR ARRAY
      K=1
      DO 150 J=1,NC
      KR=K+JPTR(J)
      JPTR(J)=K
  150 K=KR
C
C**      REORDER THE ELEMENTS INTO COLUMN ORDER.  THE ALGORITHM IS AN
C        IN-PLACE SORT AND IS OF ORDER MAXA.
      DO 230 I=1,MAXA
C        ESTABLISH THE CURRENT ENTRY.
      JCE=JNUM(I)+JDISP
      IF(JCE.EQ.0) GO TO 230
      ACE=A(I)
      ICE=INUM(I)
C        CLEAR THE LOCATION VACATED.
      JNUM(I)=NULL
C        CHAIN FROM CURRENT ENTRY TO STORE ITEMS.
      DO 200 J=1,MAXA
C        CURRENT ENTRY NOT IN CORRECT POSITION.  DETERMINE CORRECT
C        POSITION TO STORE ENTRY.
      LOC=JPTR(JCE)
      JPTR(JCE)=JPTR(JCE)+1
C        SAVE CONTENTS OF THAT LOCATION.
      ACEP=A(LOC)
      ICEP=INUM(LOC)
      JCEP=JNUM(LOC)
C        STORE CURRENT ENTRY.
      A(LOC)=ACE
      INUM(LOC)=ICE
      JNUM(LOC)=NULL
C        CHECK IF NEXT CURRENT ENTRY NEEDS TO BE PROCESSED.
      IF(JCEP.EQ.NULL) GO TO 230
C        IT DOES.  COPY INTO CURRENT ENTRY.
      ACE=ACEP
      ICE=ICEP
  200 JCE=JCEP+JDISP
C
  230 CONTINUE
C
C**      RESET JPTR VECTOR.
      JA=1
      DO 250 J=1,NC
      JB=JPTR(J)
      JPTR(J)=JA
  250 JA=JB
      RETURN
      END
      SUBROUTINE MC20BD(NC,MAXA,A,INUM,JPTR)
      DOUBLE PRECISION A(MAXA),ACE
      INTEGER   INUM(MAXA)
      DIMENSION JPTR(NC)
C
C     ******************************************************************
C
      KMAX=MAXA
      DO 30 JJ=1,NC
      J=NC+1-JJ
      KLO=JPTR(J)+1
      IF(KLO.GT.KMAX)GO TO 30
      KOR=KMAX
      DO 25 KDUMMY=KLO,KMAX
C ITEMS KOR, KOR+1, .... ,KMAX ARE IN ORDER
      ACE=A(KOR-1)
      ICE=INUM(KOR-1)
      DO 10 K=KOR,KMAX
      IK=INUM(K)
      IF(IABS(ICE).LE.IABS(IK))GO TO 20
      INUM(K-1)=IK
10    A(K-1)=A(K)
      K=KMAX+1
20    INUM(K-1)=ICE
      A(K-1)=ACE
25    KOR=KOR-1
C        NEXT COLUMN
30    KMAX=KLO-2
      RETURN
      END
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC22AD
      SUBROUTINE MC22AD(N,ICN,A,NZ,LENROW,IP,IQ,IW,IW1)
      DOUBLE PRECISION A(NZ),AVAL
      INTEGER IW(N,2)
      INTEGER   ICN(NZ),LENROW(N),IP(N),IQ(N),IW1(NZ)
      IF (NZ.LE.0) GO TO 1000
      IF (N.LE.0) GO TO 1000
C SET START OF ROW I IN IW(I,1) AND LENROW(I) IN IW(I,2)
      IW(1,1)=1
      IW(1,2)=LENROW(1)
      DO 10 I=2,N
      IW(I,1)=IW(I-1,1)+LENROW(I-1)
 10   IW(I,2)=LENROW(I)
C PERMUTE LENROW ACCORDING TO IP.  SET OFF-SETS FOR NEW POSITION
C     OF ROW IOLD IN IW(IOLD,1) AND PUT OLD ROW INDICES IN IW1 IN
C     POSITIONS CORRESPONDING TO THE NEW POSITION OF THIS ROW IN A/ICN.
      JJ=1
      DO 20 I=1,N
      IOLD=IP(I)
      IOLD=IABS(IOLD)
      LENGTH=IW(IOLD,2)
      LENROW(I)=LENGTH
      IF (LENGTH.EQ.0) GO TO 20
      IW(IOLD,1)=IW(IOLD,1)-JJ
      J2=JJ+LENGTH-1
      DO 15 J=JJ,J2
 15   IW1(J)=IOLD
      JJ=J2+1
 20   CONTINUE
C SET INVERSE PERMUTATION TO IQ IN IW(.,2).
      DO 30 I=1,N
      IOLD=IQ(I)
      IOLD=IABS(IOLD)
 30   IW(IOLD,2)=I
C PERMUTE A AND ICN IN PLACE, CHANGING TO NEW COLUMN NUMBERS.
C
C ***   MAIN LOOP   ***
C EACH PASS THROUGH THIS LOOP PLACES A CLOSED CHAIN OF COLUMN INDICES
C     IN THEIR NEW (AND FINAL) POSITIONS ... THIS IS RECORDED BY
C     SETTING THE IW1 ENTRY TO ZERO SO THAT ANY WHICH ARE SUBSEQUENTLY
C     ENCOUNTERED DURING THIS MAJOR SCAN CAN BE BYPASSED.
      DO 200 I=1,NZ
      IOLD=IW1(I)
      IF (IOLD.EQ.0) GO TO 200
      IPOS=I
      JVAL=ICN(I)
C IF ROW IOLD IS IN SAME POSITIONS AFTER PERMUTATION GO TO 150.
      IF (IW(IOLD,1).EQ.0) GO TO 150
      AVAL=A(I)
C **  CHAIN LOOP  **
C EACH PASS THROUGH THIS LOOP PLACES ONE (PERMUTED) COLUMN INDEX
C     IN ITS FINAL POSITION  .. VIZ. IPOS.
      DO 100 ICHAIN=1,NZ
C NEWPOS IS THE ORIGINAL POSITION IN A/ICN OF THE ELEMENT TO BE PLACED
C IN POSITION IPOS.  IT IS ALSO THE POSITION OF THE NEXT ELEMENT IN
C     THE CHAIN.
      NEWPOS=IPOS+IW(IOLD,1)
C IS CHAIN COMPLETE ?
      IF (NEWPOS.EQ.I) GO TO 130
      A(IPOS)=A(NEWPOS)
      JNUM=ICN(NEWPOS)
      ICN(IPOS)=IW(JNUM,2)
      IPOS=NEWPOS
      IOLD=IW1(IPOS)
      IW1(IPOS)=0
C **  END OF CHAIN LOOP  **
 100  CONTINUE
 130  A(IPOS)=AVAL
 150  ICN(IPOS)=IW(JVAL,2)
C ***   END OF MAIN LOOP   ***
 200  CONTINUE
C
 1000 RETURN
      END
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC23AD
C###### CALLS   MC13    MC21
      SUBROUTINE MC23AD(N,ICN,A,LICN,LENR,IDISP,IP,IQ,LENOFF,IW,IW1)
      DOUBLE PRECISION A(LICN)
      INTEGER IDISP(2),IW1(N,2)
      LOGICAL ABORT
      INTEGER   ICN(LICN),LENR(N),IP(N),IQ(N),LENOFF(N),IW(N,5)
      COMMON /MC23BD/ LP,NUMNZ,NUM,LARGE,ABORT
C INPUT ... N,ICN .. A,ICN,LENR ....
C
C SET UP POINTERS IW(.,1) TO THE BEGINNING OF THE ROWS AND SET LENOFF
C     EQUAL TO LENR.
      EXTERNAL MC23CD
      IW1(1,1)=1
      LENOFF(1)=LENR(1)
      IF (N.EQ.1) GO TO 20
      DO 10 I=2,N
      LENOFF(I)=LENR(I)
   10 IW1(I,1)=IW1(I-1,1)+LENR(I-1)
C IDISP(1) POINTS TO THE FIRST POSITION IN A/ICN AFTER THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
   20 IDISP(1)=IW1(N,1)+LENR(N)
C
C FIND ROW PERMUTATION IP TO MAKE DIAGONAL ZERO-FREE.
      CALL MC21A(N,ICN,LICN,IW1,LENR,IP,NUMNZ,IW)
C
C POSSIBLE ERROR RETURN FOR STRUCTURALLY SINGULAR MATRICES.
      IF (NUMNZ.NE.N.AND.ABORT) GO TO 170
C
C IW1(.,2) AND LENR ARE PERMUTATIONS OF IW1(.,1) AND LENR/LENOFF
C     SUITABLE FOR ENTRY
C     TO MC13D SINCE MATRIX WITH THESE ROW POINTER AND LENGTH ARRAYS
C     HAS MAXIMUM NUMBER OF NON-ZEROS ON THE DIAGONAL.
      DO 30 II=1,N
      I=IP(II)
      IW1(II,2)=IW1(I,1)
   30 LENR(II)=LENOFF(I)
C
C FIND SYMMETRIC PERMUTATION IQ TO BLOCK LOWER TRIANGULAR FORM.
      CALL MC13D(N,ICN,LICN,IW1(1,2),LENR,IQ,IW(1,4),NUM,IW)
C
      IF (NUM.NE.1) GO TO 60
C
C ACTION TAKEN IF MATRIX IS IRREDUCIBLE.
C WHOLE MATRIX IS JUST MOVED TO THE END OF THE STORAGE.
      DO 40 I=1,N
      LENR(I)=LENOFF(I)
      IP(I)=I
   40 IQ(I)=I
      LENOFF(1)=-1
C IDISP(1) IS THE FIRST POSITION AFTER THE LAST ELEMENT IN THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
      NZ=IDISP(1)-1
      IDISP(1)=1
C IDISP(2) IS THE POSITION IN A/ICN OF THE FIRST ELEMENT IN THE
C     DIAGONAL BLOCKS.
      IDISP(2)=LICN-NZ+1
      LARGE=N
      IF (NZ.EQ.LICN) GO TO 230
      DO 50 K=1,NZ
      J=NZ-K+1
      JJ=LICN-K+1
      A(JJ)=A(J)
   50 ICN(JJ)=ICN(J)
C 230 = RETURN
      GO TO 230
C
C DATA STRUCTURE REORDERED.
C
C FORM COMPOSITE ROW PERMUTATION ... IP(I) = IP(IQ(I)).
   60 DO 70 II=1,N
      I=IQ(II)
   70 IW(II,1)=IP(I)
      DO 80 I=1,N
   80 IP(I)=IW(I,1)
C
C RUN THROUGH BLOCKS IN REVERSE ORDER SEPARATING DIAGONAL BLOCKS
C     WHICH ARE MOVED TO THE END OF THE STORAGE.  ELEMENTS IN
C     OFF-DIAGONAL BLOCKS ARE LEFT IN PLACE UNLESS A COMPRESS IS
C     NECESSARY.
C
C IBEG INDICATES THE LOWEST VALUE OF J FOR WHICH ICN(J) HAS BEEN
C     SET TO ZERO WHEN ELEMENT IN POSITION J WAS MOVED TO THE
C     DIAGONAL BLOCK PART OF STORAGE.
      IBEG=LICN+1
C IEND IS THE POSITION OF THE FIRST ELEMENT OF THOSE TREATED ROWS
C     WHICH ARE IN DIAGONAL BLOCKS.
      IEND=LICN+1
C LARGE IS THE DIMENSION OF THE LARGEST BLOCK ENCOUNTERED SO FAR.
      LARGE=0
C
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
      DO 150 K=1,NUM
      IBLOCK=NUM-K+1
C I1 IS FIRST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
C I2 IS LAST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
      I1=IW(IBLOCK,4)
      I2=N
      IF (K.NE.1) I2=IW(IBLOCK+1,4)-1
      LARGE=MAX0(LARGE,I2-I1+1)
C GO THROUGH THE ROWS OF BLOCK IBLOCK IN THE REVERSE ORDER.
      DO 140 II=I1,I2
      INEW=I2-II+I1
C WE NOW DEAL WITH ROW INEW IN PERMUTED FORM (ROW IOLD IN ORIGINAL
C     MATRIX).
      IOLD=IP(INEW)
C IF THERE IS SPACE TO MOVE UP DIAGONAL BLOCK PORTION OF ROW GO TO 110
      IF (IEND-IDISP(1).GE.LENOFF(IOLD)) GO TO 110
C
C IN-LINE COMPRESS.
C MOVES SEPARATED OFF-DIAGONAL ELEMENTS AND UNTREATED ROWS TO
C     FRONT OF STORAGE.
      JNPOS=IBEG
      ILEND=IDISP(1)-1
      IF (ILEND.LT.IBEG) GO TO 190
      DO 90 J=IBEG,ILEND
      IF (ICN(J).EQ.0) GO TO 90
      ICN(JNPOS)=ICN(J)
      A(JNPOS)=A(J)
      JNPOS=JNPOS+1
   90 CONTINUE
      IDISP(1)=JNPOS
      IF (IEND-JNPOS.LT.LENOFF(IOLD)) GO TO 190
      IBEG=LICN+1
C RESET POINTERS TO THE BEGINNING OF THE ROWS.
      DO 100 I=2,N
  100 IW1(I,1)=IW1(I-1,1)+LENOFF(I-1)
C
C ROW IOLD IS NOW SPLIT INTO DIAG. AND OFF-DIAG. PARTS.
  110 IROWB=IW1(IOLD,1)
      LENI=0
      IROWE=IROWB+LENOFF(IOLD)-1
C BACKWARD SCAN OF WHOLE OF ROW IOLD (IN ORIGINAL MATRIX).
      IF (IROWE.LT.IROWB) GO TO 130
      DO 120 JJ=IROWB,IROWE
      J=IROWE-JJ+IROWB
      JOLD=ICN(J)
C IW(.,2) HOLDS THE INVERSE PERMUTATION TO IQ.
C     ..... IT WAS SET TO THIS IN MC13D.
      JNEW=IW(JOLD,2)
C IF (JNEW.LT.I1) THEN ....
C ELEMENT IS IN OFF-DIAGONAL BLOCK AND SO IS LEFT IN SITU.
      IF (JNEW.LT.I1) GO TO 120
C ELEMENT IS IN DIAGONAL BLOCK AND IS MOVED TO THE END OF THE STORAGE.
      IEND=IEND-1
      A(IEND)=A(J)
      ICN(IEND)=JNEW
      IBEG=MIN0(IBEG,J)
      ICN(J)=0
      LENI=LENI+1
  120 CONTINUE
C
      LENOFF(IOLD)=LENOFF(IOLD)-LENI
  130 LENR(INEW)=LENI
  140 CONTINUE
C
      IP(I2)=-IP(I2)
  150 CONTINUE
C RESETS IP(N) TO POSITIVE VALUE.
      IP(N)=-IP(N)
C IDISP(2) IS POSITION OF FIRST ELEMENT IN DIAGONAL BLOCKS.
      IDISP(2)=IEND
C
C THIS COMPRESS IS USED TO MOVE ALL OFF-DIAGONAL ELEMENTS TO THE
C     FRONT OF THE STORAGE.
      IF (IBEG.GT.LICN) GO TO 230
      JNPOS=IBEG
      ILEND=IDISP(1)-1
      DO 160 J=IBEG,ILEND
      IF (ICN(J).EQ.0) GO TO 160
      ICN(JNPOS)=ICN(J)
      A(JNPOS)=A(J)
      JNPOS=JNPOS+1
  160 CONTINUE
C IDISP(1) IS FIRST POSITION AFTER LAST ELEMENT OF OFF-DIAGONAL BLOCKS.
      IDISP(1)=JNPOS
      GO TO 230
C
C
C ERROR RETURN
  170 IF (LP.NE.0) WRITE(LP,180) NUMNZ
  180 FORMAT(33X,41H MATRIX IS STRUCTURALLY SINGULAR, RANK = ,I6)
      IDISP(1)=-1
      GO TO 210
  190 IF (LP.NE.0) WRITE(LP,200) N
  200 FORMAT(33X,33H LICN NOT BIG ENOUGH INCREASE BY ,I6)
      IDISP(1)=-2
  210 IF (LP.NE.0) WRITE(LP,220)
  220 FORMAT(33H+ERROR RETURN FROM MC23AD BECAUSE)
C
  230 RETURN
      END
      BLOCK DATA MC23CD
      LOGICAL ABORT
      COMMON /MC23BD/ LP,NUMNZ,NUM,LARGE,ABORT
      DATA LP/6/,ABORT/.FALSE./
      END
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC24AD
      SUBROUTINE MC24AD(N,ICN,A,LICN,LENR,LENRL,W)
      DOUBLE PRECISION A(LICN),W(N),AMAXL,WROWL,AMAXU,ZERO
      INTEGER   ICN(LICN),LENR(N),LENRL(N)
      DATA ZERO/0.0D0/
      AMAXL=ZERO
      DO 10 I=1,N
 10   W(I)=ZERO
      J0=1
      DO 100 I=1,N
      IF (LENR(I).EQ.0) GO TO 100
      J2=J0+LENR(I)-1
      IF (LENRL(I).EQ.0) GO TO 50
C CALCULATION OF 1-NORM OF L.
      J1=J0+LENRL(I)-1
      WROWL=ZERO
      DO 30 JJ=J0,J1
 30   WROWL=WROWL+DABS(A(JJ))
C AMAXL IS THE MAXIMUM NORM OF COLUMNS OF L SO FAR FOUND.
      AMAXL=DMAX1(AMAXL,WROWL)
      J0=J1+1
C CALCULATION OF NORMS OF COLUMNS OF U (MAX-NORMS).
 50   J0=J0+1
      IF (J0.GT.J2) GO TO 90
      DO 80 JJ=J0,J2
      J=ICN(JJ)
 80   W(J)=DMAX1(DABS(A(JJ)),W(J))
 90   J0=J2+1
 100  CONTINUE
C AMAXU IS SET TO MAXIMUM MAX-NORM OF COLUMNS OF U.
      AMAXU=ZERO
      DO 200 I=1,N
 200  AMAXU=DMAX1(AMAXU,W(I))
C GROFAC IS MAX U MAX-NORM TIMES MAX L 1-NORM.
      W(1)=AMAXL*AMAXU
      RETURN
      END
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC13D
      SUBROUTINE MC13D(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW)
      INTEGER IP(N)
      INTEGER ICN(LICN),LENR(N),IOR(N),IB(N),IW(N,3)
      CALL MC13E(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW(1,1),IW(1,2),IW(1,3))
      RETURN
      END
      SUBROUTINE MC13E(N,ICN,LICN,IP,LENR,ARP,IB,NUM,LOWL,NUMB,PREV)
      INTEGER STP,DUMMY
      INTEGER IP(N)
C
C ARP(I) IS ONE LESS THAN THE NUMBER OF UNSEARCHED EDGES LEAVING
C     NODE I.  AT THE END OF THE ALGORITHM IT IS SET TO A
C     PERMUTATION WHICH PUTS THE MATRIX IN BLOCK LOWER
C     TRIANGULAR FORM.
C IB(I) IS THE POSITION IN THE ORDERING OF THE START OF THE ITH
C     BLOCK.  IB(N+1-I) HOLDS THE NODE NUMBER OF THE ITH NODE
C     ON THE STACK.
C LOWL(I) IS THE SMALLEST STACK POSITION OF ANY NODE TO WHICH A PATH
C     FROM NODE I HAS BEEN FOUND.  IT IS SET TO N+1 WHEN NODE I
C     IS REMOVED FROM THE STACK.
C NUMB(I) IS THE POSITION OF NODE I IN THE STACK IF IT IS ON
C     IT, IS THE PERMUTED ORDER OF NODE I FOR THOSE NODES
C     WHOSE FINAL POSITION HAS BEEN FOUND AND IS OTHERWISE ZERO.
C PREV(I) IS THE NODE AT THE END OF THE PATH WHEN NODE I WAS
C     PLACED ON THE STACK.
      INTEGER ICN(LICN),LENR(N),ARP(N),IB(N),LOWL(N),NUMB(N),
     1PREV(N)
C
C
C   ICNT IS THE NUMBER OF NODES WHOSE POSITIONS IN FINAL ORDERING HAVE
C     BEEN FOUND.
      ICNT=0
C NUM IS THE NUMBER OF BLOCKS THAT HAVE BEEN FOUND.
      NUM=0
      NNM1=N+N-1
C
C INITIALIZATION OF ARRAYS.
      DO 20 J=1,N
      NUMB(J)=0
      ARP(J)=LENR(J)-1
   20 CONTINUE
C
C
      DO 120 ISN=1,N
C LOOK FOR A STARTING NODE
      IF (NUMB(ISN).NE.0) GO TO 120
      IV=ISN
C IST IS THE NUMBER OF NODES ON THE STACK ... IT IS THE STACK POINTER.
      IST=1
C PUT NODE IV AT BEGINNING OF STACK.
      LOWL(IV)=1
      NUMB(IV)=1
      IB(N)=IV
C
C THE BODY OF THIS LOOP PUTS A NEW NODE ON THE STACK OR BACKTRACKS.
      DO 110 DUMMY=1,NNM1
      I1=ARP(IV)
C HAVE ALL EDGES LEAVING NODE IV BEEN SEARCHED.
      IF (I1.LT.0) GO TO 60
      I2=IP(IV)+LENR(IV)-1
      I1=I2-I1
C
C LOOK AT EDGES LEAVING NODE IV UNTIL ONE ENTERS A NEW NODE OR
C     ALL EDGES ARE EXHAUSTED.
      DO 50 II=I1,I2
      IW=ICN(II)
C HAS NODE IW BEEN ON STACK ALREADY.
      IF (NUMB(IW).EQ.0) GO TO 100
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
  50  LOWL(IV)=MIN0(LOWL(IV),LOWL(IW))
C
C THERE ARE NO MORE EDGES LEAVING NODE IV.
      ARP(IV)=-1
C IS NODE IV THE ROOT OF A BLOCK.
   60 IF (LOWL(IV).LT.NUMB(IV)) GO TO 90
C
C ORDER NODES IN A BLOCK.
      NUM=NUM+1
      IST1=N+1-IST
      LCNT=ICNT+1
C PEEL BLOCK OFF THE TOP OF THE STACK STARTING AT THE TOP AND
C     WORKING DOWN TO THE ROOT OF THE BLOCK.
      DO 70 STP=IST1,N
      IW=IB(STP)
      LOWL(IW)=N+1
      ICNT=ICNT+1
      NUMB(IW)=ICNT
      IF (IW.EQ.IV) GO TO 80
   70 CONTINUE
   80 IST=N-STP
      IB(NUM)=LCNT
C ARE THERE ANY NODES LEFT ON THE STACK.
      IF (IST.NE.0) GO TO 90
C HAVE ALL THE NODES BEEN ORDERED.
      IF (ICNT.LT.N) GO TO 120
      GO TO 130
C
C BACKTRACK TO PREVIOUS NODE ON PATH.
   90 IW=IV
      IV=PREV(IV)
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
      LOWL(IV)=MIN0(LOWL(IV),LOWL(IW))
      GO TO 110
C
C PUT NEW NODE ON THE STACK.
 100  ARP(IV)=I2-II-1
      PREV(IW)=IV
      IV=IW
      IST=IST+1
      LOWL(IV)=IST
      NUMB(IV)=IST
      K=N+1-IST
      IB(K)=IV
  110 CONTINUE
C
  120 CONTINUE
C
C
C PUT PERMUTATION IN THE REQUIRED FORM.
  130 DO 140 I=1,N
      II=NUMB(I)
 140  ARP(II)=I
      RETURN
      END
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC21A
      SUBROUTINE MC21A(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW)
      INTEGER IP(N)
      INTEGER ICN(LICN),LENR(N),IPERM(N),IW(N,4)
      CALL MC21B(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW(1,1),IW(1,2),IW(1,3),
     1IW(1,4))
      RETURN
      END
      SUBROUTINE MC21B(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,PR,ARP,CV,OUT)
      INTEGER IP(N)
C   PR(I) IS THE PREVIOUS ROW TO I IN THE DEPTH FIRST SEARCH.
C IT IS USED AS A WORK ARRAY IN THE SORTING ALGORITHM.
C   ELEMENTS (IPERM(I),I) I=1, ... N  ARE NON-ZERO AT THE END OF THE
C ALGORITHM UNLESS N ASSIGNMENTS HAVE NOT BEEN MADE.  IN WHICH CASE
C (IPERM(I),I) WILL BE ZERO FOR N-NUMNZ ENTRIES.
C   CV(I) IS THE MOST RECENT ROW EXTENSION AT WHICH COLUMN I
C WAS VISITED.
C   ARP(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED WHEN LOOKING FOR A CHEAP ASSIGNMENT.
C   OUT(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED DURING ONE PASS THROUGH THE MAIN LOOP.
      INTEGER ICN(LICN),LENR(N),IPERM(N),PR(N),CV(N),
     1ARP(N),OUT(N)
C
C   INITIALIZATION OF ARRAYS.
      DO 10 I=1,N
      ARP(I)=LENR(I)-1
      CV(I)=0
   10 IPERM(I)=0
      NUMNZ=0
C
C
C   MAIN LOOP.
C   EACH PASS ROUND THIS LOOP EITHER RESULTS IN A NEW ASSIGNMENT
C OR GIVES A ROW WITH NO ASSIGNMENT.
      DO 130 JORD=1,N
      J=JORD
      PR(J)=-1
      DO 100 K=1,JORD
C LOOK FOR A CHEAP ASSIGNMENT
      IN1=ARP(J)
      IF (IN1.LT.0) GO TO 60
      IN2=IP(J)+LENR(J)-1
      IN1=IN2-IN1
      DO 50 II=IN1,IN2
      I=ICN(II)
      IF (IPERM(I).EQ.0) GO TO 110
   50 CONTINUE
C   NO CHEAP ASSIGNMENT IN ROW.
      ARP(J)=-1
C   BEGIN LOOKING FOR ASSIGNMENT CHAIN STARTING WITH ROW J.
   60 OUT(J)=LENR(J)-1
C INNER LOOP.  EXTENDS CHAIN BY ONE OR BACKTRACKS.
      DO 90 KK=1,JORD
      IN1=OUT(J)
      IF (IN1.LT.0) GO TO 80
      IN2=IP(J)+LENR(J)-1
      IN1=IN2-IN1
C FORWARD SCAN.
      DO 70 II=IN1,IN2
      I=ICN(II)
      IF (CV(I).EQ.JORD) GO TO 70
C   COLUMN I HAS NOT YET BEEN ACCESSED DURING THIS PASS.
      J1=J
      J=IPERM(I)
      CV(I)=JORD
      PR(J)=J1
      OUT(J1)=IN2-II-1
      GO TO 100
   70 CONTINUE
C
C   BACKTRACKING STEP.
   80 J=PR(J)
      IF (J.EQ.-1) GO TO 130
   90 CONTINUE
C
  100 CONTINUE
C
C   NEW ASSIGNMENT IS MADE.
  110 IPERM(I)=J
      ARP(J)=IN2-II-1
      NUMNZ=NUMNZ+1
      DO 120 K=1,JORD
      J=PR(J)
      IF (J.EQ.-1) GO TO 130
      II=IP(J)+LENR(J)-OUT(J)-2
      I=ICN(II)
      IPERM(I)=J
  120 CONTINUE
C
  130 CONTINUE
C
C   IF MATRIX IS STRUCTURALLY SINGULAR, WE NOW COMPLETE THE
C PERMUTATION IPERM.
      IF (NUMNZ.EQ.N) RETURN
      DO 140 I=1,N
  140 ARP(I)=0
      K=0
      DO 160 I=1,N
      IF (IPERM(I).NE.0) GO TO 150
      K=K+1
      OUT(K)=I
      GO TO 160
  150 J=IPERM(I)
      ARP(J)=I
  160 CONTINUE
      K=0
      DO 170 I=1,N
      IF (ARP(I).NE.0) GO TO 170
      K=K+1
      IOUTK=OUT(K)
      IPERM(IOUTK)=I
  170 CONTINUE
      RETURN
      END
