@! The line length must exceed 80 characters to accommodate GLA
@! descriptions that mirror the syntax of the Revised Report

@p maximum_input_line_length = infinity

@A@<Introduction@>

This document was generated by the Eli system from a specification module
that provides a complete description of ALGOL 60.
ALGOL 60 was defined in the classic paper
``Revised Report on the Algorithmic Language ALGOL 60'',
which appeared (among other places) in the January, 1963 issue of
@/Communications of the ACM@/ (pages 1-17).
We have structured the specification module to correspond as closely as
possible to that paper, so that it is easy for the reader to verify that
the specification module describes the same language as the paper.

From this specification module, the Eli system can generate an executable
program that checks its input to verify conformance to the rules of
ALGOL 60.
This specification module can also be combined with other specification
modules to define additional analysis of the input program and/or
translation of the algorithm embodied in that program to another language.

This specification defines a hardware language that differs from the
reference language of the Revised Report in some of the symbols used to
represent objects.
These differences will be pointed out in the appropriate sections of this
document.

We have also restricted the language in two ways: unsigned integers cannot
be used as labels, and type specifications must be given for all procedure
parameters.
The former restriction avoids a known ambiguity, and the latter is
necessary for compile-time determination of the types of expressions.
Both are common in ALGOL 60 implementations (Randell, B., Russell, L. J.
``ALGOL 60 Implementation'').

@B@<Formalism for Syntactic Description@>

We have used a more modern form of BNF notation in which the quoting
conventions are reversed:
The Revised Report uses angle brackets to quote nonterminal symbols, and
leaves terminal symbols unquoted;
we leave nonterminal symbols unquoted and use apostrophes to quote terminal
symbols.

One consequence of this quoting strategy is that spaces are not allowed
within nonterminal names.
In order to preserve the understandability of the nonterminal names used in
the Revised Report, we have adopted the convention of running the words
together and capitalizing the first letter of every word.
Thus we render the Revised Report's nonterminal @{<simple variable>@}
as @{SimpleVariable@}.

The Revised Report uses a combination of BNF and English to describe the
complete syntax of the language.
Because this is an executable specification, we follow standard compiler
practice, using BNF to describe the phrase structure and using a
combination of regular expressions and C code to describe the basic symbols
and comments.

@C@<Phrase Structure@>

A type-@{con@} file provides the definition of the context-free grammar to
be used by the parser to recognize the structure of a program.

@O@<algol60.con@>==@{@-
@<Logical Values@>
@<Numbers@>
@<Variables@>
@<Function Designators@>
@<Expressions@>
@<Compound Statements and Blocks@>
@<Assignment Statements@>
@<Go To Statements@>
@<Dummy Statements@>
@<Conditional Statements@>
@<For Statements@>
@<Procedure Statements@>
@<Declarations@>
@}

@C@<Basic Symbols and Comments@>

The definition of a basic symbol or comment consists of a
@/regular expression@/, an @/auxiliary scanner@/, and a @/token processor@/.
Either the auxiliary scanner or the token processor, or both, may be
omitted.

The regular expression defines a sequence of characters
that identifies the particular basic symbol or comment in the text.
If this character sequence does not constitute the complete basic symbol or
comment, then an auxiliary scanner that obtains the complete sequence
is specified.
Finally, if additional actions are required after the sequence has been
recognized, then a token processor is specified to carry out those actions.
Auxiliary scanners and token processors for common situations can be found
in the Eli library.
Routines to handle special situations can be written in C or C++ and
provided as part of the specification.

For example, consider an ALGOL 60 string.
This basic symbol is identified by the opening string quote @{`@}.
A single opening string quote does not constitute the complete string,
and the nested structure defined in Section 2.6.1 of the Revised Report
cannot be described by a regular expression.
Therefore we have written a C-coded auxiliary scanner named @{Algol60String@}
to obtain the complete sequence.
After the string has been recognized, an internal representation must be
created.
The token processor @{mkidn@} from the Eli library can be used to carry out
that task.

A type-@{gla@} file provides the definitions of the basic symbols and
comments.
Each definition consists of a regular expression and (if necessary)
the names of an auxiliary scanner and/or a token processor.

@O@<algol60.gla@>==@{@-
@<Delimiters@>
@<Unsigned Numbers@>
@<Identifiers@>
@<Strings@>
@<Parameter Delimiter Letter String@>
@<Code as Procedure Body@>
@}

A type-@{c@} file contains the code of the auxiliary scanners and token
processors that are written to support the specification.

@O@<algol60.c@>==@{@-
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "err.h"
#include "gla.h"
#include "source.h"
#include "tabsize.h"
#include "litcode.h"

@<Comment Scanner@>
@<Token processors for comment delimiters@>

@<String Scanner@>
@}

All auxiliary scanners obey the following interface specification:

@$@<Define an Auxiliary Scanner@>@(@1@)@M@{@-
char *
@1(char *start, int length)
/* Standard interface for an auxiliary scanner
 *   On entry-
 *     start points to the first character of the scanned string
 *     length=length of the scanned string
 *   On exit-
 *     The function returns a pointer to the first character
 *       beyond the scanned string
 ***/
@}

All token processors obey the following interface specification:

@$@<Define a token processor@>@(@1@)@M@{@-
void
@1(const char *start, int length, int *syncode, int *intrinsic)
/* Token processor "Name"
 *   On entry-
 *     start points to the first character of the sequence being
 *     classified
 *     length=length of the sequence being classified
 *     syncode points to a location containing the initial
 *     classification
 *     intrinsic points to a location to receive the value
 *   On exit-
 *     syncode points to a location containing the final
 *     classification
 *     intrinsic points to a location containing the value (if
 *     relevant)
 ***/
@}

@B@<Formalism for Semantically-Equivalent Symbols@>

Many distinct symbols used in the syntax of the Revised Report refer to
semantically-identical constructs.
We group such symbols into equivalence classes, and use a single symbol in
the semantic description.
This reduces the size of the semantic description, and emphasizes the
uniformity of meaning among the equivalent symbols.

@O@<algol60.map@>@{@-
MAPSYM
@<Equivalences@>
@}

Our specifications of equivalence classes have replaced the examples of
ALGOL 60 code that appear in the Revised Report.
Where no equivalence classes are defined, we have inserted an empty section
in order to keep the section numbering parallel to that of the Revised
Report.

@B@<Formalism for Semantic Description@>

We use an attribute grammar to describe the semantics of ALGOL 60 via a
series of tree computations.
The description specifies only the relationships that must hold among these
computations; Eli can deduce the order in which the computations should be
carried out, and decide on how (or indeed whether) to store intermediate
values.

Relationships among computations are embodied in @/attributes@/, which
constitute pre- and post-conditions for computations.
An attribute may have a value, and that value may be of any type.
Types are often defined by external modules that export a set of
appropriate operations for use in computation.
The pre- and post-conditions may relate computations locally, or remotely
along root-to-leaf or depth-first, left-to-right paths.

Eli's attribute grammar notation is LIDO.
A LIDO specification consists of a set of symbol and rule computations,
with additional definitions of the types of attributes.
All computations must be expressed as function application.
(Non-strict functions are available for dealing with conditional
computation.)
Computations may be associated with specific contexts in the tree
(@/rule@/ computations),
or with every context in which a particular symbol appears
(@/symbol@/ computations).

@O@<algol60.lido@>==@{@-
@<Internal representation of an identifier@>
@<Binding Identifier Uses to their Definitions@>
@<Scope Violation Rules@>

@<Semantics@>

@<Subscripts@>

@<Type Attributes@>
@<Establish operator indications for source symbols@>
@<Identify an operator from its context@>
@<Balance the operands of a conditional@>

@<Verify type consistency of a left-part list@>
@<Verify that an expression can be assigned to a left-part list@>
@<The for List Elements@>
@<Actual-Formal Correspondence@>
@<Restrictions@>
@<Values of Function Designators@>
@<Specifications@>
@<Lower upper bound expressions@>
@}

@C

An identifier may have different meanings in different parts of an ALGOL 60
program.
We deal with this by using a @/definition table key@/ to represent the
meaning of an identifier internally.
Definition table keys are unique handles providing access to the specific
set of properties that characterize an entity.

@$@<Binding Identifier Uses to their Definitions@>==@{@-
ATTR Key: DefTableKey;
@}

Identifiers are freely chosen by the programmer and given meaning through
specific language constructs.
The general strategy is to bind the definition of an identifier and all of
its uses to the same definition table key.
When processing a construct that gives meaning to an identifier, properties
characterizing that meaning are associated with the definition table key to
which the definition is bound, and when processing a construct that uses
an identifier those properties are accessed.

Eli provides modules for establishing these bindings.
Each module implements a specific set of rules governing the binding
process, and any number of copies of any of the available modules can be
instantiated in a given specification.

@$@<Instantiate the ALGOL 60 consistent renaming module@>==@{@-
$/Name/AlgScope.gnrc :inst
@}

@C@<Verifying Type Consistency@>

ALGOL 60 places a number of context conditions on expressions,
and those conditions are defined formally in this document.
The tree computations to determine the type of each expression and
to verify the context conditions are embodied in two Eli modules:

@$@<Instantiate the type analysis modules@>==@{@-
$/Type/Typing.gnrc :inst
$/Type/Expression.gnrc :inst
@}

For each operator, three steps are required:
an @/operator indication@/ must be established for the
operator's source language symbol,
one or more @/operators@/ must be associated with the indication, and
the @/signatures@/ of those operators must be defined.

Operator indications are established for each operator's source language
symbol by computations described in LIDO:

@$@<Set a monadic operator indication@>@(@2@)@M@{@-
RULE: Uniop ::= '@1' COMPUTE Uniop.Indic=@2; END;
@}

@$@<Set a dyadic operator indication@>@(@2@)@M@{@-
RULE: Binop ::= '@1' COMPUTE Binop.Indic=@2; END;
@}

Signatures for the operators are described, and operators associated with
indications, by descriptions written in OIL:

@O@<algol60.oil@>@{@-
@<Define operators and associate them with indications@>
@<Define an operator to be applied when needed@>
@<Define operators to establish types without values@>
@}

OIL @/describes@/ a set of constraints that the operators and
expressions must satisfy.
Those constraints must be @/verified@/ by tree computations
that use computational roles exported by the type analysis modules.

@$@<Identify an operator from its context@>==@{@-
SYMBOL Expression INHERITS ExpressionSymbol END;
SYMBOL Uniop      INHERITS OperatorSymbol   END;
SYMBOL Binop      INHERITS OperatorSymbol   END;

RULE: Expression ::= Uniop Expression COMPUTE
  MonadicContext(Expression[1],Uniop,Expression[2]);
END;

RULE: Expression ::= Expression Binop Expression COMPUTE
  DyadicContext(Expression[1],Binop,Expression[2],Expression[3]);
END;
@}

The constraint on a conditional expression is that the type of the result
must not depend on the (run-time) outcome of the condition:

@$@<Balance the operands of a conditional@>==@{@-
RULE: Expression ::= IfClause Expression 'else' Expression COMPUTE
  BalanceContext(Expression[1],Expression[2],Expression[3]);
END;
@}

@B@<Formalism for Properties of Quantities@>

Each quantity is represented internally by a definition table key, which is
used to access the properties of that quantity.
Properties are declared individually in a type-@{pdl@} file:

@O@<algol60.pdl@>==@{@-
@<Property characterizing all quantities@>
@<Dimension property of an array@>
@<Properties characterizing function designators@>
@<Properties characterizing formal parameters@>
@<Formal parameter key list@>
@<Property to support Section 5.2.4.2 check@>
@<Property to support Section 4.7.5.2 check@>
@}

The declaration of a property specifies the type of value that property can
hold.
All C basic types, plus the type @{DefTableKey@} (the type of a definition
table key) can be used without further specification; any other types must
be specified by some type-@{h@} file whose name is given in the
type-@{pdl@} file.

@B@<Formalism for Modules and Interfaces@>

Computations that verify context conditions are often expressed in terms of
abstract data types that are exported by modules either defined by the user
or obtained from Eli's library.

@C@<User-Defined Modules@>

A type-@{h@} file is used to define the interfaces for user-defined modules:

@O@<algol60.h@>==@{@-
#ifndef ALGOL60_H
#define ALGOL60_H

@<Kinds of quantities@>
@<Parameter identification@>
@<Monitoring interface@>

#endif
@}

Because type-@{h@} files may be included by several different
specifications, they must be protected against multiple inclusion.
Eli's convention is to use a symbol consisting of the file name rendered in
upper case, with periods replaced by underscores.

The definitions must be made available to the routines that implement the
computations, by including them in a type-@{head@} file:

@O@<algol60.head@>==@{@-
#include "algol60.h"
@}

@C@<Library Modules@>

Library modules are instantiated by Eli requests named in a type-@{specs@}
file:

@O@<algol60.specs@>==@{@-
@<Instantiate the ALGOL 60 consistent renaming module@>
@<Instantiate modules to pre-define identifiers@>
@<Instantiate the type analysis modules@>
@<Instantiate modules to support MultDefChk@>
@<Instantiate modules for list handling@>
@<Instantiate additional modules for uniqueness checks@>
@}

@C

This specification defines two types, @{KindOfQuantity@} (Section 2.7) and
@{Parameter@} (Section 4.7.4).
It is useful when debugging the specification to be able to examine the
values of these types, so we need to specify a monitoring interface for
them.

@$@<Monitoring interface@>==@{@-
#ifdef MONITOR
#define DAPTO_RESULTKindOfQuantity(k) DAPTO_RESULT_INT (k)

#define DAPTO_RESULTParameter(k) DAPTO_RESULT_PTR (k)
#define DAPTO_ARGParameter(k) DAPTO_ARG_PTR (k, Parameter)
#endif
@}

In order to print the monitored values, we need some TCL code.

@O@<algol60.tcl@>==@{@-
@<Print KindOfQuantity values@>
@<Print Parameter values@>
@}

@{KindOfQuantity@} is an enumerated type, and it is useful to print the
identifiers of that type rather than simply the index.

@$@<Print KindOfQuantity values@>==@{@-
set n(KindOfQuantity,desc) "Kind of quantity represented"

proc n_KindOfQuantity_say {i} {
    set l {UndefinedIdn VariableIdn ArrayIdn LabelIdn SwitchIdn ProcedureIdn}
    n_say "KindOfQuantity:[lindex $l $i]"
}
@}

A @{Parameter@} is a definition table key, so we can use the monitor print
routines already available for type @{DefTableKey@}.

@$@<Print Parameter values@>==@{@-
set n(Parameter,desc) "Internal parameter name"

proc n_Parameter_open {text key} {
    n_DefTableKey_open $text $key
}

proc n_Parameter_say {key} {
    n_DefTableKey_say $key
}
@}

@A@<Basic Symbols, Identifiers, Numbers, and Strings@>

The basic symbols of our specification language are identifiers,
denotations and delimiters rather than the characters making them up.

Basic symbols are recognized by a finite-state machine, and therefore the
definitions of the basic symbols are stated as regular expressions rather
than productions of a context-free grammar.
This means that all recursive definitions given in the Revised Report
must be replaced by the equivalent iterative formulations.
We have kept the regular expression notation as close to the form of the
context-free grammar as possible to ease verification, except that we have
replaced alternations with a more compact representation when describing
sets of characters: @{[a-d]@} means @{a|b|c|d@} and @{[^;]@} means ``any
character other than semicolon'', for example.

The scanner that recognizes basic symbols attaches source text coordinates
(the line number and column number of the first character) to each basic
symbol.
This requires that the scanner keep track of the coordinates as it is
scanning.
Coordinate tracking is handled automatically for most basic symbols, but
must be provided explicitly for basic symbols that may contain horizontal
tab or newline characters.
These cases are noted below when they occur.

@B@<Letters@>

@$@<letter@>@M@{[a-zA-Z]@}

Letters are used only as components of other basic symbols.

@B@< @>

@C@<Digits@>

@$@<digit@>@M@{[0-9]@}

Digits are used only as components of other basic symbols.

@C@<Logical Values@>

@$@<Logical Values@>==@{@-
LogicalValue ::= 'true' / 'false' .
@}

The logical values are denoted by keywords of the language.

@B@<Delimiters@>

Most delimiters appear as quoted literals in the grammar, so their
definitions need not be repeated here.
The exceptions are those delimiters associated with comments:
@{;@}, @{begin@}, and @{end@}.

We still want to represent these delimiters as quoted literals in the
grammar, but we need to specify that they must be processed specially:

@O@<algol60.delit@>==@{@-
$;	Semi
$begin	begin
$end	end
@}

This specification requires that we recognize each of the delimiters using
appropriate scanners, and then use a token processor to set the @{syncode@} to
@{Semi@}, @{begin@}, or @{end@}.
The actual text of each delimiter is specified as usual, except that no
symbol is associated with the scan because the symbol will be supplied by
the token processor.

@$@<Delimiters@>+=@{@-
	$;([\040\t\n]*comment[^;]*;)?      (coordAdjust)	[SemiCmt]
	$begin([\040\t\n]+comment[^;]*;)?  (coordAdjust)	[BeginCmt]
@}

(@{\040@} must be used to represent a space within a regular expression
because @/any@/ white space terminates the expression.)

@$@<Token processors for comment delimiters@>+=@{@-
@<Define a token processor@>@(SemiCmt@)
{ *syncode = Semi; }

@<Define a token processor@>@(BeginCmt@)
{ *syncode = begin; }
@}

Both @{Semi@} and @{begin@} are easy to define with regular expressions
because they are self-delimiting.
The regular expression accepts horizontal tabs and newlines, and therefore the
auxiliary scanner @{coordAdjust@} must be used to adjust the coordinates
appropriately.

Comments following @{end@} are much harder to deal with because they can
@/not@/ contain certain strings.
It would be possible to write a regular expression that matched strings
ending in @{end@} or @{;@} or @{else@}, and then use an auxiliary scanner
to accept everything up to but not including that symbol.
The problem is that the scanner would then find the @/longest@/ such
string, and we need the @/shortest@/ such string.

Thus we need to use an auxiliary scanner to pick up the comment string
following an @{end@}:

@$@<Delimiters@>+=@{@-
	$end    (Algol60Comment)	[EndCmt]
@}

An auxiliary scanner is invoked after the associated regular expression has
been accepted.
In this case, @{Algol60Comment@} will be invoked after the normal scanner
has accepted the symbol @{end@}.

The auxiliary scanner is called with a pointer to the first character
matched by the regular expression and the length of the string matching the
regular expression; it should return a pointer to the first character that
does @/not@/ belong to the basic symbol being recognized.
Thus @{start@} should point to the @{e@} of @{end@}, @{length@} should be
3, and @{Algol60Comment@} should return a pointer to the next @{end@},
@{;@} or @{else@}.

The regular expression will match the characters @{e@}, @{n@} and @{d@}
in that order.
Since the scanner finds the longest match, the character following the
@{d@} cannot be a letter or a digit.
If it were, the scanner would combine it with the first three characters in
searching for an @{identifier@}.
The variable @{p@} is set to point to the character following the @{d@},
so after fetching that character to @{c@} and incrementing @{p@} the stated
loop invariant holds:

@$@<Comment Scanner@>+=@{@-
@<Define an Auxiliary Scanner@>@(Algol60Comment@)
{ char *p = start + length;
  char c = *p++;

  for (;;) {	/* Invariant:
		 *   c is neither a letter nor a digit &&
		 *   p points to the first unexamined character
		 * Bound: Number of characters left in the file
		 ***/

    if (c == ';') return p - 1;

    @<Adjust coordinates if necessary@>@(@)

    if (*p == 'e') {
        if (strncmp(p, "end", 3) == 0 && !isalnum(p[3]) ||
            strncmp(p, "else", 4) == 0 && !isalnum(p[4]))
          return p;
    }

    while (isalnum(c = *p++)) ;
  }
}
@}

If @{c@} is @{;@}, then the scan should be terminated and the position of
the semicolon returned.
Otherwise, any necessary adjustment of the coordinates to reflect a tab or
newline character must be made.

The first unexamined character, pointed to by @{p@}, could be anything.
If it is an @{e@}, then the routine checks for the
presence of one of the two keywords that can follow the comment.
Each of the specified character sequences must be followed by a
character other than a letter or digit if it is to be recognized as a
keyword.
When either of those keywords is found, the routine returns the position
of that keyword.
(Thus terminating the comment with the character preceding the keyword.)

Finally, the routine re-establishes the invariant of the outer loop.

The generated scanner keeps track of the line and column number of each
basic symbol, so that the processor can report errors at the appropriate
position in the source program.
Tab and newline characters require special action to maintain these values:

@$@<Adjust coordinates if necessary@>@(@1@)@M@{@-
if (c == '\t') StartLine -= TABSIZE(p - StartLine);
else if (c == '\n') {
  @<Refill the source buffer if necessary@>@(@1@)
  LineNum++;
  StartLine = p - 1;
}
@}

Character position within a line is the difference between the current
character index and the character index @{StartLine@}.
A tab character occupies one character position, but it may represent a
longer sequence, depending upon it's position in the line.
This additional white space is taken into account by moving @{StartLine@}
backwards.

The coordinate adjustment code is needed for processing strings (Section
2.6) as well.
These two cases differ in that it is an error for the file to end within a
string, but no error if the file ends within a comment.
If an end-of-file is an error, code to report that error must be
introduced.
That code is introduced through the parameter to the coordinate adjustment
description.

Source text is stored as a sequence of characters in memory, and the last
character of that sequence is guaranteed to be a newline.
If the character following a newline is the ASCII NUL character, then there
are no more characters in the sequence; otherwise, this newline is not the
last newline of the sequence.
Thus when the scanner reaches a newline, it must check whether that newline
is the last of the sequence in memory:

@$@<Refill the source buffer if necessary@>@(@1@)==@{@-
if (*p == '\0') {
  size_t pSave = p - start, sSave = p - StartLine;

  refillBuf(start); TokenStart = start = TEXTSTART;
  p = start + pSave; StartLine = start + sSave;

  if (*p == '\0') {
    @1
    return p - 1;
  }
}
@}

Recall that @{p@} points to the character following the newline.
If it is the ASCII NUL character, then there are no more characters of the
file stored in memory.
By calling @{refillBuf@} with @{start@} as an argument, the scanner
@/extends@/ the character sequence that begins at the location pointed to
by @{start@}.
Because of the way storage is allocated by the source
text input module, it may be necessary to move the sequence to another
location.
Thus @{TokenStart@} (the starting location of the basic symbol), @{start@},
and @{p@} must all be adjusted.
Finally, a check is made to see whether the character sequence was, in
fact, extended.
If it was not, then end-of-file has been reached,
the comment string has ended,
and the scanner terminates.

@$@<Token processors for comment delimiters@>+=@{@-
@<Define a token processor@>@(EndCmt@)
{ *syncode = end; }
@}

@B

@$@<Identifiers@>==@{@-
Identifier:	$@<letter@>(@<letter@>|@<digit@>)*	[mkidn]
@}

This regular expression is equivalent to the definition given in the
Revised Report.

Distinct identifiers must be distinguishable from one another.
The token processor @{mkidn@} assigns a unique integer value to each
distinct identifier.
This integer value can also be used to access the string representing the
identifier, and is stored as the value of the @{Sym@} attribute of symbols
representing identifier occurrences:

@$@<Internal representation of an identifier@>==@{@-
ATTR Sym: int;

CLASS SYMBOL IdentOcc COMPUTE SYNT.Sym = TERM; END;
@}

Identifiers have no inherent meaning, but serve for the identification of
simple variables, arrays, labels, switches, and procedures.

The same identifier cannot be used to denote two different quantities
except when these quantities have disjoint scopes as defined by the
declarations of the program:

@$@<Scope Violation Rules@>+=@{@-
SYMBOL MultDefChk INHERITS Unique COMPUTE
  IF(NOT(THIS.Unique),
    message(
      ERROR,
      CatStrInd("Identifier is multiply defined: ", THIS.Sym),
      0,
      COORDREF));
END;
@}

@{Unique@} and @{CatStrInd@} are exported by Eli library modules.

@$@<Instantiate modules to support MultDefChk@>==@{@-
$/Prop/Unique.gnrc :inst
$/Tech/Strings.specs
@}

@B@<Numbers@>

@C@<Syntax@>

@$@<unsigned integer@>@M@{@<digit@>+@}

This regular expression is equivalent to the definition given in the
Revised Report.

@$@<integer@>@M@{(@<unsigned integer@>|\+@<unsigned integer@>|-@<unsigned integer@>)@}

The @{+@} must be escaped because it is a regular expression operator.

@$@<decimal fraction@>@M@{\.@<unsigned integer@>@}

The @{.@} must be escaped because it is a regular expression operator.

Following standard practice, we represent the subscript 10 of the reference
language by the letter @{E@}:

@$@<exponent part@>@M@{(E|e)@<integer@>@}

By requiring a @{decimal number@} to contain a @{decimal fraction@},
we obtain distinct representations for @{integer@} and @{real@} constants:

@$@<decimal number@>@M@{(@<decimal fraction@>|@<unsigned integer@>@<decimal fraction@>)@}

We cannot allow an @{unsigned number@} consisting of only an @{exponent part@},
because there would be no way for the scanner to distinguish it from an
identifier (this is a consequence of our representing the subscript 10 of
the reference language by the letter @{E@}):

@$@<unsigned number@>@M@{(@<decimal number@>|@<decimal number@>@<exponent part@>)@}

We express the distinction between @{integer@} and @{real@} constants by
introducing the new basic symbol @{UnsignedReal@}, which does not appear in
the Revised Report:

@$@<Unsigned Numbers@>==@{@-
UnsignedInteger: $@<unsigned integer@>                                 	    [mkidn]
UnsignedReal:    $@<unsigned number@>|@<unsigned integer@>@<exponent part@> [mkidn]
@}

The token processor @{mkidn@} assigns a unique integer value to each
distinct numeric denotation.
(Note that distinct denotations may represent the same numeric value:
@{001@} has the same value as @{1@} and @{1.23E1@} has the same value as
@{12.3@}.)
This integer value can be used to access the denoting string.

An @{unsigned integer@} followed by an @{exponent part@} is legal
according to the Revised Report.
Because of the need to exclude @{unsigned integer@} from the definition of
@{decimal number@}, however, this case has to be treated specially.

@$@<Numbers@>==@{@-
UnsignedNumber ::= UnsignedInteger / UnsignedReal .
@}

The symbol @{number@} does not appear elsewhere in the Revised Report,
so it is not defined here.

@B@<Strings@>

The Revised Report's definition of a string allows
arbitrary nesting of character sequences delimited by @{`@} and @{'@}.
Such a structure cannot be described by a finite-state machine, and
therefore an auxiliary scanner must be used:

@$@<Strings@>==@{@-
String:		$`    (Algol60String)	[mkidn]
@}

@{Algol60String@} will be invoked after the normal scanner
has accepted the character @{`@}.

@$@<String Scanner@>==@{@-
@<Define an Auxiliary Scanner@>@(Algol60String@)
{ char *p = start + length;
  int counter = 1;

  		/* Invariant:
		 *   counter = number of unmatched open quotes
                 *   p points to the first unexamined character
                 * Bound: Number of characters left in the file
                 ***/
  while (counter) {
    char c = *p++;

    @<Adjust coordinates if necessary@>@(message(ERROR,"End-of-file in string",0,&curpos);@)

    if (c == '\'') counter--; else if (c == '`') counter++;
  }

  return p;
}
@}

@B@<Quantities, Kinds and Scopes@>

The following kinds of quantities are distinguished:
simple variables, arrays, labels, switches, and procedures.

@$@<Kinds of quantities@>==@{@-
typedef enum {
  UndefinedIdn,
  VariableIdn,
  ArrayIdn,
  LabelIdn,
  SwitchIdn,
  ProcedureIdn
} KindOfQuantity;
@}

@{UndefinedIdn@} is used to distinguish identifiers that are used but not
declared.
Every declared quantity is represented internally by a definition table key
under which the kind is stored as a property:

@$@<Property characterizing all quantities@>+=@{@-
Kind: KindOfQuantity;	"algol60.h"
@}

The kind of quantity may also be stored as an attribute of certain nodes,
and a dependence must be used to guarantee that all quantities have their
@{Kind@} properties set before any are queried:

@$@<Semantics@>+=@{@-
ATTR kind: KindOfQuantity;
@}

@B@<Values and Types@>

Certain syntactic units are said to possess values.
The various ``types'' (@{integer@}, @{real@}, @{Boolean@}) basically denote
properties of these values.

The Revised Report does not consider that labels and strings have values,
but this position is inconsistent with the fact that labels and strings can
be passed as parameters.
For uniformity, therefore, we specify operators
for labels and strings as well as for @{integer@}, @{real@} and @{Boolean@}
values.
These specifications result in the values @{labelType@} and
@{stringType@}, which we use to represent the ``types'' of labels and
strings.

Some procedures do not yield values, but may have side effects
on the state of the computation.
Our specifications of the operators characterizing these procedures
return a ``value'' of type @{voidType@}.

@$@<Type Attributes@>==@{@-
ATTR Type: DefTableKey;
@}

@A

The grammar given in the Revised Report is ambiguous.
Several changes were needed to eliminate the ambiguity; these will be
pointed out in the appropriate sections.

Because type information is required to distinguish arithmetic, Boolean and
designational expressions, we have merged the grammars for these three
kinds of expression.
Wherever possible, however, we have retained the nonterminal symbols used
in the Revised Report.

The Revised Report distinguishes various classes of identifier: variable
identifier, array identifier, switch identifier and procedure identifier.
Without information about how an identifier was declared, it is impossible
to make this distinction in all contexts.
We have therefore replaced some occurrences of the nonterminals variable
identifier, array identifier, switch identifier and procedure identifier
with the terminal @{Identifier@}.

@$@<Expressions@>==@{@-
@<Arithmetic Expressions@>
@<Boolean Expressions@>
@<Designational Expressions@>
@}

@B@<Variables@>

@C@<Syntax@>

A @{<variable identifier>@} in this context is an applied occurrence.
We use the symbol @{VarIdUse@} to play this role, which is quite different
from the defining occurrence appearing in Section 5.

Because the phrase structure cannot distinguish different types of
expression, we replace @{<arithmetic expression>@} here with @{Expression@}.
Similarly, @{<array identifier>@} is replaced with @{VarIdUse@}.

@$@<Variables@>==@{@-
VarIdUse ::= Identifier .
SimpleVariable ::= VarIdUse .
SubscriptExpression ::= Expression .
SubscriptList ::=
  SubscriptExpression /
  SubscriptList ',' SubscriptExpression .
SubscriptedVariable ::= VarIdUse '[' SubscriptList ']' .
Variable ::= SimpleVariable / SubscriptedVariable .
@}

@C

@$@<Equivalences@>+=@{@-
Variable ::= SimpleVariable SubscriptedVariable .
@}

@C

A variable is a designation given to a single value.
This value may be used in expressions for forming other values and may be
changed at will by means of assignment statements.
The type of the value of a particular variable is defined in the declaration
for the variable.

@{VarIdUse@} denotes an identifier that has a type property declared at its
defining occurrence, and therefore it plays the @{TypedUseId@} role in the
tree computation that verifies types.

@$@<Semantics@>+=@{@-
SYMBOL VarIdUse INHERITS TypedUseId END;
SYMBOL Variable COMPUTE
  SYNT.Sym=CONSTITUENT VarIdUse.Sym SHIELD SubscriptExpression;
  SYNT.Type=CONSTITUENT VarIdUse.Type SHIELD SubscriptExpression;
  SYNT.Key=CONSTITUENT VarIdUse.Key SHIELD SubscriptExpression <- THIS.Type;
  SYNT.kind=GetKind(THIS.Key,UndefinedIdn);
END;
@}

The @{Kind@} property of an identifier is guaranteed to be set if the
@{Type@} property of that variable is set, hence the dependence in  the
next-to-last line.

@C

Subscripted variables designate values which are components of
multidimensional arrays.
Each arithmetic expression of the subscript list occupies one subscript
position of the subscripted variable, and is called a subscript.
The complete list of subscripts is enclosed in the subscript brackets
@{[ ]@}.

This means that the identifier must denote an array or a switch, and the
number of subscripts must equal the number of dimensions.

@$@<Subscripts@>+=@{@-
ATTR dim, sub: int;

RULE: Variable ::= VarIdUse '[' SubscriptList ']' COMPUTE
  .kind=GetKind(VarIdUse.Key,UndefinedIdn) <- VarIdUse.Type;
  IF(AND(AND(NE(.kind,ArrayIdn),NE(.kind,UndefinedIdn)),NE(.kind,SwitchIdn)),
    message(ERROR,"Array or switch identifier required",0,COORDREF));

  .dim=GetDim(VarIdUse.Key,0) <- VarIdUse.Type;
  .sub=
    CONSTITUENTS SubscriptExpression.sub SHIELD SubscriptExpression
      WITH (int, ADD, IDENTICAL, ZERO);
  IF(AND(NE(.dim,0),NE(.dim,.sub)),
      message(ERROR,"Number of indices differs from dimension",0,COORDREF));
END;

RULE: SubscriptExpression ::= Expression COMPUTE
  SubscriptExpression.sub=1;
END;
@}

Each subscript position acts like a variable of type @{integer@} and the
evaluation of the subscript is understood to be equivalent to an
assignment to this fictitious variable.
Thus the subscript expression is considered a @{RootContext@} requiring an
integer value and allowing all type conversions defined for assignment.

@$@<Subscripts@>+=@{@-
RULE: SubscriptExpression ::= Expression COMPUTE
  RootContext(integerType,,Expression);
  Indication(ColonEqual);
END;
@}

@B@<Function Designators@>

@C@<Syntax@>

A @{<procedure identifier>@} in this context is an applied occurrence.
We use the symbol @{ProcIdUse@} to play this role, which is quite different
from the defining occurrence appearing in Section 5.

@$@<Function Designators@>+=@{@-
ProcIdUse ::= Identifier .
ActualParameter ::= String / Expression .
ParameterDelimiter ::= ',' / PDLetterString .
@}

The complex parameter delimiter must be treated as a basic symbol in order
to distinguish the letter string it contains from an identifier:

@$@<Parameter Delimiter Letter String@>==@{@-
PDLetterString : $\)[a-zA-Z]+:\(
@}

@$@<Function Designators@>+=@{@-
ActualParameterList ::=
  ActualParameter /
  ActualParameterList ParameterDelimiter ActualParameter .
@}

A @{FunctionDesignator@} with an empty @{ActualParameterPart@} cannot be
distinguished from a @{Variable@} in the absence of type information, so
we cannot allow an empty @{ActualParameterPart@} in this context.

@$@<Function Designators@>+=@{@-
ActualParameterPart ::= '(' ActualParameterList ')' .
FunctionDesignator ::= ProcIdUse ActualParameterPart .
@}

@C@<Equivalences@>

@C

Function designators define single numerical or logical values, which
result through the application of given sets of rules defined by a
procedure declaration to fixed sets of actual parameters.
Thus the @{ProcIdUse@} denotes an operator that is applied to a list of
operands and returns a value.

@$@<Semantics@>+=@{@-
SYMBOL FunctionDesignator  INHERITS ExpressionSymbol END;
SYMBOL ProcIdUse           INHERITS OperatorSymbol   COMPUTE
  SYNT.Indic=THIS.Key <- INCLUDING RootType.GotAllOpers;
END;
SYMBOL ActualParameterPart INHERITS OpndExprListRoot END;
SYMBOL ActualParameter     INHERITS OpndExprListElem END;

RULE: ActualParameter ::= String COMPUTE
  PrimaryContext(ActualParameter,stringType);
END;

RULE: ActualParameter ::= Expression COMPUTE
  TransferContext(ActualParameter,Expression);
END;

RULE: FunctionDesignator ::= ProcIdUse ActualParameterPart COMPUTE
  ListContext(FunctionDesignator,ProcIdUse,ActualParameterPart);
END;
@}

@C

Certain identifiers should be reserved for the standard functions of
analysis, which will be expressed as procedures.
The report specifically recommends the following, but does not preclude the
addition of others:

@$@<Standard Functions@>==@{@-
PreDefKey("abs",   absKey)
PreDefKey("sign",  signKey)
PreDefKey("sqrt",  sqrtKey)
PreDefKey("sin",   sinKey)
PreDefKey("cos",   cosKey)
PreDefKey("arctan",arctanKey)
PreDefKey("ln",    lnKey)
PreDefKey("exp",   expKey)
@}

@{PreDefKey@} is exported by an Eli library module.

@$@<Instantiate modules to pre-define identifiers@>==@{@-
$/Name/PreDefine.gnrc +referto=Identifier :inst
$/Name/PreDefId.gnrc +referto=(algol60.d) :inst
@}

The predefinition module requires that the specifications of predefined
identifiers be supplied in a file whose name is passed as the @{referto@}
parameter of the module's instantiation.
This file is defined above as the result of the Eli request
@{ALGOL60.fw:fwGen/algol60.d@}:

@N@<algol60.d@>==@{@-
@<Standard Functions@>
@<Transfer Functions@>
@}

Eli attaches no particular significance to the @{d@} suffix.
The file is also marked as a ``non-product'' file, which means that Eli
will not attempt to process it further in any event.
However, it is included in the collection of files available for reference
and is therefore accessible via the @{referto@} parameter of the @{inst@}
derivation.

The standard functions are understood to operate indifferently on arguments
both of type @{real@} and @{integer@}.
They will all yield values of type @{real@}, except for @{sign(E)@} which
will have values of type @{integer@}.

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  absKey(realType): realType;
  signKey(realType): integerType;
  sqrtKey,
  sinKey,
  cosKey,
  arctanKey,
  lnKey,
  expKey(realType): realType;
INDICATION
  absKey:    absKey;
  signKey:   signKey;
  sqrtKey:   sqrtKey;
  sinKey:    sinKey;
  cosKey:    cosKey;
  arctanKey: arctanKey;
  lnKey:     lnKey;
  expKey:    expKey;
@}

All of these operations are defined to apply to @{real@} operands.
In Section 5.1.3 we shall show how an integer value can be accepted
wherever the context requires a real value.

@C

It is understood that transfer functions between any pair of quantities and
expressions may be defined.
Among the standard functions it is recommended that there be one, namely,
@{entier(E)@}, which ``transfers'' an expression of real type to one of
integer type, and assigns to it the value which is the largest integer not
larger than the value of @{E@}.

@$@<Transfer Functions@>==@{@-
PreDefKey("entier",entierKey)
@}

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  entierKey(realType): integerType;
INDICATION
  entierKey: entierKey;
@}

@B@<Arithmetic Expressions@>

@C@<Syntax@>

We have replaced the integer division operator of the reference language
with the symbol @{div@} because of character set limitations.
As mentioned earlier, it is impossible to distinguish syntactically among
arithmetic, Boolean, and designational expressions.
We have therefore chosen to define the @{<if clause>@} and conditional
expression in Section 3.4.

@$@<Arithmetic Expressions@>+=@{@-
AddingOperator ::= '+' / '-' .
MultiplyingOperator ::= '*' / '/' / 'div' .
Primary ::=
  UnsignedNumber /
  Variable /
  FunctionDesignator /
  '(' Expression ')' .
Factor ::= Primary / Factor '^' Primary .
Term ::= Factor / Term MultiplyingOperator Factor .
SimpleArithmeticExpression ::=
  Term /
  '+' Term / '-' Term /
  SimpleArithmeticExpression AddingOperator Term .
@}

The Revised Report makes no syntactic distinction between the monadic and
dyadic versions of @{+@} and @{-@}.
Because this distinction is important for the semantics of the language,
we have made it by using literals for the monadic versions.

@C

The syntactic distinction between operators and among expressions is
necessary only to resolve operator precedence and association in text with
a minimum number of parentheses.

@$@<Equivalences@>+=@{@-
Binop ::= AddingOperator MultiplyingOperator .
Expression ::= SimpleArithmeticExpression Term Factor Primary UnsignedNumber .
@}

@C

An arithmetic expression is a rule for computing a numerical value.
The type of a number is known syntactically, and the type of a variable is
determined from the declaration.
Since the type is known directly, each of these is a primary context.
As we have seen in Section 3.2, a @{FunctionDesignator@} plays the
@{ExpressionSymbol@} role and therefore exchanges type information with the
@{Expression@} via a transfer context.

@$@<Semantics@>+=@{@-
RULE: Expression ::= UnsignedInteger COMPUTE
  PrimaryContext(Expression,integerType);
END;

RULE: Expression ::= UnsignedReal COMPUTE
  PrimaryContext(Expression,realType);
END;

RULE: Expression ::= Variable COMPUTE
  PrimaryContext(Expression,Variable.Type);
END;

RULE: Expression ::= FunctionDesignator COMPUTE
  TransferContext(Expression, FunctionDesignator);
END;
@}

@C@<Operators and Types@>

The constituents of
simple arithmetic expressions must be of types @{real@} or @{integer@}.
The meanings of the basic operators and the types of the expressions to
which they lead are given by the rules in this section.

The operators @{+@}, @{-@} and @{*@} have the conventional meaning
(addition, subtraction and multiplication).
The type of the expression will be @{integer@} if both of the operands are
of @{integer@} type, otherwise @{real@}:

@$@<Establish operator indications for source symbols@>+=@{@-
@<Set a monadic operator indication@>@(+@,Nop@)
@<Set a dyadic operator indication@>@(+@,Plus@)
@<Set a monadic operator indication@>@(-@,Neg@)
@<Set a dyadic operator indication@>@(-@,Minus@)
@<Set a dyadic operator indication@>@(*@,Star@)
@}

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  iNop,  iNeg(integerType):                                integerType;
  iiAdd, iiSubtract, iiMultiply(integerType, integerType): integerType;
  rNop,  rNeg(realType):                                   realType;
  rrAdd, rrSubtract, rrMultiply(realType, realType):       realType;
INDICATION
  Nop:   iNop, rNop;
  Plus:  iiAdd, rrAdd;
  Neg:   iNeg, rNeg;
  Minus: iiSubtract, rrSubtract;
  Star:  iiMultiply, rrMultiply;
@}

It is unnecessary to provide operators for all combinations of integer and
real operands because Section 5.1.3 implies that the compiler is allowed to
convert an integer value to a real value in an arithmetic expression
wherever the context requires it.

The source language operator symbols @{/@} and @{div@} both denote
division, to be understood as a multiplication of the left operand by the
reciprocal of the right operand.

@{/@} is defined for all four combinations of types @{real@} and
@{integer@} and will yield results of type @{real@} in any case.
The operator @{div@} is defined only for two operands both of type
@{integer@} and will yield a result of type @{integer@}:

@$@<Establish operator indications for source symbols@>+=@{@-
@<Set a dyadic operator indication@>@(/@,Slash@)
@<Set a dyadic operator indication@>@(div@,Div@)
@}

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  rrDiv(realType, realType):       realType;
  iiDiv(integerType, integerType): integerType;
INDICATION
  Slash: rrDiv;
  Div:   iiDiv;
@}

The source language operator symbols @{^@} denotes exponentiation:

@$@<Establish operator indications for source symbols@>+=@{@-
@<Set a dyadic operator indication@>@(^@,UpArrow@)
@}

The Report specifies that the result of raising an integer value to an
integer power has type @{integer@} if the exponent is positive and has type
@{real@} if the exponent is negative.
The fact that the @/type@/ of the result of an exponentiation depends
on the @/value@/ of one of the operands is a problem, because type is
considered to be a static property of the program in this specification.
We must therefore define a new type, @{arithType@} to handle this situation.

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  iiExp(integerType, integerType): arithType;
  riExp(realType,    integerType): realType;
  rrExp(realType,       realType): realType;
INDICATION
  UpArrow: iiExp, riExp, rrExp;
@}

A value of @{arithType@} type would have to be implemented by a structure
consisting of either an integer value or a real value and a flag specifying
the type of that value.
When using a value of @{arithType@} type as an operand, a run-time check
must be made to determine the actual type and select the appropriate code
to carry out the specified operation.

Applying a @{Uniop@} to a value of @{arithType@} type, or applying a
@{Binop@} to two values of @{arithType@} type, will always yield a value
of @{arithType@} type as a result.
In other cases, the result may be guaranteed to be of type @{real@}.
A value  of @{arithType@} type can always be converted into a value of type
@{real@} if the context requires it.
If the context requires an integer value, then either a value  of
@{arithType@} type can be converted to an integer or a run-time error can
be reported.
All of the possibilities are enumerated here:

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  aNop, aNeg(arithType):                                        arithType;
  aaAdd, aaSubtract, aaMultiply, aaExp(arithType, arithType):   arithType;
  aiAdd, aiSubtract, aiMultiply, aiExp(arithType, integerType): arithType;
  iaAdd, iaSubtract, iaMultiply, iaExp(integerType, arithType): arithType;
  arAdd, arSubtract, arMultiply, arExp(arithType, realType):    realType;
  raAdd, raSubtract, raMultiply, raExp(realType, arithType):    realType;
INDICATION
  Nop:     aNop;
  Plus:    aaAdd, aiAdd, iaAdd, arAdd, raAdd;
  Neg:     aNeg;
  Minus:   aaSubtract, aiSubtract, iaSubtract, arSubtract, raSubtract;
  Star:    aaMultiply, aiMultiply, iaMultiply, arMultiply, raMultiply;
  UpArrow: aaExp, aiExp, iaExp, arExp, raExp;
COERCION
  aiConvert(arithType): integerType;
  arConvert(arithType): realType;
@}

@B@<Boolean Expressions@>

@C@<Syntax@>

As noted earlier, it is impossible to decide syntactically whether a
variable should be a primary or a Boolean primary.
If we define a logical value as a Boolean primary, this introduces an
asymmetry in error reporting: use of a logical value in an arithmetic
context is a syntax error, but use of a Boolean variable in the same
context is a type error.
This asymmetry is avoided by defining a logical value as a primary rather
than a Boolean primary.

We used obvious representations for the operators that
are not available as ASCII characters:

@$@<Boolean Expressions@>==@{@-
Primary ::= LogicalValue .
RelationalOperator ::= '<' / '<=' / '=' / '>=' / '>' / '!=' .
Relation ::=
  SimpleArithmeticExpression RelationalOperator
  SimpleArithmeticExpression .
BooleanPrimary ::=
  SimpleArithmeticExpression /
  Relation .
BooleanSecondary ::= BooleanPrimary / 'not' BooleanPrimary .
BooleanFactor ::= BooleanSecondary /
                  BooleanFactor 'and' BooleanSecondary .
BooleanTerm ::= BooleanFactor / BooleanTerm 'or' BooleanFactor .
Implication ::= BooleanTerm / Implication '->' BooleanTerm .
SimpleBoolean ::= Implication / SimpleBoolean '==' Implication .
IfClause ::= 'if' Expression 'then' .
Expression ::=
  SimpleBoolean /
  IfClause SimpleBoolean 'else' Expression .
@}

@C

@$@<Equivalences@>+=@{@-
Binop ::= RelationalOperator .
Expression ::=
  SimpleBoolean Implication BooleanTerm BooleanFactor BooleanSecondary
  BooleanPrimary Relation LogicalValue.
@}

@C

A Boolean expression is a rule for computing a logical value.

@$@<Semantics@>+=@{@-
RULE: Expression ::= 'true' COMPUTE
  PrimaryContext(Expression,BooleanType);
END;

RULE: Expression ::= 'false' COMPUTE
  PrimaryContext(Expression,BooleanType);
END;
@}

@C@<Types@>

Variables and function designators entered as Boolean primaries must be
declared @{Boolean@}.
The expression typing is handled by the rules given in Section 3.3.3.

The @{Expression@} in an @{IfClause@} must yield a Boolean value.

@$@<Semantics@>+=@{@-
RULE: IfClause ::= 'if' Expression 'then' COMPUTE
  Expression.Required=BooleanType;
END;
@}

@C@<The Operators@>

Relations take on the value @{true@} whenever the corresponding relation is
satisfied for the expressions involved, otherwise @{false@}.

@$@<Establish operator indications for source symbols@>+=@{@-
@<Set a monadic operator indication@>@(not@,Not@)
@<Set a dyadic operator indication@>@(<@,Lt@)
@<Set a dyadic operator indication@>@(<=@,Le@)
@<Set a dyadic operator indication@>@(=@,Eq@)
@<Set a dyadic operator indication@>@(!=@,Ne@)
@<Set a dyadic operator indication@>@(>=@,Ge@)
@<Set a dyadic operator indication@>@(>@,Gt@)
@}

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  iiLT, iiLE, iiEQ, iiGE, iiGT, iiNE(integerType, integerType): BooleanType;
  rrLT, rrLE, rrEQ, rrGE, rrGT, rrNE(realType, realType):       BooleanType;
INDICATION
  Lt: iiLT, rrLT;
  Le: iiLE, rrLE;
  Eq: iiEQ, rrEQ;
  Ge: iiGE, rrGE;
  Gt: iiGT, rrGT;
  Ne: iiNE, rrNE;
@}

The logical operators always take values of type @{Boolean@} as operands
and yield values of type @{Boolean@} as results.

@$@<Establish operator indications for source symbols@>+=@{@-
@<Set a dyadic operator indication@>@(and@,And@)
@<Set a dyadic operator indication@>@(or@,Or@)
@<Set a dyadic operator indication@>@(->@,Implies@)
@<Set a dyadic operator indication@>@(==@,Equiv@)
@}

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  bNot(BooleanType): BooleanType;
  bAnd, bOr, bImplies, bEquiv(BooleanType, BooleanType): BooleanType;
INDICATION
  Not:     bNot;
  And:     bAnd;
  Or:      bOr;
  Implies: bImplies;
  Equiv:   bEquiv;
@}

@B@<Designational Expressions@>

@C@<Syntax@>

We do not allow unsigned integer labels because of an ambiguity that
arises when a designational expression is used as an actual parameter.
(This ambiguity was reported in ALGOL Bulletin No. 10, October, 1960.)

@$@<Designational Expressions@>==@{@-
Label ::= Identifier .
@}

Designational expressions do not appear in the syntax here because
their phrase structure is already covered by other forms of expression,
and they cannot be distinguished without type information.

@C@<Equivalences@>

@C

A designational expression is a rule for obtaining a label of a statement.

@$@<Semantics@>+=@{@-
RULE: DesignationalExpression ::= Expression COMPUTE
  Expression.Required=labelType;
END;
@}

@A@<Statements@>

@B@<Compound Statements and Blocks@>

@C@<Syntax@>

@$@<Compound Statements and Blocks@>==@{@-
UnlabelledBasicStatement ::=
  AssignmentStatement /
  GoToStatement /
  DummyStatement /
  ProcedureStatement .
BasicStatement ::= UnlabelledBasicStatement / Label ':' BasicStatement.
UnconditionalStatement ::= BasicStatement / CompoundStatement / Block .
Statement ::= UnconditionalStatement / ConditionalStatement / ForStatement .
CompoundTail ::= Statement 'end' / Statement ';' CompoundTail .
BlockHead ::= 'begin' Declaration / BlockHead ';' Declaration .
UnlabelledCompound ::= 'begin' CompoundTail .
UnlabelledBlock ::= BlockHead ';' CompoundTail .
CompoundStatement ::= UnlabelledCompound / Label ':' CompoundStatement .
Block ::= UnlabelledBlock / Label ':' Block .
Program ::= Block / CompoundStatement .
@}

@C

@$@<Equivalences@>+=@{@-
Statement ::=
  UnlabelledBasicStatement BasicStatement UnlabelledCompound CompoundStatement
  UnconditionalStatement .
@}

@C

Every block automatically introduces a new level of nomenclature.
This is realized as follows:
Any identifier occurring within the block may through a suitable
declaration be specified to be local to the block in question.
The behavior described in detail in the Revised Report is provided by the
@{RangeScope@} computational role, exported by the name analysis module.

@$@<Semantics@>+=@{@-
SYMBOL UnlabelledBlock INHERITS RangeScope END;
@}

@B@<Assignment Statements@>

@C@<Syntax@>

The nonterminals @{<arithmetic expression>@} and @{<Boolean expression>@}
must be replaced by @{Expression@},
in accordance with the changes made in Section 3.
Also, as discussed in Section 3, distinctions among identifiers are often
dropped.
Therefore there is only a single rule for @{LeftPart@} and a single rule
for @{AssignmentStatement@}:

@$@<Assignment Statements@>==@{@-
LeftPart ::= Variable ':=' .
LeftPartList ::= LeftPart / LeftPartList LeftPart .
AssignmentStatement ::= LeftPartList Expression .
@}

@C

@$@<Equivalences@>+=@{@-
Statement ::= AssignmentStatement .
@}

@C

Assignment statements serve for assigning the value of an expression to one
or several variables or procedure identifiers.

@$@<Semantics@>+=@{@-
RULE: LeftPart ::= Variable ':=' COMPUTE
  IF(AND(AND(AND(
      NE(Variable.kind,VariableIdn),
      NE(Variable.kind,ArrayIdn)),
      NE(Variable.kind,ProcedureIdn)),
      NE(Variable.kind,UndefinedIdn)),
    message(ERROR,"Illegal target of assignment :=",0,COORDREF));
END;
@}

Assignments to a procedure identifier may only occur within the body of a
procedure defining the value of a function designator.
This is checked by defining an @{InBody@} property for each procedure
identifier.
@{InBody@} has the value 0 outside of the procedure body and a nonzero
value within the body.
The inBody chain is used to control the value of @{InBody@}.

@$@<Semantics@>+=@{@-
RULE: LeftPart ::= Variable ':=' COMPUTE
  IF(AND(
      EQ(Variable.kind,ProcedureIdn),
      EQ(GetInBody(Variable.Key,0),0)<-LeftPart.inBody),
    message(
      ERROR,
      CatStrInd(
        "Assignment must be within the body of procedure ",
	Variable.Sym),
      0,
      COORDREF));
END;
@}

@C@<Types@>

The type associated with all variables and procedure identifiers of a left
part must be the same.

@$@<Verify type consistency of a left-part list@>==@{@-
RULE: LeftPartList ::= LeftPart COMPUTE
  LeftPartList.Type=LeftPart.Type;
END;

RULE: LeftPartList ::= LeftPartList LeftPart COMPUTE
  LeftPartList[1].Type=LeftPart.Type;
  IF(NE(LeftPartList[2].Type,LeftPart.Type),
    message(ERROR,"Type does not agree with previous variable",0,COORDREF));
END;

RULE: LeftPart ::= Variable ':=' COMPUTE
  LeftPart.Type=Variable.Type;
END;
@}

If this type is @{Boolean@}, the expression must likewise be @{Boolean@}.
If the type is @{real@} or @{integer@}, the expression must be arithmetic.
If the type of the arithmetic expression differs from that associated with
the variables and procedure identifiers, appropriate transfer functions are
understood to be automatically invoked.

@$@<Verify that an expression can be assigned to a left-part list@>==@{@-
RULE: Statement ::= LeftPartList Expression COMPUTE
  RootContext(LeftPartList.Type,,Expression);
  Indication(ColonEqual);
END;
@}

For transfer from @{real@} to @{integer@} type, the transfer function is
understood to yield a result equivalent to @{entier(E+0.5)@} where @{E@} is
the value of the expression.

@$@<Define operators and associate them with indications@>+=@{@-
OPER
  riRound(realType): integerType;
INDICATION
  ColonEqual: riRound;
@}

@B@<Go To Statements@>

@C@<Syntax@>

@$@<Go To Statements@>==@{@-
GoToStatement ::= 'go' 'to' DesignationalExpression .
@}

@C

@$@<Equivalences@>+=@{@-
Statement ::= GoToStatement .
@}

@C@<Semantics@>

A go to statement interrupts the normal sequence of operations, defined by
the write-up of statements, by defining its successor explicitly be the
value of a designational expression.
Thus the next statement to be executed will be the one having this value as
its label.

The @{jump@} operator is never used.
It serves merely to establish the @{labelType@}.

@$@<Define operators to establish types without values@>+=@{@-
OPER
  jump(labelType):voidType;
@}

@B

@$@<Dummy Statements@>==@{@-
DummyStatement ::= /*Empty*/ .
@}

@C

@$@<Equivalences@>+=@{@-
Statement ::= DummyStatement .
@}

@C@<Semantics@>

A dummy statement executes no operation.
It may serve to place a label.

@B

We have deleted the definition of
@{IfClause@}, which duplicates the one in Section 3,
and the definition of
@{UnconditionalStatement@}, which duplicates the one in Section 4.1.

@$@<Conditional Statements@>==@{@-
IfStatement ::= IfClause UnconditionalStatement .
ConditionalStatement ::=
  IfStatement /
  IfStatement 'else' Statement /
  IfClause ForStatement /
  Label ':' ConditionalStatement .
@}

@C

@$@<Equivalences@>+=@{@-
Statement ::= ConditionalStatement IfStatement .
@}

@C@<Semantics@>

No tree computations are required here.
The type of the expression in the @{IfClause@} is verified by the rule in
Section 3.4.4.

@B@<For Statements@>

@C@<Syntax@>

@{ArithmeticExpression@} and @{BooleanExpression@} can be recognized here
on the basis of context.

@$@<For Statements@>==@{@-
ArithmeticExpression ::= Expression .
BooleanExpression ::= Expression .
ForListElement ::=
  ArithmeticExpression /
  ArithmeticExpression 'step' ArithmeticExpression 'until' ArithmeticExpression /
  ArithmeticExpression 'while' BooleanExpression .
ForList ::= ForListElement / ForList ',' ForListElement .
ForClause ::= 'for' Variable ':=' ForList 'do' .
ForStatement ::= ForClause Statement / Label ':' ForStatement .
@}

@C

@$@<Equivalences@>+=@{@-
Statement ::= ForStatement .
@}

@C

A for clause causes the statement S which it precedes to be executed zero
or more times.
In addition it performs a sequence of assignments to its controlled
variable.
The syntax of the report constrains the controlled variable to be of
arithmetic type.

@$@<Semantics@>+=@{@-
RULE: ForClause ::= 'for' Variable ':=' ForList 'do' COMPUTE
  ForClause.Type=Variable.Type;
  IF(AND(
      NE(Variable.Type,integerType),
      NE(Variable.Type,realType)),
    message(ERROR,"Controlled variable must be arithmetic",0,COORDREF));
END;
@}

@C

The for list gives a rule for obtaining values that are consecutively
assigned to the controlled variable.
The value of each @{ArithmeticExpression@} must be assigned to the
controlled variable.

@$@<The for List Elements@>==@{@-
RULE: ArithmeticExpression ::= Expression COMPUTE
  RootContext(INCLUDING ForClause.Type,,Expression);
  Indication(ColonEqual);
END;

RULE: BooleanExpression ::= Expression COMPUTE
  Expression.Required=BooleanType;
END;
@}

@B@<Procedure Statements@>

@C@<Syntax@>

We have deleted the definitions of @{<actual parameter>@},
@{<parameter delimiter>@}, @{<actual parameter list>@} and
@{<actual parameter part>@}.
All of these nonterminals are defined in Section 3.2.
(See the discussion there concerning the ambiguity of a letter string that
is part of a parameter delimiter.)
In addition, @{<procedure identifier>@} is replaced by @{ProcIdUse@} in
order to capture the role of the identifier as an applied occurrence.

The nonterminal @{NoArgs@} is used to represent an empty argument list.

@$@<Procedure Statements@>==@{@-
ProcedureStatement ::= ProcIdUse NoArgs / ProcIdUse ActualParameterPart .
NoArgs ::= .
@}

@C

@{NoArgs@} is sematically equivalent to an argument list.
Using this equivalence simplifies the process of checking the argument list
against the formal parameters of the procedure invoked.

@$@<Equivalences@>+=@{@-
ActualParameterPart ::= NoArgs .
@}

@C

A procedure used in a procedure statement cannot return a value.

@$@<Semantics@>+=@{@-
SYMBOL ProcedureStatement INHERITS ExpressionSymbol COMPUTE
  INH.Required=voidType;
END;
@}

All formal parameters quoted in the value part of the procedure declaration
heading are assigned the values of the corresponding actual parameters,
these assignments being considered as being performed explicitly before
entering the procedure body.
The effect is as though an additional block embracing the procedure body were
created with the formal parameters declared as variables local to this
fictitious block.

@$@<Semantics@>+=@{@-
SYMBOL ValueParameter COMPUTE
  SYNT.GotValue=ResetIsValue(THIS.Key, 1);
END;
@}

@$@<Properties characterizing formal parameters@>==@{@-
IsValue:  int;
@}

@C

The actual parameter list of the procedure statement must have the same
number of entries as the formal parameter list of the procedure declaration
heading.
The correspondence is obtained by taking the entries of these two lists in
the same order.
Use of the correspondence is made when checking the restrictions stated in
Section 4.7.5.

@$@<Actual-Formal Correspondence@>+=@{@-
SYMBOL ActualParameterPart INHERITS ParameterDeListRoot END;
SYMBOL ActualParameter     INHERITS ParameterDeListElem END;

RULE: FunctionDesignator ::= ProcIdUse ActualParameterPart COMPUTE
  ActualParameterPart.ParameterList=
    GetFormals(ProcIdUse.Key,NULLParameterList)
    <- INCLUDING RootType.GotAllOpers;
END;

RULE: ProcedureStatement ::= ProcIdUse ActualParameterPart COMPUTE
  ActualParameterPart.ParameterList=
    GetFormals(ProcIdUse.Key,NULLParameterList)
    <- INCLUDING RootType.GotAllOpers;
END;
@}

@$@<Instantiate modules for list handling@>==@{@-
$/Adt/LidoList.gnrc +instance=Parameter +referto=algol60 :inst
@}

A parameter in this list is really a definition table key, although we
could make it a more complex value if necessary.

@$@<Parameter identification@>==@{@-
#include "deftbl.h"
#define NoParameter NoKey
typedef DefTableKey Parameter;
@}

The actual verification that the procedure is called with the right number
of arguments of the correct type is carried out during type analysis.

@C@<Restrictions@>

If a string is supplied as an actual parameter in a procedure statement or
function designator, whose defining procedure body is an ALGOL 60 statement
(as opposed to non-ALGOL code) then this string can only be used in the
procedure body as an actual parameter for further calls.
Ultimately it can only be used by a procedure body expressed in non-ALGOL
code.
Thus there is no operator that takes a string as an argument or delivers
one as a result, and we must create one in order to establish the
@{stringType@}.

@$@<Define operators to establish types without values@>+=@{@-
OPER
  pass(stringType):voidType;
@}

A formal parameter which occurs as a left part variable in an assignment
statement within the procedure body and which is not called by value
can only correspond to an actual parameter which is a variable.

@$@<Restrictions@>+=@{@-
ATTR IsAssigned, IsVariable: int;

SYMBOL             Variable      COMPUTE      INH.IsAssigned=0; END;
RULE: LeftPart ::= Variable ':=' COMPUTE Variable.IsAssigned=1; END;

SYMBOL Expression              COMPUTE       SYNT.IsVariable=0; END;
RULE:  Expression ::= Variable COMPUTE Expression.IsVariable=1; END;

SYMBOL VarIdUse COMPUTE
  SYNT.GotAssign=ResetIsAssigned(THIS.Key,INCLUDING Variable.IsAssigned);
END;

SYMBOL ROOTCLASS COMPUTE
  SYNT.GotProperties=CONSTITUENTS (VarIdUse.GotAssign,ValueParameter.GotValue);
END;

RULE: ActualParameter ::= Expression COMPUTE
  IF(AND(AND(
      GetIsAssigned(ActualParameter.ParameterElem,0),
      NOT(GetIsValue(ActualParameter.ParameterElem,0))),
      NOT(Expression.IsVariable)),
    message(ERROR,"Argument must be a variable",0,COORDREF))
  <- INCLUDING (ROOTCLASS.GotProperties);
END;
@}

@$@<Property to support Section 4.7.5.2 check@>==@{@-
IsAssigned: int;
@}

A formal parameter which is used within the procedure body as an array
identifier can only correspond to an actual parameter which is an array.

@$@<Restrictions@>+=@{@-
SYMBOL Expression             COMPUTE       SYNT.kind=UndefinedIdn;  END; 
RULE: Expression ::= Variable COMPUTE Expression.kind=Variable.kind; END;

RULE: ActualParameter ::= Expression COMPUTE
  IF(AND(
      EQ(GetKind(ActualParameter.ParameterElem,UndefinedIdn),ArrayIdn),
      NE(Expression.kind,ArrayIdn)),
    message(ERROR,"Argument must be an array",0,COORDREF));
END;
@}

A formal parameter which is called by value cannot in general correspond to
a switch identifier or a string, because these do not possess values.

@$@<Restrictions@>+=@{@-
SYMBOL ValueParameter INHERITS TypedUseId COMPUTE
  IF(EQ(GetKind(THIS.Key,UndefinedIdn),SwitchIdn) <- THIS.Type,
    message(
      ERROR,
      CatStrInd("Value parameter cannot be a switch identifier: ",THIS.Sym),
      0,
      COORDREF));
  IF(EQ(THIS.Type,stringType),
    message(
      ERROR,
      CatStrInd("Value parameter cannot be a string: ",THIS.Sym),
      0,
      COORDREF));
END;
@}

All formal parameters have restrictions on the type of the corresponding
actual parameter.
(This is a change from the Revised Report, discussed in Section 1.)

@$@<Restrictions@>+=@{@-
RULE: ProcedureStatement ::= ProcIdUse ActualParameterPart COMPUTE
  ListContext(ProcedureStatement,ProcIdUse,ActualParameterPart);
END;
@}

@A@<Declarations@>

Declarations serve to define certain properties of the quantities used in
the program, and associate them with identifiers.
A declaration of an identifier is valid for one block.
Outside the block the particular identifier may be used for other purposes.

@$@<Declarations@>==@{@-
Declaration ::=
  TypeDeclaration /
  ArrayDeclaration /
  SwitchDeclaration /
  ProcedureDeclaration .

@<Type Declarations@>
@<Array Declarations@>
@<Switch Declarations@>
@<Procedure Declarations@>
@}

Dynamically this implies the following: at the time of an entry to the
block (through the @{begin@}, since the labels inside are local and
therefore inaccessible from outside) all identifiers declared for the block
assume the significance implied by the nature of the declarations given.
If these identifiers had already been defined by other declarations outside
they are for the time being given a new significance.
Identifiers which are not declared for the block, on the other hand, retain
their old meaning.

At the time of an exit from the block (through @{end@} or by a go to
statement) all identifiers which are declared for the block lose their
local significance.

Eli captures this behavior in the @{IdUseEnv@} computational role
of the name analysis module.
The @{ChkIdUse@} computational role emits an error report if the identifier
has not been declared.

@$@<Scope Violation Rules@>+=@{@-
SYMBOL VarIdUse  INHERITS IdentOcc, IdUseEnv, ChkIdUse END;
SYMBOL ProcIdUse INHERITS IdentOcc, IdUseEnv, ChkIdUse END;
@}

Labels are implicitly declared by their appearance preceding a colon.
All other identifiers of a program must be explicitly declared.
No identifier may be declared more than once in any block head.

The @{IdDefScope@} computational role of the name analysis module provides
for identifier declaration.
@{MultDefChk@} was defined in Section 2.4 to report any identifier that is
defined more than once in a block head.

@$@<Scope Violation Rules@>+=@{@-
SYMBOL VarIdDef            INHERITS IdentOcc, IdDefScope, MultDefChk END;
SYMBOL ArrayIdentifier     INHERITS IdentOcc, IdDefScope, MultDefChk END;
SYMBOL ProcedureIdentifier INHERITS IdentOcc, IdDefScope, MultDefChk END;
SYMBOL Label               INHERITS IdentOcc, IdDefScope, MultDefChk END;
SYMBOL SwitchIdentifier    INHERITS IdentOcc, IdDefScope, MultDefChk END;
@}

@B@<Type Declarations@>

@C@<Syntax@>

The Revised Report defines the elements of a @{TypeList@} to be
@{SimpleVariable@}s.
This definition does not reflect the difference in semantics between
definition and use.
In order to expose that difference, we have used the symbol @{VarIdDef@}
here.
The effect of this definition is identical to that of the report, which
defines a @{<simple variable>@} as a @{<variable identifier>@} in Section
3.1.1.

@$@<Type Declarations@>==@{@-
VarIdDef ::= Identifier .
TypeList ::= VarIdDef / VarIdDef ',' TypeList .
Type ::= 'real' / 'integer' / 'Boolean' .
LocalOrOwnType ::= Type / 'own' Type .
TypeDeclaration ::= LocalOrOwnType TypeList .
@}

@C

@$@<Equivalences@>+=@{@-
Type ::= LocalOrOwnType .
@}

@C

Type declarations serve to declare certain identifiers to represent simple
variables of a given type.
The Eli @{Typing@} module's @{TypedDefinition@} role is played by the
@{TypeDeclaration@}, the symbol that represents a definition of one or more
simple variables.
Each of those variables plays the @{TypedDefId@} role.

The @{Type@} attribute of the symbol playing the @{TypedDefinition@} role
must be set by a user computation to the definition table key of the type.
No other user computations are needed.

@$@<Semantics@>+=@{@-
SYMBOL TypeDeclaration INHERITS TypedDefinition END;
SYMBOL VarIdDef        INHERITS TypedDefId      COMPUTE
  INH.GotProp=ResetKind(THIS.Key,VariableIdn);
END;

RULE: Type ::= 'real'    COMPUTE Type.Type=realType;    END; 
RULE: Type ::= 'integer' COMPUTE Type.Type=integerType; END; 
RULE: Type ::= 'Boolean' COMPUTE Type.Type=BooleanType; END;

RULE: TypeDeclaration ::= Type TypeList COMPUTE
  TypeDeclaration.Type=Type.Type;
END;
@}

In arithmetic expressions any position which can be occupied by a real
declared variable may be occupied by an integer declared variable.

@$@<Define an operator to be applied when needed@>+=@{@-
COERCION
  irConvert(integerType): realType;
@}

@B@<Array Declarations@>

@C@<Syntax@>

The nonterminal @{<arithmetic expression>@} is replaced by @{Expression@}
and array identifiers are not distinguished, as discussed in Section 3.

@$@<Array Declarations@>==@{@-
LowerBound ::= Expression .
UpperBound ::= Expression .
BoundPair ::= LowerBound ':' UpperBound .
BoundPairList ::= BoundPair / BoundPairList ',' BoundPair .
ArrayIdentifier ::= Identifier .
ArraySegment ::=
  ArrayIdentifier '[' BoundPairList ']' / ArrayIdentifier ',' ArraySegment .
ArrayList ::= ArraySegment / ArrayList ',' ArraySegment .
ArrayDeclaration ::= 'array' ArrayList / LocalOrOwnType 'array' ArrayList .
@}

@C@<Equivalences@>

@C

An array declaration declares one or several identifiers to represent
multidimensional arrays of subscripted variables and gives the dimensions
of the arrays, the bounds of the subscripts, and the types of the
variables.

All arrays declared in one declaration are of the same quoted type.
If not type declarator is given the type @{real@} is understood.

The Eli @{Typing@} module's @{TypedDefinition@} role is played by the
@{ArrayDeclaration@}, the symbol that represents a definition of one or more
subscripted variables.
Each of those variables plays the @{TypedDefId@} role.

@$@<Semantics@>+=@{@-
SYMBOL ArrayDeclaration INHERITS TypedDefinition END;
SYMBOL ArrayIdentifier  INHERITS TypedDefId      END;

RULE: ArrayDeclaration ::= Type 'array' ArrayList COMPUTE
  ArrayDeclaration.Type=Type.Type;
END;

RULE: ArrayDeclaration ::= 'array' ArrayList COMPUTE
  ArrayDeclaration.Type=realType;
END;
@}

The dimensions are given as the number of entries in the bound pair list.

@$@<Semantics@>+=@{@-
SYMBOL BoundPair COMPUTE SYNT.dim=1; END;

RULE: ArraySegment ::= ArrayIdentifier '[' BoundPairList ']' COMPUTE
  ArraySegment.dim=
    CONSTITUENTS BoundPair.dim WITH (int, ADD, IDENTICAL, ZERO);
  ArrayIdentifier.dim=ArraySegment.dim;
END;

RULE: ArraySegment ::= ArrayIdentifier ',' ArraySegment COMPUTE
  ArraySegment[1].dim=ArraySegment[2].dim;
  ArrayIdentifier.dim=ArraySegment[2].dim;
END;
@}

The declared dimensions are stored as the value of the @{Dim@} property of
the @{ArrayIdentifier@}.

@$@<Dimension property of an array@>==@{@-
Dim: int;
@}

The @{Dim@} and @{Kind@} properties of the variable must be available
whenever the type is available, which is guaranteed by making
@{ArrayIdentifier.GotProp@} dependent upon setting them.

@$@<Semantics@>+=@{@-
SYMBOL ArrayIdentifier COMPUTE
  INH.GotProp=
    ORDER(
      ResetDim(THIS.Key,THIS.dim),
      ResetKind(THIS.Key,ArrayIdn));
END;
@}

@C

Bound expressions will be evaluated in the same way as subscript
expressions (Section 3.1.4)

@$@<Lower upper bound expressions@>+=@{@-
RULE: LowerBound ::= Expression COMPUTE
  RootContext(integerType,,Expression);
  Indication(ColonEqual);
END;

RULE: UpperBound ::= Expression COMPUTE
  RootContext(integerType,,Expression);
  Indication(ColonEqual);
END;
@}

Bound expressions can only depend on variables and procedures which are
nonlocal to the block for which the array declaration is valid.

@$@<Lower upper bound expressions@>+=@{@-
ATTR InBoundExpr: int;

SYMBOL ROOTCLASS COMPUTE SYNT.InBoundExpr=0; END;
SYMBOL BoundPair COMPUTE SYNT.InBoundExpr=1; END;

SYMBOL AnyScope COMPUTE SYNT.Key=NewKey(); END;
SYMBOL Quantity COMPUTE
  SYNT.GotBlk=ResetBlock(THIS.Key,INCLUDING AnyScope.Key);
END;

SYMBOL VarIdDef            INHERITS Quantity END;
SYMBOL ArrayIdentifier     INHERITS Quantity END;
SYMBOL ProcedureIdentifier INHERITS Quantity END;

SYMBOL ROOTCLASS COMPUTE
  SYNT.GotBlks=CONSTITUENTS Quantity.GotBlk;
END;

SYMBOL VarIdUse COMPUTE
  IF(AND(AND(
      NE(GetKind(THIS.Key,UndefinedIdn),UndefinedIdn),
      INCLUDING (ROOTCLASS.InBoundExpr, BoundPair.InBoundExpr)),
      EQ(GetBlock(THIS.Key,NoKey),INCLUDING AnyScope.Key)),
    message(
      ERROR,
      CatStrInd("Local quantity in a bound expression: ",THIS.Sym),
      0,
      COORDREF));
END;
@}

@$@<Property to support Section 5.2.4.2 check@>==@{@-
Block: DefTableKey;
@}

@B@<Switch Declarations@>

@C@<Syntax@>

The nonterminal @{<designational expression>@} is replaced by
@{Expression@}, as discussed in Section 3.

@$@<Switch Declarations@>==@{@-
SwitchList ::= DesignationalExpression / SwitchList ',' DesignationalExpression .
SwitchIdentifier ::= Identifier .
SwitchDeclaration ::= 'switch' SwitchIdentifier ':=' SwitchList .
@}

@C@<Equivalences@>

@C

A switch declaration defines the set of values of the corresponding switch
designators.
These values are always labels, and the result is therefore a label.

@$@<Semantics@>+=@{@-
SYMBOL SwitchDeclaration INHERITS TypedDefinition COMPUTE
  SYNT.Type=labelType;
END;

SYMBOL SwitchIdentifier INHERITS TypedDefId COMPUTE
  INH.GotProp=
    ORDER(
      ResetKind(THIS.Key,SwitchIdn),
      ResetDim(THIS.Key,1));
END;
@}

@B@<Procedure Declarations@>

@C@<Syntax@>

If there are no formal parameters, the @{ValuePart@} and the
@{SpecificationPart@} must also be empty.
This is only one of several constraints on identifiers appearing in a
procedure heading that cannot be checked syntactically.
In order to support semantic checking, we need to distinguish the various
roles that identifiers play in procedure definition.
For example, we use the symbol @{ValueParameter@} to characterize an identifier
appearing in the @{ValuePart@}.

@$@<Procedure Declarations@>+=@{@-
FormalParameter ::= Identifier .
FormalParameterList ::=
  FormalParameter /
  FormalParameterList ParameterDelimiter FormalParameter .
FormalParameterPart ::= / '(' FormalParameterList ')' .
IdentifierList ::= ValueParameter / IdentifierList ',' ValueParameter .
ValueParameter ::= Identifier .
ValuePart ::= 'value' IdentifierList ';' / /*Empty*/ .
@}

The syntax of @{SpecificationPart@} in the report is ambiguous.
Also, we need to distinguish the role played by the identifiers in the
specification part: they constitute the type definitions of the formal
parameters.

@$@<Procedure Declarations@>+=@{@-
Specifier ::=
  'string' /
  Type /
  'array' /
  Type 'array' /
  'label' /
  'switch' /
  'procedure' /
  Type 'procedure' .
SpecificationPart ::= FormalSpecification* .
FormalSpecification ::= Specifier FormalIdList ';' .
FormalIdList ::= FormalParamIdTypeDef / FormalIdList ',' FormalParamIdTypeDef .
FormalParamIdTypeDef ::= Identifier .
@}

The grammar given in the Revised Report does not reflect
the scope rules of the language:
A procedure identifier is declared in the enclosing scope, and the formal
parameters are declared in the procedure body, but the grammar places both
in the @{<procedure heading>@} phrase.
We have therefore moved the procedure identifier to the procedure
declaration and defined a new nonterminal, @{ProcedureRange@}, that
is exactly the scope of the formal parameters described by Section 5.4.3
of the Revised Report:

@$@<Procedure Declarations@>+=@{@-
ProcedureIdentifier ::= Identifier .
ProcedureHeading ::= FormalParameterPart ';' ValuePart SpecificationPart .
ProcedureBody ::= Statement / Code .
ProcedureRange ::=
  ProcedureHeading ProcedureBody .
ProcedureDeclaration ::=
  'procedure' ProcedureIdentifier ProcedureRange /
  Type 'procedure' ProcedureIdentifier ProcedureRange .
@}

@C@<Equivalences@>

@C

A procedure declaration serves to define the procedure associated with a
procedure identifier.
The principal constituent of a procedure declaration is a statement or a
piece of code, the procedure body, which through the use of procedure
statements and/or function designators may be activated from other parts of
the block in the head of which the procedure declaration appears.
Associated with the body is a heading, which specifies certain identifiers
occurring within the body to represent formal parameters.
The scope of the formal parameters is the @{ProcedureRange@}.

@$@<Semantics@>+=@{@-
SYMBOL ProcedureRange INHERITS RangeScope END;
@}

We need to distinguish three roles that may be played in the heading by
those identifiers.

The @{FormalParamIdTypeDef@} is the defining occurrence of the formal
parameter's identifier.
As discussed earlier, we require that each formal parameter be given a type
in order to be able to determine the type of any expression.

A @{FormalParameter@} is an applied occurrence in the
@{FormalParameterPart@}.
It is used to determine the type of argument that will appear in a specific
position in the argument list of a call.

Finally, the @{ValueParameter@} is an applied occurrence in the value list.
It allows the analyzer to set the value property of the corresponding
formal parameter.

@$@<Semantics@>+=@{@-
SYMBOL FormalParamIdTypeDef INHERITS IdentOcc, IdDefScope, MultDefChk END;
SYMBOL FormalParameter      INHERITS IdentOcc, IdUseScope, ChkIdUse   END;
SYMBOL ValueParameter       INHERITS IdentOcc, IdUseScope, ChkIdUse   END;
@}

Formal parameters will, whenever the procedure is activated, be assigned
the values of or be replaced by actual parameters.
Thus the procedure plays the role of an operator with an operand list.
We also need the definition table keys of the formal parameters in order to
verify restrictions in Section 4.7.5.

@$@<Formal parameter key list@>==@{@-
Formals: ParameterList;	"ParameterList.h"
@}

@$@<Semantics@>+=@{@-
SYMBOL ProcedureDeclaration INHERITS OperatorDefs                 END;
SYMBOL FormalParameterPart  INHERITS OpndTypeListRoot, ParameterListRoot END;
SYMBOL FormalParameter      INHERITS OpndTypeListElem, TypedUseId,
                                     ParameterListElem COMPUTE
  SYNT.ParameterElem=THIS.Key;
END;

RULE: ProcedureDeclaration ::= 'procedure' ProcedureIdentifier ProcedureRange
COMPUTE
  ProcedureDeclaration.GotOper=
    ListOperator(
      ProcedureIdentifier.Key,
      NoOprName,
      CONSTITUENT FormalParameterPart.OpndTypeList,
      voidType);
  ProcedureIdentifier.GotProp=
    ORDER(
      ResetKind(ProcedureIdentifier.Key,ProcedureIdn),
      ResetFormals(
        ProcedureIdentifier.Key,
        CONSTITUENT FormalParameterPart.ParameterList));
END;

RULE: ProcedureDeclaration ::= Type 'procedure' ProcedureIdentifier ProcedureRange
COMPUTE
  ProcedureDeclaration.GotOper=
    ListOperator(
      ProcedureIdentifier.Key,
      NoOprName,
      CONSTITUENT FormalParameterPart.OpndTypeList,
      Type.Type);
  ProcedureIdentifier.GotProp=
    ORDER(
      ResetKind(ProcedureIdentifier.Key,ProcedureIdn),
      ResetFormals(
        ProcedureIdentifier.Key,
        CONSTITUENT FormalParameterPart.ParameterList));
END;
@}

@C

For a procedure declaration to define the value of a function designator
there must, within the procedure body, occur one or more assignment
statements with the procedure identifier in a left part.

This is checked by defining an @{InBody@} property for each procedure
identifier.
@{InBody@} has the value 0 outside of the procedure body and a nonzero
value within the body.
The @{inBody@} chain is used to control the value of @{InBody@}.

@$@<Values of Function Designators@>+=@{@-
CHAIN inBody: VOID;
ATTR InBody: int;

SYMBOL ROOTCLASS COMPUTE
  CHAINSTART HEAD.inBody=0;
END;

RULE: ProcedureDeclaration ::= 'procedure' ProcedureIdentifier ProcedureRange
COMPUTE
  ProcedureRange.inBody=
    ResetInBody(ProcedureIdentifier.Key,1) <- ProcedureDeclaration.inBody;
  ProcedureDeclaration.inBody=
    ResetInBody(ProcedureIdentifier.Key,0) <- ProcedureRange.inBody;
END;

RULE: ProcedureDeclaration ::= Type 'procedure' ProcedureIdentifier ProcedureRange
COMPUTE
  ProcedureRange.inBody=
    ResetInBody(ProcedureIdentifier.Key,1) <- ProcedureDeclaration.inBody;
  ProcedureDeclaration.inBody=
    ORDER(
      IF(NE(GetInBody(ProcedureIdentifier.Key,1),2),
        message(ERROR,"No assignment to the function designator",0,COORDREF)),
      ResetInBody(ProcedureIdentifier.Key,0)) <- ProcedureRange.inBody;
END;

RULE: LeftPart ::= Variable ':=' COMPUTE
  LeftPart.inBody=
    IF(NE(GetInBody(Variable.Key,0),0), ResetInBody(Variable.Key,2))
    <- LeftPart.inBody;
END;
@}

@$@<Properties characterizing function designators@>==@{@-
InBody: int;
@}

The type associated with the procedure identifier must be declared through
the appearance of a type declarator as the very first symbol of the
procedure declaration.

@$@<Values of Function Designators@>+=@{@-
SYMBOL ProcedureDeclaration INHERITS TypedDefinition END;
SYMBOL ProcedureIdentifier  INHERITS TypedDefId      END;

RULE: ProcedureDeclaration ::= 'procedure' ProcedureIdentifier ProcedureRange
COMPUTE
  ProcedureDeclaration.Type=voidType;
END;

RULE: ProcedureDeclaration ::= Type 'procedure' ProcedureIdentifier ProcedureRange
COMPUTE
  ProcedureDeclaration.Type=Type.Type;
END;
@}

@C

In the heading a specification part, giving information about the kinds and
types of the formal parameters by means of an obvious notation, @/must@/ be
included.
(Note that this is a change from the Revised Report, as discussed in
Section 1.)

@$@<Specifications@>+=@{@-
SYMBOL FormalSpecification  INHERITS TypedDefinition END;
SYMBOL FormalParamIdTypeDef INHERITS TypedDefId      COMPUTE
  INH.GotType=ResetKind(THIS.Key,INCLUDING FormalSpecification.kind);
END;

RULE: SpecificationPart LISTOF FormalSpecification END;

RULE: FormalSpecification ::= Specifier FormalIdList ';' COMPUTE
  FormalSpecification.Type=Specifier.Type;
  FormalSpecification.kind=Specifier.kind;
END;

RULE: Specifier ::= 'string' COMPUTE
   Specifier.Type=stringType;
   Specifier.kind=VariableIdn;
END;

RULE: Specifier ::= Type COMPUTE
   Specifier.Type=Type.Type;
   Specifier.kind=VariableIdn;
END;

RULE: Specifier ::= 'array' COMPUTE
   Specifier.Type=realType;
   Specifier.kind=ArrayIdn;
END;

RULE: Specifier ::= Type 'array' COMPUTE
   Specifier.Type=Type.Type;
   Specifier.kind = ArrayIdn;
END;

RULE: Specifier ::= 'label' COMPUTE
   Specifier.Type=labelType;
   Specifier.kind=LabelIdn;
END;

RULE: Specifier ::= 'switch' COMPUTE
   Specifier.Type=labelType;
   Specifier.kind=SwitchIdn;
END;

RULE: Specifier ::= 'procedure' COMPUTE
   Specifier.Type=voidType;
   Specifier.kind=ProcedureIdn;
END;

RULE: Specifier ::= Type 'procedure' COMPUTE
   Specifier.Type=Type.Type;
   Specifier.kind = ProcedureIdn;
END;
@}

Neither the @{FormalParameterPart@} nor the @{ValuePart@} may contain
repeated identifiers.

@$@<Instantiate additional modules for uniqueness checks@>==@{@-
$/Prop/Unique.gnrc +instance=Formal :inst
$/Prop/Unique.gnrc +instance=Value  :inst
@}

@$@<Specifications@>+=@{@-
SYMBOL FormalParameter INHERITS FormalUnique COMPUTE
  IF(AND(NOT(THIS.FormalUnique),NE(THIS.Key,NoKey)),
    message(
      ERROR,
      CatStrInd("Repeated formal parameter: ",THIS.Sym),
      0,
      COORDREF));
END;

SYMBOL ValueParameter INHERITS ValueUnique COMPUTE
  IF(AND(NOT(THIS.ValueUnique),NE(THIS.Key,NoKey)),
    message(
      ERROR,
      CatStrInd("Repeated value parameter: ",THIS.Sym),
      0,
      COORDREF));
END;
@}

There must be a formal parameter for every specification.

@$@<Specifications@>+=@{@-
SYMBOL ProcedureHeading COMPUTE
  IF(
      NE(
        CONSTITUENTS FormalParameter.Sym       WITH (int, ADD, ARGTOONE, ZERO),
        CONSTITUENTS FormalParamIdTypeDef.Sym  WITH (int, ADD, ARGTOONE, ZERO)),
    message(ERROR,"Fewer formals than specifications",0,COORDREF));
END;
@}

@C

It is understood that the procedure body may be expressed in non-ALGOL
language.
Since it is intended that the use of this feature should be entirely a
question of the hardware representation, the Revised Report gives no
further rules concerning this code language.

We have chosen to define @{Code@} as a body of text enclosed in braces,
possibly with nested text of the same form.
A C procedure body or compound statement takes this form, which is
recognized by the @{Ctext@} auxiliary scanner from the Eli library:

@$@<Code as Procedure Body@>==@{@-
Code:	$\{	(Ctext)	[mkstr]
@}

The @{{@} must be escaped because it is a regular expression operator.

The token processor @{mkstr@} assigns a unique integer value to each code
body regardless of its content.
This integer value can be used to access the code body.
