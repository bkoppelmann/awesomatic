/*  macro definitions for fast/full-table  C/FTL programs generated by flex */
/* $Id: fastskeldef.h,v 1.2 1989/02/23 15:20:12 bob Exp $ */

#include "flexskelcom.h"

#define YY_END_OF_BUFFER_CHAR 0

/* action number for "not an accepting state; back-track (not implemented)" */
#define YY_BACK_TRACK 0

/* action number for end-of-buffer was seen */
#define YY_END_OF_BUFFER -3

/* reinitializes everything except the current start condition.  The last
 * input character is set to a newline so an initial beginning-of-line
 * rule will match
 */
#define YY_FAST_INIT \
	{ \
	yytext = yy_c_buf_p = &yy_ch_buf[1]; \
	yyleng = 0; \
	yy_hold_char = *yy_c_buf_p; \
	}

/* done before the next pattern has been matched action
 * change both of these if you change them at all!
 */
#define YY_DO_BEFORE_SCAN \
	*yy_c_buf_p = yy_hold_char
#define YY_DO_BEFORE_RESTART \
	yy_hold_char = *yy_c_buf_p

/* done after the current pattern has been matched and before the
 * corresponding action
 */
#define YY_DO_BEFORE_ACTION \
	yytext = yy_b_buf_p; \
	yyleng = YY_LENG; \
	yy_hold_char = *yy_c_buf_p; \
	*yy_c_buf_p = '\0'

/* returns the length of the matched text */
#define YY_LENG (yy_c_buf_p - yy_b_buf_p)

#ifdef FLEX_FULL_TABLE
#define YY_CS_TYPE int
#else
#define YY_CS_TYPE struct yy_trans_info *
#endif

/* find starting state */
#ifdef FLEX_FULL_TABLE
#    define YY_FIND_START_STATE( x ) \
	    x = yy_start; \
	    if ( yy_b_buf_p[-1] == '\n' ) \
		++x
#else
#    define YY_FIND_START_STATE( x ) \
	    x = yy_state_ptr[yy_start]; \
	    if ( yy_b_buf_p[-1] == '\n' ) \
		x = yy_state_ptr[yy_start + 1]
#endif

# ifdef FLEX_USE_ECS
#     define yy_eq(x) e[x]
# else
#     define yy_eq(x) x
# endif

/* get next jam state from packed table */
#ifdef FLEX_FULL_TABLE
#    define YY_FIND_NEXT_MATCH \
	    { \
	    register int yy_state_info; \
	    while ( (yy_state_info = n[yy_current_state][yy_eq(*yy_c_buf_p)] ) != YY_JAM ) \
		{ \
		yy_current_state = yy_state_info; \
		YY_BACKTRACKING_ACTION(yy_current_state,yy_c_buf_p) \
		yy_c_buf_p++; \
		} \
	    }
#else
#    define YY_FIND_NEXT_MATCH \
	    for ( yy_c = yy_eq(*yy_c_buf_p); \
		  (yy_trans_info = &yy_current_state[yy_c])->v == yy_c; \
		  yy_c = yy_eq(*++yy_c_buf_p) ) \
		{ \
		yy_current_state += yy_trans_info->n; \
		YY_BACKTRACKING_ACTION(yy_current_state,yy_c_buf_p) \
		}
#endif

#ifdef FLEX_FULL_TABLE
#    define YY_FIND_ACTION( x ) x = l[yy_current_state]
#else
#    define YY_FIND_ACTION( x ) x = yy_current_state[-1].n
#endif


#ifdef FLEX_FULL_TABLE
#    define YY_GET_NEXT_STATE \
      { \
      yy_cur_state = n[yy_cur_state][yy_eq(*yy_temp_char_ptr)]; \
      YY_BACKTRACKING_ACTION(yy_cur_state,yy_temp_char_ptr) \
      ++yy_temp_char_ptr; \
      }
#else
#    define YY_GET_NEXT_STATE \
      { \
      yy_cur_state += yy_cur_state[yy_eq(*yy_temp_char_ptr)].n; \
      YY_BACKTRACKING_ACTION(yy_cur_state,yy_temp_char_ptr) \
      ++yy_temp_char_ptr; \
      }
#endif

#define EOB_ACT_RESTART_SCAN 2
#define EOB_ACT_END_OF_FILE 3
#define EOB_ACT_LAST_MATCH 4

#ifdef FLEX_FULL_TABLE
#define YY_DECLARE_YY_CS_PARAM int *yy_current_state
#else
#define YY_DECLARE_YY_CS_PARAM struct yy_trans_info *yy_current_state
#endif
