\input texinfo    @c -*-texinfo-*-
@comment %**start of header (This is for running Texinfo on a region.)
@setfilename refcard
@settitle Quick Reference Card
@comment %**end of header (This is for running Texinfo on a region.)
@comment $Id: EliRefCard.tnf,v 1.4 1996/04/09 14:14:30 mjung Exp $


@iftex 
@finalout
@end iftex

@node top, , , (dir)

@ifinfo
@titlefont{Eli Quick Reference Card}
@end ifinfo

@menu
* Products::    Products and Parameters.
* Specs::       Eli Specifications.
* UI::          User Interface.
@end menu

@comment *********************************************************************
@node Products, Specs, , top
@comment  node-name,  next,  previous,  up
@chapter Products and Parameters .
@comment *********************************************************************

A product (e.g.: @code{:exe}) is a Unix file, a directory or a list of
files that can be requested from Eli. Parameters (e.g.: @code{+fold})
allow the requestor to control some characteristics of the requested
product. 

Product files can be displayed by appending @code{>}, file-lists
can be viewed with @code{:viewlist} and generated directories by listing
their contents with @code{!ls}.
A single file named @samp{f} can be selected from a directory by
appending @code{/f} to the request for that directory.

@noindent
For further details see @ref{top, Products, , pp, Eli Products and
Parameters}.

@section Processor Generation

@table @code
@item :exe
Executable file containing the generated processor.

@item :source 
File-List with all source and include files making up the processor.

@item :allspecs 
File-List with all files defining a processor.

@item :gencode 
File-List with all files generated by Eli from your specifications.

@item :fwGen 
Directory with all files specified by one .fw file.

@item :ligaResults 
File-List with all files generated by Liga from your specifications.

@item +define 
cpp directive for C compilation.

@item +fold 
To suppress case distinctions in identifiers and keywords.

@item +ignore 
To switch off the verification of the presence of certain include files.

@item +parser 
Selects the parser generator:pgs/cola.
@end table


@section Generating Specifications

@table @code
@item :bnf 
File containing complete concrete grammar in BNF notation.

@item :consyntax 
File containing complete concrete grammar in EBNF notation.

@item :pgram
File containing complete parsing grammer as given to the parser generator.

@item :abstree 
File containing complete tree grammar.

@item :inst 
File-List containing instantiated generic module.

@item :kwd 
Recognize specified literals as identifiers.

@item +instance, +referto 
For instantiation of specification modules.
@end table


@section Diagnostics

@table @code
@item :warning
File containing Warnings noted while deriving a product.

@item :error
File containing Errors noted while deriving a product.

@item :warn, :err 
Unprocessed warning and error messages.

@item :help
Executable for browsing Warning and error messages of a derivation.
Messages contain references to documentation.

@item :parsable 
File containing verification protocol of the parsability of the 
parsing grammar (LALR(1)).

@item :showFe, :showMe 
File-List with 3 files containing information about the Lido specifications.

@item :ExpInfo,:OrdInfo,:OptimInfo 
Files with Information from Liga on remote attribute access, attribute
dependencies, attribute storage.

@item :gorto 
Start @code{gorto}, a graphical tool for attribute dependence analysis.
@end table

@section Testing a Generated Processor

@table @code
@item :stdout 
Standard output from a test run, for example
@example
   input +cmd=(x.specs:exe):stdout
@end example

@item :run 
Execute the generated processor, for example
@example
   . +cmd=(x.specs:exe) input :run
@end example

@item :output 
Output files from a test run, for example
@example
   input +cmd=(x.specs:exe) :output !ls -l
@end example

@item :dbx, :gdb 
Debug a program interactively at the source level.

@item :mon 
Monitor a program at the specification level.

@item :mondbx, :mongdb 
Monitor a program at the specification level.

@item +arg 
Command line arguments for processor execution (only usable with @code{:mon})

@item +debug 
Flag to request debugging information in object files.

@item +input 
Directory containing files to be made available during execution.

@item +monitor 
Flag to request monitoring support.

@item +printtokens 
Flag to request that tokens be printed as they are read.

@item +stdin 
File to be made available as standard input.
@end table



@section Producing Formatted Documents

@table @code
@item :ps 
PostScript file generated from a TeX file.

@item :fwTex 
TeX file generated from a .fw file.

@item :fwTexinfo 
Hypertext document generated from a .fw file.
@end table


@section Information About the Derivation

@table @code
@item !:redo 
Tell Eli to redo a derivation step, even though no inputs to it have
changed.

@item !:test 
Ask Eli to check whether an object has been modified.

@item !:inputs 
A list of the objects on which this object directly depends.

@item !:outputs 
A list of the objects directly depending on this object.
@end table


@comment *********************************************************************
@node Specs, UI, Products, top
@comment  node-name,  next,  previous,  up
@chapter Eli Specifications
@comment *********************************************************************


The Eli user describes the subproblems of a particular text processing
problem in files of different ``type''.  The type is indicated by the
file name extension.  Any of these files can contain C-style comments
and preprocessor directives such as @code{#include}, @code{#define}
and @code{#ifdef}.


@table @code
@item .specs 
A collection of subproblem descriptions, one per line:

@example
word.gla
$/Tool/lib/Name/Nest.gnrc :inst
symbol.lido
@end example

@item .gla 
A description of the token structure of the input text:

@example
ident : C_IDENTIFIER
string: $' (auxPascalString) [mkstr]
numb  : $[0-9] [mkint]
@end example


@item .con 
A description of the phrase structure of the input text:
  
@example
def: set_name '=' '@{' body '@}' .
body: element+ .
cond : 'if' exp 'then' stmt $'else'.
@end example

@item .lido
A description of the structure of a tree and the computations to be
carried out on that tree:

@example
ATTR Sym: int;
SYMBOL set_name INHERITS Entity END;
SYMBOL text COMPUTE 
  PTGOut(
    PTGTable(
      CONSTITUENTS set_name.Sym 
          WITH (int, ADD, ONE, ZERO)));
END;
RULE r_wall: wallspec ::= 'wall' pos ';'
COMPUTE 
  wallspec.done = setwall(pos.x, pos.y);
END;
@end example
    

@item .map 
A description of the mapping between the parsing and the tree grammar.

@item .ctl 
Options for evaluator generation.

@item .h, .c 
C modules for user-supplied functions, variables, types etc.

@item .head 
Headers and macro definitions to be inserted into code generated from
Lido:
  
@example
#include "myproc.h"
#define MyValue(s) MyArray[s]
@end example

@item .init, .finl 
C code to be executed before any processing begins (.init) or after all
other processing is complete (.finl):
  
@example
@{ int s;
  s = GetValue(speed,1);
  setdelay(1000000/s);   @}
@end example

@item .ptg 
A description of structured output text:  

@example
Seq: $ $
List: $ ",\n\t" $
@end example

@item .pdl 
A property definition language:  

@example
code : mytype; "kcode.h"
size : int;
@end example

@item .oil 
A description of operator overloading:  

@example
OPER iAdd(integer, integer): integer;
OPER rAdd(real, real): real;
INDICATION Plus: iAdd, rAdd, sUnion;
COERCION Float(integer): real;
@end example


@item .clp 
A description of command line arguments for the generated processor:

@example
speed "-s" int 
"-s determines steps per second";
@end example


@item .fw 
Combines a collection of strongly-coupled specifications with
documentation describing their relationships:
  
@example
@@O@@<c.ptg@@>@@@{
Seq:   $ $
@@@}
@@O@@<c.lido@@>@@@{
SYMBOL Entity INHERITS IdPtg END;
@@@}
@end example


@item .delit 
Specifies literals appearing in a type-`con' file that are to be
recognized by special routines.

@item .gnrc 
Defines a generic specification module.
@end table

@comment *********************************************************************
@node UI, , Specs, top
@comment  node-name,  next,  previous,  up
@chapter User Interface
@comment *********************************************************************


Single characters are quoted with @code{\} in an Eli request; strings
are quoted by enclosing them in apostrophes (').  Spaces and tabs are
ignored, and @code{#} marks the rest of the line as a comment. The
request @code{?} starts the documentation browser.

@noindent
For further details see @ref{top, User Interface, , ui, Interacting with
Eli}.


@table @code
@item object 
Make a product up-to-date with respect to its inputs.

@example
x.specs+monitor:exe # Make up-to-date
x.specs:parsable<   # To your editor
x.specs>            # To standard output
x.specs:exe>x.exe   # To file x.exe
x.specs:source>src  # To directory src
@end example

@item ! 
Execute the remainder of the line as a shell command.  If @code{!} is preceded
by @code{object}, append the name of the up-to-date product to the end of the
line.

@item = 
Query or set variables.


@example
?=         # Show list of all variables.
Dir=?      # Show `Dir' variable meaning.
History=   # Show the value of `History'.
ErrLevel=1 # Set `ErrLevel' to `1'.
@end example
  

@item control character 
Request editing with history.  Starred commands accept a repeat count
(e.g. `+ESC 4 ^P+').  Arrow keys can be used to move in the history.


@example
^A   Move to the beginning of the line

^B*  Move left in the line (left arrow)

^E   Move to the end of the line

^F*  Move right in the line(right arrow)

^N*  Next request in history (down arrow)

^P*  Previous request in history (up arrow)

^R*  Request a substring to search for
     String starts line if it begins with @code{^}
     Search forward if repeat count given
@end example

@end table
@contents
@bye 


