\input texinfo   @c -*-texinfo-*-
@comment Copyright, 1996, The Regents of the University of Colorado
@comment %**start of header
@setfilename novice
@settitle Guide for New Eli Users
@setchapternewpage odd
@comment %**end of header

@titlepage
@center @titlefont{Guide for New Eli Users}
@sp 1
@center $Revision: 3.13 $
@include org.tnf
@end titlepage

@iftex
@finalout
@end iftex

@node    Top,       ,     ,         (dir)
@comment node-name, next, previous, up

@ifinfo
$Revision: 3.13 $
@end ifinfo

A text processor is a program that takes a sequence of
characters as input, computes some set of values based on that sequence, and
then carries out some action determined by the computed values.
A desk calculator program is therefore a text processor,
as is a Pascal compiler and the input subsystem of a transaction processor.

The Eli system creates executable text processing programs from
specifications.
A user provides Eli with specifications that describe a particular text
processing problem, and Eli creates a program to solve that problem.
By making simple requests of Eli, the user can test the generated program,
obtain an executable copy, or obtain a directory containing a source copy.

@iftex
This manual is intended for the new Eli user.
It begins with a general characterization of text processing problems.
The emphasis is on a strategy for decomposing such problems and describing
their components, but an indication of how Eli builds working software from
these descriptions is also included.

The simplest way to understand a system is to see how it is used.
We therefore present a concrete text processing problem and show, step by
step, how a program to solve it is specified and produced.
Each component of the specification is discussed, and exercises provided to
lead you through the production process.
The text of the specification is part of the Eli distribution.

As with any complex system,
there are ways to customize Eli to fit particular working styles.
We therefore describe some of the common things that you might want to do
to change Eli's behavior in order to fit your working style.

Finally, we give an overview of the Eli documentation.
@end iftex

@menu
* Overview::		How Eli creates a text processing program
* Specifications::	  Ways to describe text processing
* Products::		  Ways to describe derived objects
* Interactive::		  Ways to request product manufacture
* Escape::		  Ways to invoke unix commands

* Example::		Illustration of Eli usage
* Problem::		  Statement of the problem to be solved
* Structure::		  Specifying the desired phrase structure
* Atoms::		  Nonliteral character sequences and comments
* Entities::		  Managing source text definitions
* Generation::		  Creating structured output text

			Exercises involving the Eli example
* tskex::		  Getting the sample specification
* parex::		  How to verify parsability of a grammar
* procex::		  How to generate a processor
* symbex::		  How to extract a processor from Eli
* debugex::		  How to debug Eli-generated C code

* Strategies::		Ways to alter Eli's behavior
* Cache::		  Hints on Cache Management
* Session::		  Hints on Session Management

* Documentation::	How to access system documentation

* Index::		Index to this manual.
@end menu

@node    Overview,  Example,  ,         Top
@comment node-name, next,     previous, up
@chapter How Eli Creates a Text Processing Program

The program generated by Eli
@findex generated program, characteristics
reads a file containing the text, examining it character-by-character.
Character sequences are recognized as significant units or discarded, and
relationships among the sequences are used to build a tree that
reflects the structure of the text.
Computations are then carried out over the tree, and the results of these
computations determine the processor's output.
Thus Eli assumes that the original text processing problem is decomposed into
the problems of determining
which character sequences are significant and which should be discarded,
what tree structure should be imposed on significant sequences,
what computations should be carried out over the resulting tree, and
how the computed values should be encoded and output.

@iftex
A user describes a particular text processing problem to Eli
by specifying the characteristics of its subproblems.
For example, the tree structure that should be imposed on significant
character sequences is specified to Eli by providing a context-free
grammar.
Different subproblems are characterized in different ways, and they are
specified by descriptions written in different languages.
Those specifications are processed by a variety of tools,
which verify their consistency and generate C-compatible C++ code
to solve the specified subproblems.

Eli focuses the user's attention on specification by
automating the process of tool invocation.
It responds to a request for a piece of computed information, called a
@dfn{derived object}, by invoking the minimum number of tools necessary to
produce that information.
Derived objects are automatically stored by Eli for later re-use,
significantly improving the response time for subsequent requests.

This chapter provides
an overview of the most important subproblems and how they can be described,
summarizes the available descriptive mechanisms and explains the most
common derived objects,
and indicates how Eli is used to create and test programs.
@end iftex

@menu
* Subproblems::		How to decompose a text processing problem
* Specifications::	Descriptive mechanisms known to Eli
* Products::		Common products that Eli can manufacture
* Interactive::		How to request product manufacture
* Escape::		How to invoke unix commands
@end menu

@node    Subproblems, Specifications, ,         Overview
@comment node-name,   next,           previous, up
@section How to Decompose a Text Processing Problem

There is considerable variability in the specific decompositions
@findex decomposition
for particular text processing problems.
For example, one subproblem
@findex subproblem
of the compilation problem for many programming
languages is @emph{overload resolution}:
@findex overload resolution
how to decide that (say) a
particular @code{+} operator means integer addition instead of real addition.
Overload resolution would probably not be a subproblem of the problem of
creating a PostScript version of a musical score from a description of the
desired notes.
This section briefly reviews five major subproblems common to a wide range of
problems:

@menu
* Syntactic analysis::	Determining the structure of an input text
* Lexical analysis::	Recognizing character sequences
* Attribution::		Computing values over trees
* Property storage::	Maintaining information about entities
* Text generation::	Producing structured output
@end menu

@iftex
@table @asis
@item Syntactic analysis
Determining the structure of an input text

@item Lexical analysis
Recognizing character sequences

@item Attribution
Computing values over trees

@item Property storage
Maintaining information about entities

@item Text generation
Producing structured output
@end table
@end iftex

@node    Syntactic analysis, Lexical analysis, ,         Subproblems
@comment node-name,          next,             previous, up
@ifinfo
@subsubsection Determining the structure of an input text
@end ifinfo

@dfn{Syntactic analysis}
@findex syntactic analysis
determines the @dfn{phrase structure}
@findex phrase structure
of the input text.
The phrase structure is described to Eli by a @dfn{context-free grammar}.
@findex context-free grammar
Here is a context-free grammar
@findex context-free grammar
describing the structure of a geographical position
(@pxref{Phrases, , Context-Free Grammars and Parsing, syntax, Syntactic
Analysis}):

@example
Position: Latitude Longitude .
Latitude: NS Coordinate .
Longitude: EW Coordinate .
NS: 'N' / 'S' .
EW: 'E' / 'W' .
Coordinate: Integer Float .
@end example

This grammar has eight symbols
@findex symbol
(@code{Position}, @code{Latitude}, @code{Longitude},
@code{NS}, @code{EW}, @code{Coordinate} @code{Integer}
and @code{Float}),
four literals
@findex literal
(@code{'N'}, @code{'S'}, @code{'E'} and @code{'W'}) and
eight rules
@findex rule, grammar
@findex grammar rule
(@code{x: y / z .} is an abbreviation for the two rules
@code{x: y .} and @code{x: z .}).
Two of the symbols, @code{Integer} and @code{Float}, are not defined by the
grammar.
One of the symbols, @code{Position}, is not used in the definition of any
other symbol.

Symbols that are not defined by the grammar are called
@dfn{terminal} symbols;
@findex terminal symbol
@findex symbol, terminal
those defined by the grammar are called
@dfn{nonterminal} symbols.
@findex nonterminal symbol
@findex symbol, nonterminal
The (unique) symbol not used in the definition of any other symbol is
called the @dfn{axiom}
@findex axiom
of the grammar.

The entire input text is called a @dfn{sentence},
@findex sentence
and corresponds to the axiom.
Thus the input text @code{N41 58.8 W087 54.3} is a sentence corresponding
to @code{Position}.
A @dfn{phrase}
@findex phrase
is a portion of the sentence corresponding to a nonterminal symbol
of the grammar.
For example, @code{N41 58.8} is a phrase corresponding to @code{Latitude},
and @code{087 54.3} is a phrase corresponding to @code{Coordinate}.
@code{54} and @code{58.8 W087} are @emph{not} phrases
because they do not correspond to any symbols.
(@code{54} is a part of the phrase @code{087 54.3} corresponding to
@code{Coordinate} and
@code{58.8 W087} is made up of part of the phrase corresponding to
@code{Latitude} and part of the phrase corresponding to @code{Longitude}.)

@node    Lexical analysis, Attribution, Syntactic analysis, Subproblems
@comment node-name,        next,        previous,           up
@ifinfo
@subsubsection Recognizing character sequences
@end ifinfo

@dfn{Lexical analysis}
@findex lexical analysis
is the process that examines the source program text,
retaining significant character sequences
@findex significant character sequence
@findex character sequences
and discarding those that are not significant.
A character sequence is significant if it corresponds to a literal in the
grammar or to a terminal symbol.
In the sentence @code{N41 58.8 W087 54.3}, the significant character sequences
are @code{N}, @code{41}, @code{58.8}, @code{W}, @code{087} and @code{54.3}.
The spaces separating the numbers of a @code{Coordinate}
and preceding the @code{Longitude} are not significant.

Eli obtains information about character sequences that correspond to literals
directly from the grammar.
The user must, however, provide descriptions of the character sequences
corresponding to each terminal symbol.
Those descriptions determine the @emph{form} of the character sequences,
but not their @emph{content}.
For example, the character sequences corresponding to the terminal symbol
@code{Integer} might be described as sequences of one or more decimal
digits, and those corresponding to the terminal symbol @code{Float} might be
described as pairs of such sequences separated by a dot
(@pxref{Regular expressions, , Regular Expressions, lex, Lexical
Analysis}):

@example
Integer:  $[0-9]+
Float:    $[0-9]+"."[0-9]+
@end example

@node    Attribution, Property storage, Lexical analysis, Subproblems
@comment node-name,   next,             previous,           up
@ifinfo
@subsubsection Computing values over trees
@end ifinfo

Computations
@findex computation
may be specified over a tree that reflects the phrase structure of a sentence.
That tree has one node
@findex node
corresponding to each phrase, with the root
@findex root
corresponding to the sentence.
For example, the tree that reflects the structure of the sentence
@code{N41 58.8 W087 54.3} has a node corresponding to the
@code{Latitude} phrase @code{N41 58.8}.
Children
@findex child
of a node correspond to the immediate component phrases of the
phrase corresponding to that node.
Thus the children of the the node corresponding to the
@code{Latitude} phrase @code{N41 58.8}
would correspond to the phrases @code{N} and @code{41 58.8}, because the
immediate components of the @code{Latitude} phrase @code{N41 58.8} are an
@code{NS} phrase (@code{N}) and a @code{Coordinate} phrase (@code{41 58.8}).

One or more values, called @dfn{attributes},
@findex attribute
may be associated with each tree node.
Computations over the tree may involve only attribute access,
C constants,
@findex C constant
and function application.
@findex function application
Here is an example:

@example
RULE DegMin: Coordinate ::= Integer Float
COMPUTE
  Coordinate.minutes=Minutes(Integer, Float);
END;
@end example

@noindent
According to the rule @code{DegMin}, @code{Coordinate} has a @code{minutes}
attribute attached to it.
The @code{minutes} attribute of @code{Coordinate} is computed by applying
the function @code{Minutes} to the values representing
@code{Integer} and @code{Float}, but how are those values obtained?
Clearly they must depend on the character sequences corresponding to these
terminal symbols.

A single integer value can be used to represent any terminal symbol.
That value is determined by a @dfn{token processor}
@findex token processor
@findex processor, token
whose name is attached to
the definition of the character sequences corresponding to the symbol,
enclosed in brackets (@pxref{Token Processors, , Token Processors, lex, Lexical
Analysis}):

@example
Integer:  $[0-9]+           [mkstr]
Float:    $[0-9]+"."[0-9]+  [mkstr]
@end example

The processor @code{mkstr}
@findex mkstr
is a library routine that stores the character sequence in an array
and yields the sequence's index.
@code{Minutes} can then use the index values to obtain the stored strings,
convert them to numbers, and perform the necessary computation.

@node    Property storage, Text generation, Attribution, Subproblems
@comment node-name,        next,            previous,    up
@ifinfo
@subsubsection Maintaining information about entities
@end ifinfo

Often an input text describes some set of @dfn{entities}
@findex entity
and the relationships
@findex relationship
among them.
For example, a program in a conventional language may describe some set of
constants, variables, types and procedures, and how these entities are
related in the execution of an algorithm.
Entities may be defined by one part of the input text and used by another.
It is therefore necessary for computations over the tree representing the
phrase structure of a sentence to be able to refer to entities and their
properties at arbitrary points.
Eli provides a @dfn{definition table}
@findex definition table
to meet this requirement
(@pxref{Criteria, , Definition Table Design Criteria, deftbl, Definition
Table}).

Each entity can be represented by a unique @dfn{definition table key},
@findex key
which allows access to arbitrary information about that entity.
The Eli user specifies the information that might be stored, and possibly a
set of @dfn{query}
@findex query
and @dfn{update}
@findex update
operations for that information.
(Eli provides a standard query operation and a standard update operation
that suffice for most purposes.)

Library modules are available for associating unique definition table keys
with identifiers
@findex identifier
according to the scope rules
@findex scope rules
@findex rule, scope
of the input text,
and for maintaining various kinds of information about entities.
Definition table keys themselves can be stored as attributes,
compared for equality, passed to query and update routines,
and accessed either directly or remotely.
A distinguished value, @code{NoKey},
@findex @code{NoKey}
represents the absence of a definition table key.

@node    Text generation, ,     Property storage, Subproblems
@comment node-name,       next, previous,         up
@ifinfo
@subsubsection Producing structured output
@end ifinfo

Output
@findex output
may be derived from arbitrary information in the input text.
The elements of the output may be arranged in arbitrary ways based on
computations over the tree representing the phrase structure of a sentence.
It is therefore useful to be able to build up a complex output data
structure piecemeal, combining components according to information gleaned
from computation.

The program text generation
@findex program text generation
@findex generation of program text
@findex output text structure
@findex structured output text
facility allows the user to specify templates
@findex template
that describe output text fragments
@findex text fragment
(@pxref{Patterns, , Pattern Specifications, ptg, PTG: Pattern-Based Text
Generator}).
``Holes'' in these templates can be filled with text generated according to
other templates.
The result is a directed, acyclic graph in which each node represents a
single template and the children of that node represent generated text
fragments.
Text at the leaves can be generated by arbitrary user-supplied routines.
(A library module provides common leaf generation routines.)

Eli generates a set of functions,
@findex text generation function
@findex functions, text generation
one per template, that are invoked during
computations to build the directed, acyclic graph.
These functions return values that can be stored as attributes,
passed to text generation functions,
and accessed either directly or remotely.
A distinguished value, @code{PTGNULL},
@findex @code{PTGNULL}
represents the absence of a graph.

Printing functions
@findex printing functions
@findex functions, printing
are also provided by Eli to output the generated text on
an arbitrary file (including the standard output unit).
These functions accept a graph and perform a depth-first, left-to-right
traversal.
The text is output during the traversal, with text generated by a common
subgraph being output once for each parent of that subgraph.

@node    Specifications, Products, Subproblems, Overview
@comment node-name,      next,     previous,   up
@section Descriptive Mechanisms Known to Eli

The Eli user describes the subproblems
@findex descriptions of subproblems
@findex subproblem descriptions
of a particular text processing problem.
Eli derives code fragments from these descriptions, and combines them into
a complete program.
Each description is given in a notation that is ideally suited to the
subproblem being described.

Subproblem descriptions are placed into files,
each of which has a @dfn{type}.
@findex specification types
@findex types, of input specification
The type is indicated by the file name extension: @file{foo.c} is a
type-@file{c} file.
Eli recognizes type-@file{c} and type-@file{h} files as C program text and
include files respectively.
Here is a list of the other file types recognized by Eli:

@table @file
@item specs
@findex @file{specs}
@findex type-@file{specs} file
A collection of object names, one per line.

@item con
@findex @file{con}
@findex type-@file{con} file
A description of the phrase structure
@findex phrase structure
of the input text.
Each phrase may be associated with a computation to be carried out when
that phrase is recognized.
Eli generates a parser from these specifications.
@xref{top, Syntactic Analysis, , syntax, Syntactic Analysis}.

@item gla
@findex @file{gla}
@findex type-@file{gla} file
A description of character sequences,
@findex character sequences
whether they are meaningful or not,
and what (if any) computation should be carried out when they are
recognized in the input text.
Eli generates a scanner from these specifications.
@xref{top, Lexical Analysis, , lex, Lexical Analysis}.

@item lido
@findex @file{lido}
@findex type-@file{lido} file
A description of the structure of a tree and the computations
@findex computation
to be carried out on that tree.
Eli generates a tree-walking evaluator from these specifications.
For a discussion on constructing computations in trees, see
@ref{top, LIDO - Computation in Trees, , comptrees,
LIDO - Computation in Trees}.
For reference, see @ref{top, LIDO - Reference Manual, , lidoref,
LIDO - Reference Manual}.

@item ctl
@findex @file{ctl}
@findex type-@file{ctl} file
Constraints on evaluator generation.
Eli uses these specifications to modify its behavior when constructing the
routine that carries out the computations.
@xref{top, LIGA Control Language Reference Manual, , lcl,
LIGA Control Language Reference Manual}.

@item ptg
@findex @file{ptg}
@findex type-@file{ptg} file
A description of structured output text.
@findex output text structure
@findex structured output text
@findex program text generation
Eli generates a set of output functions from these specifications.
@xref{top, Pattern-Based Text Generator, , ptg, Pattern-Based Text Generator}.

@item pdl
@findex @file{pdl}
@findex type-@file{pdl} file
A definition of entities and their associated properties.
@findex property definition
@findex definition table
Eli generates a definition table module from these specifications.
@xref{top, PDL Reference Manual, , deftbl, PDL Reference Manual}.

@item oil
@findex @file{oil}
@findex type-@file{oil} file
A definition of possible tree node re-labeling.
@findex overload resolution
Eli generates a re-labeling module from these specifications.
@xref{top, OIL Reference Manual, , oil, OIL Reference Manual}.

@item clp
@findex @file{clp}
@findex type-@file{clp} file
A description of the meanings of command line arguments.
@findex command line argument
Eli generates a module that accesses command line arguments from these
specifications.
@xref{top, CLP Reference Manual, , clp, CLP Reference Manual}.

@item map
@findex @file{map}
A description of the relationship between the phrase structure
@findex phrase structure
of the input text and the structure of the tree
@findex tree structure
over which computations are to be made.
Eli uses this specification to determine the tree building actions that
must be attached to rules of the parsing grammar.
@xref{Mapping, , , syntax, Syntactic Analysis}.

@item sym
@findex @file{sym}
@findex type-@file{sym} file
This is provided for backward compatibility with previous Eli releases
for specifying symbolic equivalence classes.  It is superseded by
type-@file{map} files.
@xref{Symbol Mapping, , Specifying symbolic equivalence classes, syntax,
Syntactic Analysis}.

@item delit
@findex @file{delit}
@findex type-@file{delit} file
Specifies literals
@findex literal
appearing in a type-@file{con} file that are to be
recognized by special routines.
Each line of a type-@file{delit} file consists of a regular expression
(@pxref{Regular Expressions, , Regular Expressions, lex, Lexical Analysis})
optionally followed by an identifier.
The regular expression defines the literal to be recognized specially.
A @code{#define} directive making the identifier a synonym for that
literal's syntax code is placed in the generated file @file{litcode.h}.

@item str
@findex @file{str}
@findex type-@file{str} file
Specifies initial contents of the identifier table.
@findex identifier table
Each line of a type-@file{str} file consists of two integers and a sequence
of characters.
The first integer is the syntax code to be returned by @code{mkidn}
(@pxref{identifier, , Unique Identifier Management, lib, Library Reference
Manual}), and the second is the length of the character sequence.
The integer representing the length is terminated by a single space.
The character sequence begins immediately after this space, and consists of
exactly the number of characters specified by the length.

@item gnrc
@findex @file{gnrc}
@findex type-@file{gnrc} file
Defines a generic module.
@findex generic module
Generic modules can be instantiated to yield collections of specifications
that solve specific problems.

@item fw
@findex @file{fw}
@findex type-@file{fw} file
Combines a collection of strongly-coupled specifications with documentation
describing their relationships.
Eli splits these specifications according to their types and processes them
individually.
It can also create a printed document or on-line hypertext from a
type-@file{fw} file.

@item phi
@findex @file{phi}
@findex type-@file{phi} file
Material to be included
@findex include directive
in some part of the generated processor.
Specification files of this type should have a name consisting of three parts:
@code{foo.bar.phi}.
All the files whose names end in @file{bar.phi} are concatenated together 
in arbitrary order to form a file named @code{bar.h}.
An @code{#include} directive can then be used to incorporate @file{bar.h}
into any generated file.

@file{.phi}-file-parts may also be generated by different Eli-Tools. They may only
be used in files of type @file{.h} and @file{.c}. They are automatically protected
against multiple inclusion. 

@item eta
@findex @file{eta}
@findex type-@file{eta} file
Material to be included
@findex include directive
in some part of the specifications. Specification files of this
type should have a name consisting of three parts: @code{foo.bar.eta}.
All the files whose names end in @file{bar.eta} are concatenated
together in arbitrary order to form a file named @code{bar.eta.h}.  An
@code{#include} directive can then be used to incorporate
@file{bar.eta.h} in any specification file.

@file{.eta}-file-parts can be used in any specification file with the
exception of @file{.specs} and @file{.fw}-files. The generated
include-files are not protected against multiple inclusion.

@end table

@noindent
Any of these files can contain C-style comments
@findex C-style comment
and preprocessor directives
such as @code{#include},
@findex include directive
@code{#define}
@findex macro definition
and @code{#ifdef}.
@findex conditional compilation
The C preprocessor is applied to files of all types except type-@file{fw}
@emph{before} those files are examined.
C-style comments and preprocessor directives appearing in type-@file{fw}
files are passed unchanged to the files generated from the type-@file{fw}
file.

Eli includes three pre-defined header files, which are usually generated
from type-@file{phi} specifications, in specified places:

@table @file
@item HEAD.h
@findex @file{HEAD.phi}
@findex type-@file{HEAD.phi} file
Included at the beginning of the main program, the tree constructor,
and the attribute evaluator.
This header file is used primarily to define abstract data types used in
tree computation.

@item INIT.h
@findex @file{INIT.phi}
@findex type-@file{INIT.phi} file
@findex initialization
Included at the beginning of the main program's executable code.
@file{INIT.h} may contain declarations, but only if they appear at the
beginning of compound statements that lie wholly within @file{INIT.h}.
The content of @file{INIT.h} will be executed before any other code.
Its primary purpose is to initialize abstract data types used in tree
computation.

@item FINL.h
@findex @file{FINL.phi}
@findex type-@file{FINL.phi} file
@findex finalization
Included at the end of the main program's executable code.
@file{FINL.h} may contain declarations, but only if they appear at the
beginning of compound statements that lie wholly within @file{FINL.h}.
The content of @file{FINL.h} will be executed after all other code.
Its primary purpose is to finalize abstract data types used in tree
computation.
@end table

@node    Products,  Interactive, Specifications, Overview
@comment node-name, next,        previous,       up
@section Common Derived Objects

Eli recognizes three kinds of object:
a @dfn{file}, a @dfn{string} and a @dfn{list}.
Examples of files are a specification file such as those mentioned in the
previous section, an executable binary file, or an output file from a test
run.
A flag to a command is an example of a string.
Lists are ordered sequences of objects, such as the arguments to a command
or the Makefile, C files, and header files that implement a text processor.

@dfn{Source objects}
@findex source object
@findex object, source
can be created or modified directly by the user.
They can be regular files, directories, or symbolic links.
Source objects cannot be automatically recreated by Eli;
they are the basic building blocks
from which Eli creates all other objects.
Every source object is given a type by Eli
based on its host filename,
and this type determines what derived objects can be produced from the
source object.

The file type of a source file is the longest suffix of the file name that
matches one of the source type suffixes listed in the last section.
If no suffix match is found, the file type is empty.

@dfn{Derived objects}
@findex derived object
@findex object, derived
are objects that can be produced from source objects and other derived objects
through the invocation of one or more tools.
Tools are invoked only as needed to create a specified derived object.
Eli automatically caches derived objects for re-use in future
derivations.
Derived objects are created and modified only by Eli itself,
not by users.

A derived object is named by an @dfn{odin-expression}
@findex odin-expression
@findex name of a derived object
(@pxref{Objects, , Referring to Objects, ui, User Interface}).
Lexically, an odin-expression is composed of a sequence of
@dfn{identifier}
@findex identifier, in odin-expressions
and @emph{operator}
@findex operator, in odin-expressions
tokens, and is terminated by a newline character.
An odin-expression can be continued on multiple lines
by escaping each newline character with a backslash.
This backslash (but not the newline) is deleted
before the expression is parsed.
Multiple odin-expressions can be specified on the same line
by separating them with semicolon operators.

An identifier token is just a sequence of characters.
The following characters must be escaped to be included in an identifier:

@example
: + = ( ) / % ; ? $ < > ! # \ ' @kbd{space} @kbd{tab} @kbd{newline}
@end example

A single character can be escaped by preceding it with a backslash
(e.g. @code{lost\+found}).
A sequence of characters can be escaped
by enclosing them in single quote marks
(e.g. @code{'lost+found'}).

Unescaped @dfn{white space}
@findex white space, in odin-expressions
characters (spaces, tabs, and newlines)
are ignored during parsing except when they separate adjacent identifiers.

Here are a number of odin-expressions that name common objects derived from
the same collection of specifications (all of the spaces are redundant).
The identifier following a colon (@kbd{:}) is an @dfn{object type} (or
@dfn{product}) that characterizes the properties of the derived object,
while the identifier following a plus (@kbd{+}) is a @dfn{parameter type}
that modifies those properties without changing the nature of the derived
object.
(For the characteristics of all of the products and parameters defined by Eli,
@pxref{Top, , , pp, Products and Parameters}.)

@table @code
@item sets.specs :exe
@findex @code{exe}
is the executable program generated by Eli from the specifications
enumerated in @code{sets.specs}.
It is a normal program for the machine on which it was generated,
and is independent of Eli.

@item sets.specs :source
@findex @code{source}
is a set of C files, a set of header files, and a Makefile.
The result of running @code{make} with this information is the executable
program generated by Eli from the specifications
enumerated in @code{sets.specs}.

@item sets.specs :exe :help
@findex @code{help}
is a browser session that helps to explain inconsistencies in the
specifications enumerated in @code{sets.specs}.
It provides cross-references to on-line documentation and allows you to
invoke an editor on the proper files to make corrections.

@item . +cmd=(sets.specs :exe) (input) :run
@findex run
is the result of running the program generated by Eli from the
specifications enumerated in @code{sets.specs} as a command with the file
@file{input} from the current directory as an argument.
The name of the directory (in this case @code{.}, the name of the current
directory) in which the program is to be executed precedes the parameter
that defines the command to be executed.

@item sets.specs +monitor +arg=(input) :mon
@findex monitoring
is an interaction with the program generated by Eli from the specifications
enumerated in @code{sets.specs}, as it processes the data file
@file{input}.
This interaction allows you to follow the execution at the level of your
specifications, rather than at the level of the machine on which  the
program is running.

@item sets.specs +debug :dbx
@findex debugging
is an interaction with the program generated by Eli from the specifications
enumerated in @code{sets.specs} using the symbolic debugger of the machine
on which the program is running.
It is useful when some of your specifications are written directly in C.
(Replace @code{dbx} with @code{gdb} to use the GNU symbolic debugger.)

@item sets.specs :gencode :viewlist
@findex @code{gencode}
@findex @code{viewlist}
is an interactive shell executing in a directory containing all text files
generated by Eli from the specifications enumerated in @code{sets.specs}.
This facility is sometimes useful in diagnosing compiler errors due to type
mismatches.

@item sets.specs :exe :err >
@findex err
@findex @kbd{>}
@findex @kbd{<}
is the raw set of reports generated by inconsistencies in the specifications
enumerated in @code{sets.specs}, written to the screen.
(It would be sent to your editor if you replaced @kbd{>} with @kbd{<}.)
This display is sometimes useful if the reports are garbled by the
@code{help} derivation.

@item sets.specs :exe :warn >
@findex warn
is the raw set of reports generated by anomalies in the specifications
enumerated in @code{sets.specs}, written to the screen.
(It would be sent to your editor if you replaced @kbd{>} with @kbd{<}.)
This display is sometimes useful if the reports are garbled by the
@code{help} derivation.
@end table

@node    Interactive, Escape, Products,  Overview
@comment node-name,   next,   previous,  up
@section How to Request Product Manufacture

Eli is invoked by giving the command @code{eli}.
If you have never used Eli before, it will have to establish a @dfn{cache}
(@pxref{Cache, , Hints on Cache Management}).
This process is signaled by a long sequence of messages about installing
packages, followed by a note that the packages have been compiled.

After printing an identifying banner, Eli writes the prompt @code{->} and
waits for input.
The interactive session can be terminated by responding to the @code{->}
prompt with a @kbd{^D}, and you can browse the documentation by responding
with a question mark.

Entering a derived object name in response to the @code{->} prompt
constitutes a request to bring that derived object up to date with respect
to all of the source objects on which it depends.
Eli will carry out the minimum number of operations required to satisfy
this request.
When the next @code{->} prompt appears, the given object will be up to
date.

Bringing an object up to date does not yield a copy of that object.
To obtain a copy, you must add an output request.
The precise form and effect of an output request depends on whether the
object being output is a file object or a list object.
All source objects are file objects; to find out the kind of a derived
object, consult @ref{Top, , , pp, Products and Parameters}.

Here are some examples of common output requests:

@table @code
@item sets.specs :parsable >
@findex standard output
requests that the derived file object @code{sets.specs :parsable}
be written to the standard output (normally the screen).
Garbage will result if the derived object is not a text file.

@item sets.specs :exe > trans
@findex file object, output
@findex derived file object, output
@findex output to a file
requests that the derived file object @code{sets.specs :exe}
be written to file @file{trans}.
The derived object must be a file object, but it need not be text.
If the file @file{trans} does not exist, it will be created;
if it does exist, it will be overwritten if its content differs from that
of the derived object @code{sets.specs :exe}.
If @file{trans} exists and is a directory, a file named
@code{sets.specs.exe} will be written to that directory
(@pxref{copy, , Extracting and Editing Objects, ui, User Interface}).

@item sets.specs :source > src
@findex list object, output
@findex derived list object, output
requests that the derived list object @code{sets.specs :source}
be written to directory @file{src}.
The directory @file{src} must exist.
A file in @file{src} before the request will be overwritten only if it has the
same name as one of the file objects in the list @code{sets.specs :source},
but different content.
(Normally, @file{src} would be either an empty directory or
one that contains an earlier version of @code{sets.specs :source}.)

@item sets.con <
@findex file object, editing
@findex editing a file object
requests that your current editor be invoked on the object @code{sets.con}
@end table

@node    Escape,        , Interactive, Overview
@comment node-name, next, previous,    up
@section How to Invoke Unix Commands

While one is interacting with Eli, there are a number of situations in
which one wishes to execute normal operating system commands.
These commands can be executed with or without derived objects as
arguments.
We have already seen the most general form, a derived object that is an
execution of an arbitrary command in an arbitrary directory
(@pxref{Products}).
Although this facility is general enough to handle @emph{any} command
execution, it is cumbersome for simple commands.

The @kbd{!} character introduces a host command line
(@pxref{Unix, , Unix Commands, ui, User Interface}).
If the first non-white space character following the @kbd{!} is not
@kbd{:}, @kbd{;} or @kbd{=} then the rest of the line is treated as a
single, escaped sequence of characters.
This avoids the confusion resulting from interactions between the escape
conventions of host commands and odin-expressions.
A leading @kbd{:}, @kbd{;}, @kbd{=} or whitespace can be included in the
escaped sequence by preceding it with @kbd{\}.

If the name of a file object precedes the @kbd{!} character, that object is
brought up to date and the name of a file containing it is appended to the
host command line.

Here are examples of some typical command invocations using @kbd{!}:

@table @code
@item !ls
lists the files in the current directory.

@item !mkdir src
makes a new subdirectory of the current directory.

@item (sets.specs :exe) ! size
provides information about the space used by the processor generated from
@code{sets.specs}.

@item input +cmd=(sets.specs:exe) :stdout ! diff desired
compares the file @file{desired} with the result of applying the processor
generated from @code{sets.specs} to the file @file{input}.
@end table

@node    Example,   Strategies, Overview, Top
@comment node-name, next,       previous, up
@chapter Example of Eli Use

The example in this chapter illustrates how text processors are specified
to Eli.
Each section covers a major step in the development process,
@findex development process
discussing the purpose of that step and then carrying it out for the example.
A set of exercises is provided with each section.
The purpose of these exercises is to familiarize you with the basic
facilities that Eli provides for dealing with specifications, and how Eli
is typically used.
@findex typical use of Eli
@findex Eli, typical use

All of the text used in the exercises can be obtained, and the exercises
themselves can be carried out, using the facilities of Eli's
system documentation browser described in the first set of exercises given
below (@pxref{tskex, , Exercises}).

@menu
* Problem::		Statement of the problem to be solved
* Structure::		Specifying the desired phrase structure
* Atoms::		Nonliteral character sequences and comments
* Entities::		Managing source text definitions
* Generation::		Creating structured output text
@end menu

@node    Problem,   Structure, ,         Example
@comment node-name, next,      previous, up,       Eg
@section Statement of the problem to be solved

You need to classify a collection of several thousand words.
There are no duplicate words in any class, but a given word may belong to
more than one class.
The classes have arbitrary names, and no two classes may have the same
name.

A C program will manipulate the words and classes.
Because of the application, classes will be relatively fluid.
The customer expects that new words and classes will be added,
and the classification of existing words changed,
on the basis of experience and changing requirements.
Nevertheless, the system design requires that the data be built into the C
program at compile time.

@menu
* C::			Data structure required by the C program
* Data::		Proposed notation for describing a classification
* Task::		Description of the translation task
* Exercises: tskex.	Getting the sample specification
@end menu

@node C, Data, , Problem
@ifinfo
@subsubsection Data structure required by the C program
@end ifinfo

The system designers have settled on an internal representation of the data
involving an array for each class containing the words in that class as
strings, an array containing the class names as strings, and an array
containing the sizes of the classes as integers.
The number of classes is also given.
All of these data items are to be specified in a single header file.
Here is an example of such a header file for a simple classification:

@example
int number_of_sets = 3;

char *name_of_set[] = @{
"colors",
"bugs",
"verbs"@};

int size_of_set[] = @{
3,
5,
4@};

char *set_of_colors[] = @{
"red",
"blue",
"green"@};

char *set_of_bugs[] = @{
"ant",
"spider",
"fly",
"moth",
"bee"@};

char *set_of_verbs[] = @{
"crawl",
"walk",
"run",
"fly"@};

char **values_of_set[] = @{
set_of_colors,
set_of_bugs,
set_of_verbs@};
@end example

@node Data, Task, C, Problem
@ifinfo
@subsubsection Proposed notation for describing a classification
@end ifinfo

Although the meaning of the internal representation is straightforward, it
is quite clear that making the necessary alterations will be a tedious and
error-prone process.
Any change requires compatible modifications of several arrays.
For example, moving a word from one class to another means not only cutting
and pasting the word itself, but also changing the sizes of both classes.

It would be simpler and safer to define the classification with a notation
ideally suited to that task, and generate the header file from that
definition.
Here is an example of an obvious notation, defining the classification
represented by the header file given above:

@example
colors@{red blue green@}
bugs@{ant spider fly moth bee@}
verbs@{crawl walk run fly@}
@end example

@node Task, tskex, Data, Problem
@ifinfo
@subsubsection Description of the translation task
@end ifinfo

The remainder of this chapter discusses the specification and generation of
a program that translates class descriptions into header files.
This program must accept a class description, verify that class names are
unique and that there is only one occurrence of any given word in a class,
and then write a header file defining the appropriate data structure.
Its specification is broken into four parts, each stored in a separate
file:

@table @file
@item sets.con
A context-free grammar describing the structure of the input text.

@item word.gla
A specification of the character sequences that are acceptable words,
and how those character sequences should be represented internally,
plus a specification of the character sequences to be ignored.

@item symbol.lido
A specification of the context conditions on uniqueness of set names and
elements within a single set.

@item code.fw
A specification of the form of the output text and how it is constructed.
@end table

File @file{sets.specs} lists the names of these four files and contains
requests to instantiate three library modules that support them.

@node    tskex,     ,     Task,     Problem, Run
@comment node-name, next, previous, up,        Eg
@unnumberedsubsec Exercises

@iftex
Invoke Eli and type @kbd{?}, followed by a carriage return.
This request will begin a documentation browsing session.
Use the browser's @code{goto} command to place yourself at node
@code{(novice)tskex}
(Browser commands are described in
@ref{expert, , Some Advanced Info Commands, info, Info}.)
@end iftex

If you are using a computer with multiple-window capability, your
documentation browsing session is independent of your Eli session,
so you can simultaneously browse the documentation and make Eli requests.
Otherwise you must terminate the document browsing session in order to make
an Eli request.
In that case, you might want to make a note of your current node (given in
the highlighted status line) before exiting.
When you begin a new session, you can then use the @code{g} command to go
directly to that node.

@enumerate
@item
Use the documentation browser's @code{run} command to obtain a copy of the
complete specification.
You will use this copy to do the exercises in the remainder of this
chapter.

@item
Verify that you have obtained all of the specification files by making the
following Unix request via Eli
(@pxref{Unix, , Running Unix commands from Eli, ui, User Interface
Reference Manual}):

@example
-> !ls
@end example

@item
Examine the file that is not a part of the specification by requesting Eli
to display it on screen
(@pxref{copying to standard output, , Copying to Standard Output, ui,
User Interface Reference Manual}):

@example
-> input>
@end example
@end enumerate

@ifinfo
@egfiles examples/sets
@end egfiles

@run
echo 'Obtaining specifications and sample input'
cp $INFOLIB/$INFODIR/[sciw]* .
chmod +w [cwi]*
echo 'Copy complete, hit return to continue'
read answer
@end run
@end ifinfo

@node    Structure, Atoms, Problem,  Example
@comment node-name, next,  previous, up,       Eg
@section Specifying the desired phrase structure

The first step in specifying a problem to Eli is to develop a
context-free grammar
@findex context-free grammar
that describes the phrase structure
@findex phrase structure
of the input text.
This structure must reflect the desired semantics, and it must be possible
for Eli to construct a parser
@findex parser
from the grammar.
Grammar development
@findex grammar development
is a surprisingly difficult task.
It is best to concentrate on the meaning of the tree structure
@findex tree structure, meaning of
as you are developing the grammar,
and not try to economize by using the same symbols
to describe constructs that look the same but have different meanings.

@menu
* Grammar::		Explanation of the grammar for word classification
* Exercises: parex.	How to verify parsability of a grammar
@end menu

@node Grammar, parex, , Structure
@ifinfo
@subsubsection Explanation of the grammar for word classification
@end ifinfo

One possible description of the structure of the set definition text is
(@pxref{Notation, , How to describe a context-free grammar, syntax,
Syntactic Analysis}):

@example
text: set_defs .
set_defs: set_def / set_defs set_def .
set_def: set_name '@{' set_body '@}' .
set_name: word .
set_body: elements .
elements: set_element / elements set_element .
set_element: word .
@end example

@noindent
Here each set definition is described as a @code{set_name} followed by a
bracketed @code{set_body}.
The text will be made up of an arbitrary number of such definitions.
A @code{set_body}, in turn, consists of an arbitrary number of elements.
The @code{set_name} and each @code{set_element} is a @code{word}.

This structure represents the semantics of the input text:
Set names and set elements have different meanings, even though they are
both written as words.
Set bodies are significant units, even though they have the same form as
any subset of themselves.
The following specification would @emph{not} reflect the semantics, even
though it is simpler and describes the same input language:

@example
text: set_defs .
set_defs: set_def / set_defs set_def .
set_def: word '@{' elements '@}' .
elements: word / elements word .
@end example

@node    parex,     , Grammar,   Structure
@comment node-name, next, previous, up,        Eg
@unnumberedsubsec Exercises

To get information about whether Eli can construct a parser from a grammar
without actually trying to build the whole program,
use the @code{:parsable}
@findex @code{parsable}
product
(@pxref{parsable, , , pp, Products and Parameters Reference Manual}).
In order to be parsable, the grammar must satisfy the
@dfn{LALR(1) condition}.
@findex LALR(1) condition
If the LALR(1) condition is satisfied, @code{parsable} will indicate that
fact.
Otherwise it will say that the grammar is not LALR(1) and provide a listing
of conflicts
(@pxref{Conflicts, , How to Resolve Parsing Conflicts, syntax, Syntactic
Analysis}).

@enumerate
@item
Tell Eli to explain what it is doing, and
request verification that Eli can generate a parser. Append @code{>} to the 
derivation to tell Eli to copy the results on the screen.

@example
-> LogLevel=4
-> sets.specs :parsable>
@end example

When the process is complete, repeat the last request.
To save keystrokes, you can scroll through the @dfn{history}
@findex history
(@pxref{History, , The History Mechanism, ui, User Interface})
using the up- and down-arrow keys.

Explain the very different responses to the two requests
for verification of parsability.

@item
Request an editing session on the file @file{sets.con}
(@pxref{editing with the copy odin-command, ,
Editing with the Copy Command, ui, Eli User Interface Reference Manual}):
@findex editing
@findex example of editing

@example
-> sets.con<
@end example

@noindent
Delete @code{text} from the first rule of the grammar, leaving
the colon and everything following it unchanged.
Then request execution as before, scrolling through the history:

@example
-> sets.specs:parsable>
@end example

Why was Eli's response so much shorter than before?

@item
Obtain help diagnosing the error you created by deleting @code{text}:
@findex example of obtaining help

@findex @code{help}
@example
-> sets.specs :parsable :help
@end example

This request will start a documentation browsing session.
@findex browser session
Follow the menu to the display for the file in error, and use the edit
command to gain access to that file.
Correct the error by inserting @code{text} before the colon,
exit the editor, and then quit the browsing session.
Use the Eli history mechanism to repeat the last request:

@example
-> sets.specs :parsable :help
@end example

Explain Eli's response to this request.
Why was no documentation browsing session started?
Why was the response so much shorter than the response to the original
request for derivation and execution of the processor?

@item
Your request for help after fixing the error really didn't demonstrate that
the grammar was parsable, because it didn't show you the result.
Request the result:

@example
-> sets.specs :parsable>
@end example

Explain Eli's response to this request.
What steps were carried out to satisfy it?
Why were these the only ones necessary?

@item
Delete the braces @{ @} from the rule defining @code{set_def} in file
@file{sets.con}.
This change makes the entire input text nothing but a list of words,
with no differentiation between set names and elements or between different
sets.
Eli will not be able to generate a parser from this grammar.
Request verification of parsability to see the error report:

@example
-> sets.specs :parsable >
@end example

A @dfn{shift-reduce conflict}
@findex shift-reduce conflict
@findex conflict, shift-reduce
is a situation in which the parser can't tell whether it should recognize a
complete phrase or continue to add symbols to an incomplete phrase.
In this example, the next word is either the name of a new set
(and thus the current @code{elements} phrase is complete), or 
it is another set element (and thus belongs to the current @code{elements}
phrase).

Add a comma as a separator between set elements, but do not re-introduce
the braces.
Do you think that Eli will be able to generate a parser?
Briefly explain, and then verify your answer.
(For a more complete treatment of conflict resolution, see
@ref{Conflicts, , How to Resolve Parsing Conflicts, syntax, Syntactic
Analysis}.)

Restore the original specification, or change @file{input} to conform to
your new specification, to ensure correct behavior for later exercises.
@end enumerate

@node    Atoms,     Entities, Structure, Example
@comment node-name, next,     previous,  up,       Eg
@section Nonliteral character sequences and comments

The terminal symbols
@findex terminal symbol
of the grammar are the literal
@findex literal
braces and the nonliteral symbol
@findex nonliteral symbol
@code{word}.
Eli can easily deduce that the braces are significant characters, but we
must provide a definition of the significant character sequences
@findex significant character sequence
that could make up a @code{word}.
We must also describe how to capture the significant information in a word
for further processing.

Eli normally assumes that white space
@findex white space
characters (space, tab
@findex tab character
and newline)
@findex newline character
are not significant.
If we want to provide a facility for commenting a classification then we
must additionally define the form of a comment
@findex comment
and specify that character sequences having this form are also not significant.

@menu
* GLA specification::	Explanation of the character sequence description
* Exercises: procex.	How to generate a processor
@end menu

@node    GLA specification, procex, , Atoms
@ifinfo
@subsubsection Explanation of the character sequence description
@end ifinfo

Here is one possible description of the non-literal character sequences
and comments:

@findex @code{mkidn}
@findex @code{C_COMMENT}
@findex C-style comment
@example
word:   $[a-zA-Z]+      [mkidn]
        C_COMMENT
@end example

The first line defines a @code{word} to be any sequence of one or more
letters
(@pxref{Regular expressions, , Regular Expressions, lex, Lexical
Analysis}).
Whenever such a sequence is recognized in the input text, @code{mkidn} is
invoked to capture the significant information represented by the sequence.
This processor associates an integer with the recognized sequence, and
arranges for that integer to become the value representing the character
sequence.
If two character sequences recognized as words are identical, @code{mkidn}
will represent them with the same integer; distinct sequences are represented
by different integers.

The second line of the specification does not begin with a symbol followed
by @kbd{:}, which indicates that the character sequences it describes are
not significant.
It uses a @dfn{canned description}
@findex canned description
to describe character sequences taking the form of C comments
(@pxref{Canned Descriptions, , Canned Symbol Descriptions, lex,
Lexical Analysis}).
Thus any character sequence taking the form of a C comment will be ignored
in the input text read by the generated program.

@node    procex, , GLA specification, Atoms
@unnumberedsubsec Exercises

@enumerate
@item
Tell Eli to keep quiet about what it is doing, and then ask it to run the
processor derived from your specification:

@findex @code{LogLevel}
@example
-> LogLevel=2
-> input +cmd=(sets.specs :exe) :stdout >
@end example

@item
The sample input file does not contain either comments or errors.
Introduce an error by inserting a digit into one of the words of the
example and repeat your request:

@example
-> input<
-> input +cmd=(sets.specs :exe) :stdout >
@end example

Briefly explain Eli's response to this request.

@item
Verify that the generated processor correctly handles C comments.

@item
Change the specification to accept only words that begin with upper-case
letters.
Generate a translator and verify its correctness.

@item
Change the specification to allow Ada comments instead of C comments.
(Hint: @pxref{Canned Descriptions, , Canned Symbol Descriptions, lex,
Lexical Analysis}.)
Generate a translator and verify its correctness.
@end enumerate

@node    Entities,  Generation, Atoms,    Example
@comment node-name, next,       previous, up,       Eg
@section Managing source text definitions

The statement of the problem requires that the names of the classes be
unique, and that there be only one occurrence of a given word in a given
class.
This sort of condition is very common in translation problems.
It involves recognition of regions
@findex region
and specific entities
@findex entity
within those regions.
For example, a @code{set_body} is a region and a @code{set_element} is a
specific entity within that region.
The check to be made is that no @code{set_element} appears more than once
in any @code{set_body}.

Regions are defined by the grammar.
Entities may be defined both by the grammar and by the values representing
the terminal symbols: the grammar selects a particular kind of phrase,
while the instances of this phrase are differentiated by the values of their
terminal symbols.
Some computation must be carried out over the region to verify the
condition.
This computation is standard, involving only the concepts of region and
entity, so a @dfn{generic module}
@findex generic module
@findex module, generic
can be used to carry it out.

@menu
* Instantiation::	Using generic library modules to test uniqueness
* Exercises: symbex.	How to extract a processor from Eli
@end menu

@node Instantiation, symbex, , Entities
@ifinfo
@subsubsection Using generic library modules to test uniqueness
@end ifinfo

In order to use a generic module
@findex generic module
we must instantiate that module and
connect the concepts it provides to the specification of our problem.
Instantiation
@findex instantiation
is handled in the @file{sets.specs} file:

@example
$/Name/AlgScope.gnrc :inst
$/Prop/Unique.gnrc :inst
@end example

The @code{AlgScope} module
@findex @code{AlgScope} module
provides the concept of nested regions
@findex regions, nested
@findex nested regions
containing entities distinguished by integer values
(@pxref{AlgScope, , Algol-like Basic Scope Rules, name,
Specification Module Library: Name Analysis}).
The @code{Unique} module
@findex @code{Unique} module
provides the concept of an error for entities that
appear more than once in a region
(@pxref{Unique, , Check for Unique Object Occurrences, prop,
Specification Module Library: Properties of Definitions}).

An attribute grammar
@findex attribute grammar
fragment is used to connect the concepts provided by
these two modules to the specification of the phrase structure:

@findex @code{SYMBOL}
@findex @code{INHERITS}
@findex @code{TERM}
@example
ATTR Sym: int;

SYMBOL Entity INHERITS IdDefScope, Unique COMPUTE
  SYNT.Sym=TERM;
  IF(NOT(THIS.Unique), 
     message(ERROR,"Multiply-defined word", 0, COORDREF));
END;

SYMBOL text INHERITS RootScope, RangeUnique END;
SYMBOL set_body INHERITS RangeScope END;
SYMBOL set_name INHERITS Entity END;
SYMBOL set_element INHERITS Entity END;
@end example

The symbol @code{Entity},
@findex @code{Entity}
which does not occur in the context-free grammar, is used to represent the
concept of a word that must be unique within some region: a
@code{set_name} must be unique over the region lying outside of all sets,
while a @code{set_element} must be unique over the set in which it appears.
@code{Entity} allows us to gather all of the characteristics of that
concept in one place -- a @dfn{symbol attribution}
@findex symbol attribution
-- and then use inheritance
@findex inheritance
to associate those characteristics with the symbols that embody the concept.

An @code{Entity} appears in the input text as a word, which is represented
internally by the value representing the terminal symbol @code{word}.
That value was established by @code{mkidn} when the word was recognized
(@pxref{GLA specification}).

The two symbols inheriting @code{Entity}, @code{set_name} and
@code{set_element}, are defined by rules that have terminal symbols on
their right-hand sides.
@code{TERM} can be used in a symbol computation to represent the value of
a terminal symbol appearing on the right-hand side of any rule defining the
given symbol
(@pxref{Terminal Access, , , lidoref, LIDO Reference Manual}).
Thus @code{SYNT.Sym=TERM} sets the @code{Sym} attribute of the
@code{Entity} to the value representing the terminal symbol defining that
@code{Entity}.
(@code{SYNT} means that the computation takes place in the
@dfn{lower context}
@findex lower context
@findex context, lower
of the symbol, i.e. in the rules corresponding to the phrases
@code{set_name: word} and @code{set_element: word}.
@xref{Types and Classes of Attributes, , , lidoref, LIDO Reference
Manual}.)

The concept of a definition within a region is embodied in the symbol
@code{IdDefScope}
@findex @code{IdDefScope}
exported by the @code{AlgScope} module, while the concept that such a
definition must be unique is embodied in the symbol @code{Unique},
@findex Unique
exported by the @code{Unique} module.
Thus @code{Entity} inherits from these two symbols.

If the @code{Unique} attribute of the @code{Entity} is false,
then the @code{message}
@findex @code{message}
operation is invoked to output an error report. 
The report has severity
@findex error severity
@findex severity of errors
@code{ERROR},
@findex @code{ERROR}
which indicates that a definite error has been detected and therefore
no object code should be produced
(@pxref{error, , Source Text Coordinates and Error Reporting, lib,
Library Reference Manual}).
It is placed at the source text coordinates (line and column) represented
by @code{COORDREF}, and consists of the string
@code{Multiply-defined word}.
@code{COORDREF} always refers to the location of the leftmost character of
the phrase corresponding to the rule in which it appears.
Since this computation is inherited by @code{set_name} and
@code{set_element}, it appears in rules corresponding to the phrases
@code{set_name: word} and @code{set_element: word}.
Any error report will therefore refer to the leftmost character of the
multiply-defined word.

The @code{text} is the outermost region (@code{RootScope}),
@findex @code{RootScope}
within which the set names are defined.
Each set body is an inner region (@code{RangeScope}),
@findex @code{RangeScope}
within which the set elements are defined.
Therefore @code{text} inherits the @code{RootScope} computations and
@code{set_body} inherits the @code{RangeScope} computations.

A @code{set_name} must be unique within the @code{text} and a
@code{set_element} must be unique within its @code{set_body},
so both @code{text} inherits the @code{RangeUnique} computations.
@findex @code{RangeUnique}

@node symbex, , Instantiation, Entities
@unnumberedsubsec Exercises

@enumerate
@item
Create a subdirectory @file{src} and then request source code for the
set processor
(@pxref{Unix, , Running Unix commands from Eli, ui, User Interface
Reference Manual}):
@findex example of requesting source code
@findex requesting source code, example

@findex @code{source}
@example
-> !mkdir src
-> sets.specs :source >src
@end example

Does @file{src} @emph{really} contain a version of the translator
that is independent of Eli?
How can you be certain?

@item
Try deriving source code without first creating a directory:

@example
-> sets.specs :source >foo
@end example

What was the result?
Can you explain what happened?

@item
Request an executable version of the translator:

@example
-> sets.specs :exe >sets.exe
@end example

Is this executable independent of Eli?
How can you be certain?
@end enumerate

@node    Generation, ,     Entities, Example
@comment node-name,  next, previous, up,       Eg
@section Creating structured output text

At least two specifications, and sometimes more, are needed to create
structured output text.
The form of the text must be described, along with the source of its
components.
Eli generates a set of procedures from the description of the form of the
text, one for each kind of component.
The information about the components is then provided by a computation that
invokes these procedures with appropriate arguments.

We have already seen how Eli allows us to break the specification into
files that encapsulate individual tasks.
So far, each of the tasks has required only one kind of specification.
Here, however, we have a single task that requires at least two
specifications.
There is strong coupling between these specifications, however, so that a
@findex coupling between specifications
change to one will often involve a change to the other.
The solution is to combine such related specifications
@findex combining related specifications
into a single file of type @file{fw}.
@findex @file{fw}
@findex type-@file{fw} file
A type-@file{fw} file describes a set of specification files that Eli will
separate as necessary, but which the user can manipulate as a single
entity.

@menu
* Output::		Creating the C declarations
* Exercises: debugex.	How to debug Eli-generated C code
@end menu

@node Output, debugex, , Generation
@ifinfo
@subsubsection Creating the C declarations
@end ifinfo

The variable atoms of the generated C code are integers (like the number of
elements in a set) and strings (like the elements of a set).
@code{LeafPtg}
@findex @code{LeafPtg}
(@pxref{LeafPtg, , PTG Output of Leaf Nodes, output, Specification Module Library: Generating Output})
is a generic module
@findex generic module
that provides operations useful in writing such atoms,
so it is instantiated in file @file{sets.specs}:

@example
$/Output/LeafPtg.gnrc :inst
@end example

Three related specifications are used to describe the creation of the C
declarations.
First the general form of the declarations is given in a special language
called @dfn{PTG}, then there is an attribute grammar
@findex attribute grammar
fragment that computes
the individual components, and finally two C macros
@findex C macro
are needed to implement operations used in the computations.
All three specifications are combined in a single type-@file{fw} file
called @file{code.fw}:

@example
@@O@@<code.ptg@@>@@@{
Table:
  "int number_of_sets = " $/*integer*/ ";\n\n"
  "char *name_of_set[] = @{\n"
  $/*list of set names*/ "@};\n\n"
  "int size_of_set[] = @{\n"
  $/*list of set sizes*/ "@};\n\n"
  $/*list of sets*/
  "char **values_of_set[] = @{\n"
  $/*list of set representations*/ "@};"

Set:
  "char *set_of_" $/*set name*/ "[] = @{\n"
  $/*list of set elements*/ "@};\n\n"

Seq:
  $ $

List:
  $ ",\n" $

Quoted:
  "\"" $ "\""

Name:
  "set_of_" $
@@@}

@@O@@<code.lido@@>@@@{
ATTR Ptg: PTGNode;
SYMBOL Entity INHERITS IdPtg END;

SYMBOL text COMPUTE
  IF(NoErrors,
    PTGOut(
      PTGTable(
        PTGNumb(CONSTITUENTS set_name.Sym WITH (int, ADD, ARGTOONE, ZERO)),
        CONSTITUENTS set_name.Ptg WITH (PTGNode, PTGList, PTGQuoted, PTGNull),
        CONSTITUENTS set_body.Size WITH (PTGNode, PTGList, PTGNumb, PTGNull),
        CONSTITUENTS set_def.Ptg WITH (PTGNode, PTGSeq, IDENTICAL, PTGNull),
        CONSTITUENTS set_name.Ptg WITH (PTGNode, PTGList, PTGName, PTGNull))));
END;

ATTR Size: int;
SYMBOL set_body COMPUTE
  SYNT.Size=CONSTITUENTS set_element.Sym WITH (int, ADD, ARGTOONE, ZERO);
END;

SYMBOL set_def COMPUTE
  SYNT.Ptg=
    PTGSet(
      CONSTITUENT set_name.Ptg,
      CONSTITUENTS set_element.Ptg WITH (PTGNode, PTGList, PTGQuoted, PTGNull));
END;
@@@}

@@O@@<code.HEAD.phi@@>@@@{
#include "err.h"
#define NoErrors (ErrorCount[ERROR]==0)
@@@}
@end example

The PTG specification,
@findex PTG specification
which is introduced by @code{@@O@@<code.ptg@@>@@@{} and
terminated by @code{@@@}}, is simply a collection of parameterized
templates
@findex template
for output.
Each template is given a name, and consists of a sequence of items that
will be output in the given order.
Quoted C strings are output as they stand, and each @kbd{$} stands for one
parameter.
A text fragment is constructed according to a particular template by
invoking a function whose name is @code{PTG} followed by the template name.
@findex text generation function
This function returns a value of type @code{PTGNode},
@findex @code{PTGNode}
and must be provided
with one argument of type @code{PTGNode} for each parameter.

To construct a text fragment according to the template named @code{Quoted},
for example, invoke @code{PTGQuoted} with one argument of type
@code{PTGNode}.
The result will be a value of type @code{PTGNode} that describes the text
fragment @kbd{"}, followed by the text fragment described by the argument,
followed by @kbd{"}.

The attribute grammar fragment,
@findex attribute grammar
which is introduced by
@code{@@O@@<code.lido@@>@@@{} and terminated by @code{@@@}},
invokes the PTG functions with appropriate arguments.
@code{PTGNumb}
@findex @code{PTGNumb}
and @code{PTGName}
@findex @code{PTGName}
are defined by the @code{LeafPtg}
@findex @code{LeafPtg}
module
(@pxref{LeafPtg, , PTG Output of Leaf Nodes, output, Specification Module Library: Generating Output}).
They construct values of type @code{PTGNode} that describe the text
fragment consisting of a single integer value or word respectively.
These text fragments are then used in building larger text fragments, and
so on.

The translated output should be produced only if no errors were detected
by the translator.
@code{NoErrors} is a user-defined macro that tests whether any reports of
severity @code{ERROR}
@findex @code{ERROR}
@findex error severity
@findex severity of errors
were issued.
@code{NoErrors} must be defined as a C macro, in a file of type
@file{.HEAD.phi}.
@findex @file{head}
@findex type-@file{HEAD.phi} file
This can be done by a segment of the FunnelWeb file
introduced by @code{@@O@@<code.HEAD.phi@@>@@@{} and terminated by @code{@@@}}.

The error module maintains an array @code{ErrorCount},
@findex @code{ErrorCount}
indexed by severity, each of whose elements specifies the number of reports
issued at the corresponding severity
(@pxref{error, , Source Text Coordinates and Error Reporting, lib,
Library Reference Manual}).
If the @code{ERROR} element of this array is @code{0}, then no reports
of severity @code{ERROR} have been issued.

In addition to building the C declarations, the attribute grammar fragment
computes the total number of sets and the total number of elements in each
set:

@findex @code{CONSTITUENTS}
@example
ATTR Size: int;
SYMBOL set_body COMPUTE
  SYNT.Size=CONSTITUENTS set_element.Sym WITH (int, ADD, ARGTOONE, ZERO);
END;
@end example

@noindent
@code{ADD}, @code{ARGTOONE} and @code{ZERO} are built-in functions of Eli
(@pxref{Predefined Entities, , Predefined Entities, lidoref, LIDO Reference
Manual}).

This computation visits nodes of the subtree rooted in the @code{set_body}
node.
If the node is a @code{set_element} node, function @code{ARGTOONE}
is applied to the value of the @code{Sym} attribute to yield the integer
value 1.
If the node has no @code{set_element} descendants, then its descendants are
not visited and the function @code{ZERO} is invoked with no arguments to
yield the integer value 0.
Otherwise the integers computed for the children of the node are combined
pairwise in left-to-right order via the function @code{ADD}.
@xref{CONSTITUENT(S), , , lidoref, LIDO Reference Manual}.

@node debugex, , Output, Generation
@unnumberedsubsec Exercises

@enumerate
@item
Request the code generated by the processor from the specification:

@findex @code{gencode}
@example
-> sets.specs :gencode :viewlist
@end example

Find the files generated from @code{code.fw} and verify the content of
@code{code.HEAD.phi}.
(Hint: Re-read the discussion of @code{code.fw}.)

@item
Which file contains the definition of the function @code{PTGQuoted}?
(Hint: Use grep, or create a @file{tags} file and then give the command
@code{vi -t PTGQuoted}.)

@item
Briefly explain the operation of @code{PTGQuoted}.
How is the text fragment created by this function printed?

@item
Use @code{lint}
@findex @code{lint}
to search for anomalies in the collection of C routines.
Are any of those found significant?
Explain briefly.

@item
Request an interactive debugging session:
@findex debugging
@findex example of debugging

@findex @code{dbx}
@findex @code{debug}
@example
-> sets.specs +debug :dbx
@end example

@noindent
(If you prefer to use the GNU debugger gdb, simply replace
@findex @code{gdb}
@code{dbx} with @code{gdb}).

Set breakpoints to stop the program in @code{PTGQuoted}, @code{_PrPTGQuoted}
and @code{PTGOut}.
Run the program with the name of file @file{input} as its command line
argument.
What is the order of the calls to these three routines?
Explain briefly.

@item
Redefine the output text so that each array value is indented, and the
closing brace is at the beginning of a line.
For example, the array of set names should look like this:

@example
char *name_of_set[] = @{
        "colors",
        "bugs",
        "verbs"
@};
@end example

Generate a translator and verify its correctness.
@end enumerate

@node    Strategies, Documentation, Example, Top
@comment node-name,  next,          previous, up
@chapter Customizing Eli's Behavior

All derived objects are stored in a directory called the
@dfn{derived object cache},
@findex derived object cache
or simply the @dfn{cache}.
@findex cache
The cache also contains a database that stores the @dfn{depends}
relationship between the output and input files of a tool run, and the
@dfn{contains} relationship between a list and its elements.
Many of the ways of customizing Eli involve various aspects of the
derived object cache.

Eli can also be used non-interactively, and can be customized by defining
shortcuts for frequently-used derivations.

@menu
* Cache::	Hints on Cache Management
* Session::	Hints on Session Management
@end menu

@node    Cache,     Session, ,           Strategies
@comment node-name, next,    previous,   up
@section Hints on Cache Management

The default location for the cache is a directory named @code{.ODIN}
in the user's home directory.
A non-default cache location can be specified
by the @code{$ODIN} environment variable,
or with an option on the command line.
The main reasons for specifying a non-default location for
the cache are to share a common cache with other users,
or to locate the cache on a local disk for more efficient access
to derived files.

An Eli session is begun by giving the following command:
@findex Eli session
@findex @code{eli} command
@findex command line arguments

@example
eli [ -c @var{cache} ] [ -r | -R ]
@end example

@noindent
All of the command line arguments are optional, and all affect the cache:

@table @code
@item -c @var{cache}
@findex @code{-c} command line argument
Use the directory @var{cache} as the cache.

@item -r
@findex @code{-r} command line parameter
Reset the cache.
This deletes all derived objects currently stored in the cache.

@item -R
@findex @code{-R} command line parameter
Reset the cache and upgrade all tools.
This deletes all derived objects currently stored in the cache,
and also installs the most recent versions of all tools.
@end table

@noindent
Cache directories may also be deleted using normal Unix commands
whenever they are not being used by active Eli sessions.
If the specified cache does not exist when the @code{eli} command is given,
then it will be created and the most recent versions of all tools
installed.

There is no limit to the number of cache directories that may exist at one time.
You might choose to have a separate cache
@findex separate caches
@findex multiple caches
for each project you are working on, or you might choose to have a single cache
@findex single cache
to hold information for all of your projects.
If you choose multiple caches, each can be smaller than the cache you would use
for all projects.
When a project is complete, you can delete all the intermediate objects relating
to it by deleting the cache directory for that project.

Cache contents are architecture dependent, so it is not possible to
create a cache on one architecture and then
use that same cache on a different architecture.
In order to avoid this error, Eli creates a separate subdirectory of the
cache directory for each @emph{host} (not architecture) on which it is
invoked.
This behavior is unpleasant in a setting where there is a pool of hosts,
all of which have the same architecture, running with a common file server.
If the environment variable @code{ODINVIEW} is set, Eli uses the
subdirectory name specified by that variable.
(The subdirectory names can be anything; using the host name is simply
convenient.)

The default inter-process communication mechanism 
for the odin cache manager process is TCP/IP.  
If TCP/IP is not available,
set the environment variable @code{$ODIN_LOCALIPC}
and Unix domain sockets will be used instead.

@node    Session,       , Cache,    Top
@comment node-name, next, previous, up
@section Hints on Session Management

There are two kinds of Eli sessions -- interactive
@findex interactive Eli session
@findex Eli session
and non-interactive.
@findex non-interactive Eli session
Interactive sessions are used when the requests being made are ones that Eli
can satisfy quickly, and actions by the user are necessary between requests.
During initial development of a specification,
when specification errors prevent Eli from completely satisfying the request,
interactive sessions are very fruitful:
The user makes a request,
errors are reported,
the user corrects the errors and
makes the request again.

One important decision that must be made for either kind of session is the
amount of information that should be provided to the user during that session.
@findex feedback to the user
(Of course if the session is interactive, this decision can be changed
during the session itself by making appropriate requests.)
Eli is capable of describing at great length what it is doing at any given
moment.
Since the purpose of Eli is to suppress the details of the process needed to
satisfy your request, you will probably not want Eli to report those details to
you.
The Eli variable @code{LogLevel}
@findex @code{LogLevel}
controls the level at which Eli describes the actions that it is taking.
The default is @code{LogLevel=2}.
For more information about the effect of different @code{LogLevel} values,
give the Eli request @code{LogLevel=?}.
(This is an example of an Eli help request,
@findex help request to Eli
described in @ref{Help, , The Help Facility, ui, User Interface}.)

The value of the environment variable @code{EDITOR}
@findex @code{EDITOR}
at the time the Eli session starts is the command that is invoked
when the character @kbd{<} ends an input line.
(If @code{EDITOR} is not defined when the Eli session starts then @code{vi}
is assumed.)
That value can be changed at any time during the session by assigning to
the environment variable @code{EDITOR}:

@example
-> EDITOR=!emacsclient
@end example

@noindent
(Note the use of @kbd{!} to indicate that the assignment is to an
environment variable rather than to an Eli variable.)

You may wish to make your selection of an editor dependent on some property
of the environment.
A typical situation is to use one editor when seated at a workstation and 
another when logged in remotely.
In this case, create a script @file{my_editor} that tests the appropriate
environment variables, decides what editor to use, and invokes it.
Then set the value of the environment variable @code{EDITOR} to
@file{my_editor}.

Users of Gnu Emacs
@findex Emacs
who invoke Emacs only once per login session
(i.e. in a window that is always present) can
use the server capability of Emacs.
To do this, execute the command
@code{M-x server-start} in your Emacs session and use
@code{emacsclient} as the value of the environment variable @code{EDITOR}.
(You will also need to make sure that
the @code{etc} directory in your Emacs distribution is on your
@code{PATH}.)
Once
this is done, Eli editor invocations will use buffers in your Emacs
session.
A common way of utilizing this capability is to invoke Eli
from a sub-shell of your Emacs (created using @code{M-x shell}).

Eli consults file @file{Odinfile}
@findex @file{Odinfile}
in the current directory for information about the task at hand.
@file{Odinfile} is used to define one or more @dfn{targets}.
@findex target
Each target defines some product that can be requested,
using the notation @var{target} @code{==} @var{odin-expression}.
Here are examples of the three common kinds of target:

@table @code
@item mkhdr == sets.specs :exe
@findex @code{==}
@code{mkhdr} is a @dfn{file target}.
@findex file target
This line specifies that @code{mkhdr} should always be equal to the derived
file object @code{sets.specs :exe}.
If the command @code{eli mkhdr}
is given in a directory with a file @file{Odinfile} containing this line,
it will result in a non-interactive Eli session guaranteeing that
file @code{mkhdr} in this directory is up to date.
(The same effect can be obtained in an interactive session by
responding to the @code{->} prompt with
@code{mkhdr}.)
 
@item %results == input +cmd=(mkhdr) :stdout
@findex @code{%}
@code{%results} is a @dfn{virtual target}.
@findex virtual target
A virtual target is simply a name for an odin-expression, and can be used
wherever and odin-expression is required.
If the command @code{eli} @code{'%results>'}
is given in a directory with a file @file{Odinfile} containing this line,
it will result in a non-interactive Eli session guaranteeing that
the derived object @code{input +cmd=(mkhdr) :stdout} is up to date,
and writing the content to the standard output.
(The same effect can be obtained in an interactive session by
responding to the @code{->} prompt with @code{%results>}.)

@item %test ! == . +cmd=diff (%results) (result) :run
@findex @code{!}
@code{%test} is an @dfn{executable target}.
@findex executable target
An executable target is a target that is executable.
If the command @code{eli %test}
is given in a directory with a file @file{Odinfile} containing this line,
it will result in a non-interactive Eli session guaranteeing that
the derived object @code{input +cmd=(mkhdr) :stdout} (named
@code{%results}) is up to date,
and executing the @code{diff} command with this object and the file
@file{result} from the current directory as arguments.
Execution will take place in the current directory.
(The same effect can be obtained in an interactive session by
responding to the @code{->} prompt with @code{%test}.)
@end table

@node    Documentation, Index, Strategies, Top
@comment node-name,     next,  previous,   up
@chapter System Documentation

The Eli system documentation
@findex system documentation
is divided into three basic groups:

@table @asis
@item Tutorial
Strategies and examples for using Eli.
The purpose of this material is to present simple techniques that work.
Only points that we have found important for most users are covered.

@item Reference
Detailed definitions of notation and behavior.
The purpose of this material is to answer any question that might arise.
There is a reference manual for each of the notations understood by Eli,
including the language in which requests for processor construction are made.
All of the products that can be requested, and all of the parameters that can
be used to modify those requests, are the subject of a separate reference
manual.
Finally, there is a reference manual for the on-line documentation browser.

@item Administration
Strategies for installing, configuring and maintaining Eli.
The purpose of this material is to guide the person responsible for Eli at a
particular installation.
@end table

All of the documentation is available both on-line and in printed form.
Documents are stored on line as hypertext, and can be used
to support the debugging phase of a project.

@menu
* Root: (dir)top.	All Eli system documentation
* Help::		How on-line documentation supports debugging
@end menu

@node    Help,      ,     ,         Documentation
@comment node-name, next, previous, up
@section How On-line Documentation Supports Debugging

Two levels of debugging
@findex debugging
are necessary when using Eli:

@enumerate
@item
The specifications you present to Eli may be inconsistent or
ill-formed.
In that case, Eli will provide error reports in the same way as any
compiler.
You must correct the specifications so that they are well-formed and
consistent.

@item
You have presented a correct specification to Eli, but this specification
describes the wrong problem instance.
Now you must determine how the problem instance you have described differs
from the one you are really interested in, and change the specification
accordingly.
@end enumerate

@noindent
On-line documentation for Eli can only provide support for level (1),
because level (2) does not involve symptoms that can be diagnosed by Eli.

Eli presents error reports to a user only on request.
The available requests are described in
@ref{Diagnostics, , Diagnosing Specification Inconsistencies, pp,
Products and Parameters Reference Manual}.
One of these requests is @code{:help}.
@findex @code{help}
This request builds a new hypertext subtree containing the error reports,
embedded in the text to which they refer.
The files containing the errors are made accessible to the nodes describing
those errors, so that the user can correct them directly.

To correct a file, move the browser to the node describing the errors in
that file.
Execute the browser's edit command and make whatever changes are necessary.
Then exit the editor.

Error reports are also linked to the nodes of the on-line documentation
describing the constructs in which the errors were detected.
Thus the user is placed in an environment in which all of the information
needed to diagnose the errors, and the tools needed to correct them, are
immediately at hand.

@node    Index,     ,     Documentation, top
@comment node-name, next, previous,      up

@unnumbered Index
@printindex fn

@contents

@bye

