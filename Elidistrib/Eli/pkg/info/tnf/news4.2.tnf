\input texinfo   @c -*-texinfo-*-
@comment Copyright, 1998, University of Paderborn
@comment Copyright, 1997 Anthony M. Sloane
@comment %**start of header
@setfilename news4.2
@settitle New Features of Eli Version 4.2
@setchapternewpage odd
@comment %**end of header

@titlepage
@center @titlefont{New Features of Eli Version 4.2}
@sp 4
@center Uwe Kastens
@sp 1
@center University of Paderborn
@center D-33098 Paderborn
@center FRG
@sp 2
@center A. M. Sloane
@sp 1
@center Department of Computing
@center School of Mathematics, Physics, Computing and Electronics
@center Macquarie University
@center Sydney, NSW 2109 
@center Australia
@sp 2
@center W. M. Waite
@sp 1
@center Department of Electrical and Computer Engineering
@center University of Colorado
@center Boulder, CO  80309-0425
@center USA
@sp 4
@center $Revision: 3.3 $
@end titlepage

@iftex 
@finalout
@end iftex

@node top, FunnelWeb, (dir), (dir)
@ifinfo
@comment  node-name,  next,  previous,  up
@unnumbered New Features of Eli Version 4.2

$Revision: 3.3 $
@end ifinfo

This document gives information about new facilities available in Eli
version 4.2 and those modifications made since the previous distributed
Eli version 4.1 that might be of general interest. Numerous corrections,
improvements, and additions have been made without being described
here. They shall just help users to solve their problem without taking
notice of Eli's mechanism.

@menu
* FunnelWeb::                   FunnelWeb Output Specification.
* Lexical Analysis::            New token processor.
* OIL::                         Additional symbols for constants.
* Tree Parsing::                New specification language for tree 
                                transformation.
* ModLib::                      New functionality in the List and 
                                LidoList modules.
* ELI_CC::			Caution Needed in Specifying a Compiler

* Index::                       
@end menu

@node FunnelWeb, Lexical Analysis, top, top
@chapter New FunnelWeb Typesetter Support

@findex latex
@findex latex2html
@findex FunnelWeb typesetters
Two typesetter pragmas have been added to FunnelWeb:

@example
@@p typesetter = latex
@@p typesetter = latex2html
@end example

These pragmas cause the derivation @code{:fwTex} to create text
acceptable to LaTeX and latex2html respectively.  They are identical as
far as the treatment of text is concerned, but differ in how they handle
FunnelWeb macro definitions and invocations.  In both cases, normal
LaTeX and latex2html markup can be used in the text portions.  Macro
definitions and calls are implemented using LaTeX markup when
@code{latex} is specified, and latex2html markup when @code{latex2html}
is specified.

In both cases the user must supply an appropriate LaTeX preamble,
@code{\begin@{document@}} and @code{\end@{document@}} as part of the
document text.  This means that it is possible to combine the outputs
from several @code{:fwTex} derivations into a single document by using
appropriate LaTeX @code{\input} commands.

The preamble must include the LaTeX command @code{\usepackage@{alltt@}}
for either of these pragmas, and @code{latex2html} also requires
@code{\usepackage@{html@}}.

The FunnelWeb section directives are normally translated to LaTeX
sectioning commands as follows:

@itemize
@item
@code{@@A} @code{\section}
@item
@code{@@B} @code{\subsection}
@item
@code{@@C} @code{\subsubsection}
@item
@code{@@D} @code{\paragraph}
@item
@code{@@E} @code{\subparagraph}
@end itemize

If the @code{+chapter} parameter is passed to the @code{:fwTex} derivation,
however, the translation is:

@itemize
@item
@code{@@A} @code{\chapter}
@item
@code{@@B} @code{\section}
@item
@code{@@C} @code{\subsection}
@item
@code{@@D} @code{\subsubsection}
@item
@code{@@E} @code{\paragraph}
@end itemize

@node Lexical Analysis, OIL, FunnelWeb, top
@chapter New token processor lexerr

@findex lexerr
The token processor @code{lexerr} reports that the character sequence is
not a token.  It does not alter the initial classification, and does not
compute a value.

Normally, a lexical analyzer generated by Eli attaches an error report
to each character that it does not recognize.  While this behavior is
adequate in most cases, it is sometimes necessary for the designer to
specify a particular sequence of characters to be erroneous.  One
typical example is disallowing tab characters:

@example
        TAB     [lexerr]
@end example

@noindent
The canned description @code{TAB} handles all of the coordinate updating
(@pxref{Coordinates,,Maintaining the source text coordinates, lex,
Lexical Analysis}).  Since there is no label on this line, the tab
character is classified as a comment.  That classification is not
changed by @code{lexerr}, which simply reports a token error at the
coordinates of the tab
(@pxref{Illegal, , Making White Space Illegal, lex, Lexical Analysis}).

There is no source file for @code{lexerr}; it is a component of the
scanner itself, but its interface is exported so that it can be used by
other modules.

@node OIL, Tree Parsing, Lexical Analysis, top
@chapter OIL

Four constant definitions have been added to the OIL library in an effort
to simplify code using it and to bring its interface more into line with
other interfaces in the Eli system.
These new definitions do not change the library's functionality in any way:

@table @code
@item OilInvalidType
The type to which all types can be coerced, and which can be coerced to any
type.
This is the value returned by @code{OilErrorType()}.

@item OilInvalidOp
The invalid operator, resulting from an operator identification failure.
This is the value returned by @code{OilErrorOp()}.

@item OilEmptyArgSig
The empty signature, used in constructing signatures.
This is the value returned by @code{OilNewArgSig()}.

@item OilEmptySetSig
The empty type set signature, used in constructing argument lists.
This is the value returned by @code{OilNewSetSig()}.
@end table

@node Tree Parsing, ModLib, OIL, top
@chapter Tree Parsing

Type-@file{.tp}-files specify tree parsers.  Tree parsers can be used to
transform, interpret and print tree-structured data.  They are
particularly useful for problems in which the action at a node depends
strongly on the context in which that node appears.  Code selection is a
common example of this kind of problem: The code selected for an
operation is largely determined by that operation's context.

Specifications written in the TP language are analyzed for consistency and
then compiled into specifications for the BURG processor (Fraser, C. W., R.
R. Henry and T. A. Proebsting, ``BURG -- Fast Optimal Instruction Selection
and Tree Parsing'', SIGPLAN Notices 27, 4 (April, 1992) 68-76).
Eli will now also accept raw BURG specifications (file type @file{.burg}),
but we recommend that TP specifications be used instead because they are
easier to write and understand.

For a detailed treatment of tree parsers, see
@ref{Top, , , tp, Tree Parsing}.

@node ModLib, ELI_CC, Tree Parsing, top
@comment  node-name,  next,  previous,  up
@chapter ModLib

This chapter summarizes changes made to the Module Library. For more details, see
@ref{top, , , adt, Specification Module Library: Abstract Data Types}.

@subheading List-Module

@findex Module @code{List}
@findex List-Module
@findex CONSTITUENTS
@findex SingleTYPEList
A macro @code{SingleTYPEList(e)} has been added. It creates a singleton list
from the element @code{e}. In LIDO specifications it may be used e.g.
in @code{WITH} clauses of @code{CONSTITUENTS}.

@findex AddToOrderedSetTYPEList
@findex AddToSetTYPEList
A function @code{AddToOrderedSetTYPEList} has been added.
It adds an element to a list if it is not yet in that list.
In contrast to the function @code{AddToSetTYPEList} it is
assumed that the list is ordered increasingly.

@subheading LidoList-Module

@findex Module @code{LidoList}
@findex LidoList-Module
@findex FilterListElem
@findex ListElem
A symbol role @code{TYPEFilterListElem} has been added. 
On list construction it
may be used instead of @code{TYPEListElem} in order to
decide for each element whether it is to be inserted into the
list.

@node ELI_CC, Index, ModLib, top
@chapter Caution Needed in Specifying a Compiler

The environment variable @code{ELI_CC} can be used to specify the C
compiler that should be used to compile user-provided and Eli-generated
code.
Specification of a C compiler in this manner is considered to be
``permanent'', so Eli assumes that the value of @code{ELI_CC} will remain
unchanged over the life of a cache.
If you change the value of @code{ELI_CC}, you should restart Eli with the
@code{eli -r} command to reset the cache.
Otherwise, Eli will mix object code produced by the two compilers with
unpredictable results.

You can also specify the C compiler to be used by means of the @code{+cc}
parameter.
That specification holds only for the request containing it.
Eli will guarantee that all of the object code needed to satisfy that
request was produced by the specified compiler.
Successive requests specifying different compilers will be handled
correctly.

@node Index,  , ELI_CC, top
@unnumbered Index
@printindex fn

@contents
@bye

