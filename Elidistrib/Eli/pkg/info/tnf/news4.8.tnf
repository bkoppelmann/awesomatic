\input texinfo   @c -*-texinfo-*-
@comment %**start of header
@setfilename news4.8
@settitle New Features of Eli Version 4.8
@setchapternewpage odd
@comment %**end of header

@titlepage
@center @titlefont{New Features of Eli Version 4.8}
@sp 4
@center Uwe Kastens
@sp 1
@center University of Paderborn
@center D-33098 Paderborn
@center FRG
@sp 2
@center A. M. Sloane
@sp 1
@center Department of Computing
@center Division of Information and Communication Sciences
@center Macquarie University
@center Sydney, NSW 2109 
@center Australia
@sp 2
@center W. M. Waite
@sp 1
@center Department of Electrical and Computer Engineering
@center University of Colorado
@center Boulder, CO  80309-0425
@center USA
@sp 4
@center $Date: 2013/04/07 00:23:42 $
@end titlepage

@iftex 
@finalout
@end iftex

@node Top
@top New Features of Eli Version 4.8

This document gives information about new facilities available in Eli
version 4.8 and those modifications made since the previous distributed
Eli version 4.7 that might be of general interest. Numerous corrections,
improvements, and additions have been made without being described
here.

@menu
* Refactor::	Refactored top level
* Foreign::	Support for parsers not generated by Eli
* SO::		Shared library product
* Command::	Reporting file opening errors

* Index::                       
@end menu

@node Refactor
@chapter Refactored top level

The top level of the Eli system has been refactored to combine the
@cindex primary input file
primary input file open operation with the tree-building operation.
With this refactoring, the driver of an Eli-generated processor first
invokes a routine to parse the
@cindex command line
command line
(@pxref{top,,,clp,Command Line Processing}).
It then executes any code supplied via
@cindex .init files
@cindex file types: .init
@file{@samp{m}.init} files
(@pxref{Implementing,,Implementing Tree Computations,comptrees,
LIDO -- Computations in Trees}).

At this point, the driver invokes the
@cindex TREEBUILD
@code{TREEBUILD} routine.
@code{TREEBUILD} opens the primary input file, and uses the generated
scanner and parser to build the abstract syntax tree.
If there were no reports above the
@cindex WARNING error severity
@cindex error severity level WARNING
@code{WARNING} severity level
(@pxref{error,,Source Text Coordinates and Error Reporting,lib,
Library Reference}),
then the driver invokes the
@cindex ATTREVAL
@code{ATTREVAL} routine to perform the specified computation
over the constructed tree.
Finally, any code supplied via
@cindex .finl files
@cindex file types: .finl
@file{@samp{m}.finl} files is executed
(@pxref{Implementing,,Implementing Tree Computations,comptrees,
LIDO -- Computations in Trees}).

This refactoring allows one to replace @code{TREEBUILD} with any code
that builds a tree conforming to some LIDO definition
(@pxref{Tree Construction Functions,,,lidoref,LIDO - Reference Manual}).
That code will usually have its own input module, and may or may not access
command line parameters
(@pxref{Accessing,,Accessing the command line,clp,
Command Line Processor}).

@node Foreign
@chapter Support for parsers not generated by Eli

Eli has the ability to generate a complete text processor, including all of
the tree computation needed for contextual analysis.
It assumes, however, that the input language can be described by a
reasonably consistent grammar.
This is not the always the case, even for programming languages, and it may
be that more ad-hoc methods are needed to construct a tree that describes
the source text.

There are many tools other than Eli that one can use to create processors
that scan and parse text, and they differ among themselves in strategy and
power.
All support mechanisms to build trees on the basis of the relationships
implicit in the input text.
Once the tree is built, however, most systems provide no further aid.
The user is responsible for writing code in C or Java to process and
transform the tree.

Eli now has the ability to interact with a scanner/parser developed using
any arbitrary technology
(@pxref{Foreign,,Using Foreign parsers,syntax,Syntactic Analysis}).
For example, the
@cindex foreign parser
``foreign'' analyzer might be a collection of C or C++
routines that could be defined by a @file{specs} file and invoked by the
main program that Eli generates.
Alternatively, it might be a main program that invokes a
@cindex shared library
shared library to build and process the tree.
In either case, Eli can generate code to interact with it and automate the
tedious job of constructing tree computations.

@node SO
@chapter Shared library product

@cindex exe
The @code{:exe} product is the executable file derived from the
specifications, to be run on the current machine
(@pxref{exe,,exe -- Executable Version of the Processor,pp,
Products and Parameters}).
When Eli-generated code is only a part of a program created by other means,
it may be convenient to encode it as a
@cindex shared library
shared library.
This strategy could be used, for example, to incorporate Eli-generated code
into a Java program via the Java Native Interface.

@cindex so
The @code{:so} product is a shared library file derived from the given
specifications
(@pxref{so,,so -- Shared library Version of the Processor,pp,
Products and Parameters}).
A shared library should not have a
@cindex main program
main program, and therefore it should be derived with the
@cindex nomain
@code{+nomain} opition
(@pxref{nomain,,nomain -- Omitting the main program,pp,
Products and Parameters}).

When a shared library is used, the program using it normally requires that
the shared library file have a specific name.
Thus the @code{:so} product should be copied out of the cache into a file
with the appropriate name
(@pxref{Copy,,Extracting and Editing Objects,ui,User Interface}).
For example, suppose that we were deriving from @file{MyProc.fw}
and the required name for the shared library file was @file{YourLib.so}.
In that case, an appropriate derivation request might be:

@example
MyProc.fw +nomain :so > YourLib.so
@end example

@node Command
@chapter Reporting file opening errors

The format of a processor's command line can be specified in
@cindex clp
@cindex command line processor
clp (@pxref{top,,Command Line Processor,clp,Command Line Processor}).
In addition to defining options and parameters, the designer can specify
the form of an error report to be used when a file appearing on the command
line cannot be opened.

In earlier versions of Eli, this message was only written when the
processor could not open its primary input file.
As a part of the refactoring to support foreign parsers, we defined a
routine
@cindex ClpOpenError
@code{ClpOpenError} to output the report on request
(@pxref{Reporting open errors,,,clp,Command Line Processor}).

This report will be automatically made if the processor cannot open the
file specified on the command line as its primary source of data
(@pxref{Input parameters,,,clp,Command Line Processor}).
User code can also make the report if it encounters an error while opening
an arbitrary file.

@node Index
@unnumbered Index
@printindex cp
@contents
@bye
