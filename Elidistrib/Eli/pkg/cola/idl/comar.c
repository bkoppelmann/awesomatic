/* (C) Copyright 1997 University of Paderborn */

/* This file is part of the Eli translator construction system.

Eli is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

Eli is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with Eli; see the file COPYING.  If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/*
** $Id: comar.c,v 1.6 1997/08/29 08:38:08 mjung Exp $
*/
static char rcs_id[]= "$Id: comar.c,v 1.6 1997/08/29 08:38:08 mjung Exp $";

/* comar.c - IDL read/mark/write routines generated by idlc, version 3.2 
    on Mon Mar 12 14:00:11 1990
*/

/* Changes to the generated version:
 *   1. < # include "/net/corona/usr/local/idl3.2/include/C/writer.h"
 *      ---
 *      > # include "writer.h"
 *   2. < # include "/net/corona/usr/local/idl3.2/include/C/reader.h"
 *	---
 *	> # include "reader.h"
 *   3. The declarations of 'MString()' and 'Mint()' are put into comments.
 */

# include "comar.h"
# include <stdio.h>
symb_entry IDLtempsymb_entry;
def_entry IDLtempdef_entry;
unit IDLtempunit;
prop_entry IDLtempprop_entry;
value IDLtempvalue;
# define DynMode 0
# define TwoPassMode 1
# define FlatMode 0
# define DynFormat 0
# include "writer.h"
void Mp_lval();
void Wp_lval();
void Mp_dval();
void Wp_dval();
void Mp_nval();
void Wp_nval();
void Mp_sval();
void Wp_sval();
void Mvalue();
void Wvalue();
void MLvalue();
void WSEQvalue();
void Mp_prop_val();
void Wp_prop_val();
void Mp_prop();
void Wp_prop();
void Mprop_entry();
void Wprop_entry();
void MLprop_entry();
void WSEQprop_entry();
void Mp_elunit();
void Wp_elunit();
void Mp_delrep();
void Wp_delrep();
void Mp_star();
void Wp_star();
void Mp_plus();
void Wp_plus();
void Mp_opt();
void Wp_opt();
void Mp_alt();
void Wp_alt();
void Munit();
void Wunit();
void MLunit();
void WSEQunit();
void Mp_prod();
void Wp_prod();
void Mp_other();
void Wp_other();
void Mp_nterm();
void Wp_nterm();
void Mp_term();
void Wp_term();
void Mdef_entry();
void Wdef_entry();
void MLdef_entry();
void WSEQdef_entry();
void Mp_name();
void Wp_name();
void Mp_string();
void Wp_string();
void Msymb_entry();
void Wsymb_entry();
void MLsymb_entry();
void WSEQsymb_entry();
void Mp_comar();
void Wp_comar();
/* extern void MString(); */  /* put into comments to avoid compile-errors */
/* extern void Mint();    */
# define POUTPUT 2

void WSEQsymb_entry(S)
register Lsymb_entry S;
{	IDLoutC(OpenAngle);
	if (S) {
		Wsymb_entry(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    Wsymb_entry(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLsymb_entry(S)
register Lsymb_entry S;
{
		while (S) {
		    Msymb_entry(S->value);
		    S = S->next;
		}
}
void Wsymb_entry (C)
symb_entry C;
{
	switch(typeof(C)) {
		case Kp_string: Wp_string(C.Vp_string); break;
		case Kp_name: Wp_name(C.Vp_name); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void Msymb_entry (C)
symb_entry C;
{
	switch(typeof(C)) {
		case Kp_string: Mp_string(C.Vp_string); break;
		case Kp_name: Mp_name(C.Vp_name); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQdef_entry(S)
register Ldef_entry S;
{	IDLoutC(OpenAngle);
	if (S) {
		Wdef_entry(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    Wdef_entry(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLdef_entry(S)
register Ldef_entry S;
{
		while (S) {
		    Mdef_entry(S->value);
		    S = S->next;
		}
}
void Wdef_entry (C)
def_entry C;
{
	switch(typeof(C)) {
		case Kp_term: Wp_term(C.Vp_term); break;
		case Kp_nterm: Wp_nterm(C.Vp_nterm); break;
		case Kp_other: Wp_other(C.Vp_other); break;
		case Kp_prod: Wp_prod(C.Vp_prod); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void Mdef_entry (C)
def_entry C;
{
	switch(typeof(C)) {
		case Kp_term: Mp_term(C.Vp_term); break;
		case Kp_nterm: Mp_nterm(C.Vp_nterm); break;
		case Kp_other: Mp_other(C.Vp_other); break;
		case Kp_prod: Mp_prod(C.Vp_prod); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQunit(S)
register Lunit S;
{	IDLoutC(OpenAngle);
	if (S) {
		Wunit(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    Wunit(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLunit(S)
register Lunit S;
{
		while (S) {
		    Munit(S->value);
		    S = S->next;
		}
}
void Wunit (C)
unit C;
{
	switch(typeof(C)) {
		case Kp_alt: Wp_alt(C.Vp_alt); break;
		case Kp_opt: Wp_opt(C.Vp_opt); break;
		case Kp_plus: Wp_plus(C.Vp_plus); break;
		case Kp_star: Wp_star(C.Vp_star); break;
		case Kp_delrep: Wp_delrep(C.Vp_delrep); break;
		case Kp_elunit: Wp_elunit(C.Vp_elunit); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void Munit (C)
unit C;
{
	switch(typeof(C)) {
		case Kp_alt: Mp_alt(C.Vp_alt); break;
		case Kp_opt: Mp_opt(C.Vp_opt); break;
		case Kp_plus: Mp_plus(C.Vp_plus); break;
		case Kp_star: Mp_star(C.Vp_star); break;
		case Kp_delrep: Mp_delrep(C.Vp_delrep); break;
		case Kp_elunit: Mp_elunit(C.Vp_elunit); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQprop_entry(S)
register Lprop_entry S;
{	IDLoutC(OpenAngle);
	if (S) {
		Wprop_entry(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    Wprop_entry(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLprop_entry(S)
register Lprop_entry S;
{
		while (S) {
		    Mprop_entry(S->value);
		    S = S->next;
		}
}
void Wprop_entry (C)
prop_entry C;
{
	switch(typeof(C)) {
		case Kp_prop: Wp_prop(C.Vp_prop); break;
		case Kp_prop_val: Wp_prop_val(C.Vp_prop_val); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void Mprop_entry (C)
prop_entry C;
{
	switch(typeof(C)) {
		case Kp_prop: Mp_prop(C.Vp_prop); break;
		case Kp_prop_val: Mp_prop_val(C.Vp_prop_val); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQvalue(S)
register Lvalue S;
{	IDLoutC(OpenAngle);
	if (S) {
		Wvalue(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    Wvalue(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLvalue(S)
register Lvalue S;
{
		while (S) {
		    Mvalue(S->value);
		    S = S->next;
		}
}
void Wvalue (C)
value C;
{
	switch(typeof(C)) {
		case Kp_sval: Wp_sval(C.Vp_sval); break;
		case Kp_nval: Wp_nval(C.Vp_nval); break;
		case Kp_dval: Wp_dval(C.Vp_dval); break;
		case Kp_lval: Wp_lval(C.Vp_lval); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void Mvalue (C)
value C;
{
	switch(typeof(C)) {
		case Kp_sval: Mp_sval(C.Vp_sval); break;
		case Kp_nval: Mp_nval(C.Vp_nval); break;
		case Kp_dval: Mp_dval(C.Vp_dval); break;
		case Kp_lval: Mp_lval(C.Vp_lval); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void Mp_alt(n)
register p_alt n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLunit(n->rhs2);}
		{MLunit(n->rhs1);}
	}
}
void Wp_alt(zzn)
register p_alt zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_alt"); Sep = "[";
	{IDLout(Sep); IDLout("rhs2"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs2);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("rhs1"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs1);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_comar(n)
register p_comar n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLdef_entry(n->definitions);}
		{MLsymb_entry(n->symbols);}
	}
}
void Wp_comar(zzn)
register p_comar zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_comar"); Sep = "[";
	{IDLout(Sep); IDLout("definitions"); IDLoutC(AttrSep);
	WSEQdef_entry(zzn->definitions);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("symbols"); IDLoutC(AttrSep);
	WSEQsymb_entry(zzn->symbols);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_delrep(n)
register p_delrep n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLunit(n->sep);}
		{MLunit(n->rhs);}
	}
}
void Wp_delrep(zzn)
register p_delrep zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_delrep"); Sep = "[";
	{IDLout(Sep); IDLout("sep"); IDLoutC(AttrSep);
	WSEQunit(zzn->sep);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_dval(n)
register p_dval n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
	}
}
void Wp_dval(zzn)
register p_dval zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_dval"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_elunit(n)
register p_elunit n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
	}
}
void Wp_elunit(zzn)
register p_elunit zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_elunit"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_lval(n)
register p_lval n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLvalue(n->list);}
	}
}
void Wp_lval(zzn)
register p_lval zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_lval"); Sep = "[";
	{IDLout(Sep); IDLout("list"); IDLoutC(AttrSep);
	WSEQvalue(zzn->list);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_name(n)
register p_name n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->sid);}
		{MString(n->str);}
	}
}
void Wp_name(zzn)
register p_name zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_name"); Sep = "[";
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("str"); IDLoutC(AttrSep);
	WString(zzn->str);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_nterm(n)
register p_nterm n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{Mint(n->sid);}
		{MLprop_entry(n->prop);}
	}
}
void Wp_nterm(zzn)
register p_nterm zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_nterm"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("prop"); IDLoutC(AttrSep);
	WSEQprop_entry(zzn->prop);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_nval(n)
register p_nval n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->val);}
	}
}
void Wp_nval(zzn)
register p_nval zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_nval"); Sep = "[";
	{IDLout(Sep); IDLout("val"); IDLoutC(AttrSep);
	Wint(zzn->val);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_opt(n)
register p_opt n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLunit(n->rhs);}
	}
}
void Wp_opt(zzn)
register p_opt zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_opt"); Sep = "[";
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_other(n)
register p_other n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{Mint(n->sid);}
		{MLprop_entry(n->prop);}
	}
}
void Wp_other(zzn)
register p_other zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_other"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("prop"); IDLoutC(AttrSep);
	WSEQprop_entry(zzn->prop);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_plus(n)
register p_plus n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLunit(n->rhs);}
	}
}
void Wp_plus(zzn)
register p_plus zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_plus"); Sep = "[";
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_prod(n)
register p_prod n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{Mint(n->sid);}
		{MLprop_entry(n->prop);}
		{MLunit(n->rhs);}
		{Mint(n->lhsdid);}
	}
}
void Wp_prod(zzn)
register p_prod zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_prod"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("prop"); IDLoutC(AttrSep);
	WSEQprop_entry(zzn->prop);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("lhsdid"); IDLoutC(AttrSep);
	Wint(zzn->lhsdid);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_prop(n)
register p_prop n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{Mint(n->sid);}
	}
}
void Wp_prop(zzn)
register p_prop zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_prop"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_prop_val(n)
register p_prop_val n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{Mint(n->sid);}
		{Mvalue(n->val);}
	}
}
void Wp_prop_val(zzn)
register p_prop_val zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_prop_val"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("val"); IDLoutC(AttrSep);
	Wvalue(zzn->val);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_star(n)
register p_star n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLunit(n->rhs);}
	}
}
void Wp_star(zzn)
register p_star zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_star"); Sep = "[";
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQunit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_string(n)
register p_string n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->sid);}
		{MString(n->str);}
	}
}
void Wp_string(zzn)
register p_string zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_string"); Sep = "[";
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("str"); IDLoutC(AttrSep);
	WString(zzn->str);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_sval(n)
register p_sval n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->sid);}
	}
}
void Wp_sval(zzn)
register p_sval zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_sval"); Sep = "[";
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void Mp_term(n)
register p_term n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{Mint(n->sid);}
		{MLprop_entry(n->prop);}
	}
}
void Wp_term(zzn)
register p_term zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("p_term"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("sid"); IDLoutC(AttrSep);
	Wint(zzn->sid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("prop"); IDLoutC(AttrSep);
	WSEQprop_entry(zzn->prop);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void OUTPUT (filePtr, zzN
# if DynMode
, mode
# endif
# if DynFormat
, format
# endif
)
FILE * filePtr;
p_comar zzN;
# if DynMode
int mode;
# endif
# if DynFormat
int format;
# endif
{	IDLportState = POUTPUT;
	IDLcurrentFile = filePtr;
# if DynMode
	switch (mode) {
	case FLAT:
# endif
# if (DynMode || FlatMode)
		O_Node((int)zzN);
		while (doList != NULL) {
		   register struct ncell *l;
		   l = doList; doList = l->next;
		   O_Node(l->value); FreeHeap(l);
		}
		while (doneList != NULL) {
		    register struct ncell *l;
		    l = doneList;
		    UnmarkTouched(l->value); 
		    UnmarkShared(l->value);
		    doneList = l->next;FreeHeap(l);
		}
# endif
# if DynMode
		break;
	case TWOPASS:
# endif
# if DynMode || TwoPassMode
		fprintf(IDLcurrentFile, "-- structure COMAR\n");
		Mp_comar(zzN);
		Wp_comar(zzN);

# endif
# if DynMode
		break;
	default:
		WError(ErrPortMode);
	}
# endif
	fputs("#\n", IDLcurrentFile);
	return;
}
# include "reader.h"
extern ntype *IDLAllNodeTypes;
extern natype *IDLNodeAttributes;
extern int IDLnum_nodetypes;
static ntype AllNodeTypes[] = {
  { "p_alt", Kp_alt },
  { "p_comar", Kp_comar },
  { "p_delrep", Kp_delrep },
  { "p_dval", Kp_dval },
  { "p_elunit", Kp_elunit },
  { "p_lval", Kp_lval },
  { "p_name", Kp_name },
  { "p_nterm", Kp_nterm },
  { "p_nval", Kp_nval },
  { "p_opt", Kp_opt },
  { "p_other", Kp_other },
  { "p_plus", Kp_plus },
  { "p_prod", Kp_prod },
  { "p_prop", Kp_prop },
  { "p_prop_val", Kp_prop_val },
  { "p_star", Kp_star },
  { "p_string", Kp_string },
  { "p_sval", Kp_sval },
  { "p_term", Kp_term },
  { NULL, 0}
};
static natype NodeAttributes[] = {
  { "rhs2", "rhs1", NULL },
  { "definitions", "symbols", NULL },
  { "sep", "rhs", NULL },
  { "did", NULL },
  { "did", NULL },
  { "list", NULL },
  { "sid", "str", NULL },
  { "did", "sid", "prop", NULL },
  { "val", NULL },
  { "rhs", NULL },
  { "did", "sid", "prop", NULL },
  { "rhs", NULL },
  { "did", "sid", "prop", "rhs", "lhsdid", NULL },
  { "did", "sid", NULL },
  { "did", "sid", "val", NULL },
  { "rhs", NULL },
  { "sid", "str", NULL },
  { "sid", NULL },
  { "did", "sid", "prop", NULL },
  { NULL }
};
static int num_nodetypes  = 19;
static int max_attributes  = 6;
# define Gp_lval(R) ((p_lval)((R)->UnionField.NodeField))

# define Gp_dval(R) ((p_dval)((R)->UnionField.NodeField))

# define Gp_nval(R) ((p_nval)((R)->UnionField.NodeField))

# define Gp_sval(R) ((p_sval)((R)->UnionField.NodeField))

value Gvalue();
Lvalue GLvalue();
#define GSEQvalue(R) GLvalue(R)

# define Gp_prop_val(R) ((p_prop_val)((R)->UnionField.NodeField))

# define Gp_prop(R) ((p_prop)((R)->UnionField.NodeField))

prop_entry Gprop_entry();
Lprop_entry GLprop_entry();
#define GSEQprop_entry(R) GLprop_entry(R)

# define Gp_elunit(R) ((p_elunit)((R)->UnionField.NodeField))

# define Gp_delrep(R) ((p_delrep)((R)->UnionField.NodeField))

# define Gp_star(R) ((p_star)((R)->UnionField.NodeField))

# define Gp_plus(R) ((p_plus)((R)->UnionField.NodeField))

# define Gp_opt(R) ((p_opt)((R)->UnionField.NodeField))

# define Gp_alt(R) ((p_alt)((R)->UnionField.NodeField))

unit Gunit();
Lunit GLunit();
#define GSEQunit(R) GLunit(R)

# define Gp_prod(R) ((p_prod)((R)->UnionField.NodeField))

# define Gp_other(R) ((p_other)((R)->UnionField.NodeField))

# define Gp_nterm(R) ((p_nterm)((R)->UnionField.NodeField))

# define Gp_term(R) ((p_term)((R)->UnionField.NodeField))

def_entry Gdef_entry();
Ldef_entry GLdef_entry();
#define GSEQdef_entry(R) GLdef_entry(R)

# define Gp_name(R) ((p_name)((R)->UnionField.NodeField))

# define Gp_string(R) ((p_string)((R)->UnionField.NodeField))

symb_entry Gsymb_entry();
Lsymb_entry GLsymb_entry();
#define GSEQsymb_entry(R) GLsymb_entry(R)

# define Gp_comar(R) ((p_comar)((R)->UnionField.NodeField))

p_comar INPUT(zzF)
FILE *zzF;
{	p_comar zzC;
	NodeType zzN;
	NodeType comarNodeAlloc();
	void comarAttrStore();
	extern PF_NodeType GenericNodeAlloc;
	extern PF_AttrStore GenericAttrStore;

	IDLAllNodeTypes = AllNodeTypes;
	IDLNodeAttributes = NodeAttributes;
	IDLnum_nodetypes = num_nodetypes;
	GenericNodeAlloc = comarNodeAlloc;
	GenericAttrStore = comarAttrStore;
	zzN = Reader(zzF);
	if (!OK) {
		zzC = NULL;
	}
	else if (TypeNode(zzN) == Kp_comar) {
		zzC = (p_comar)AtNode(zzN);}
	else {
		Error(ErrBadRootType, Lex.Pos);
		OK = 0;
		zzC = NULL; }
	return(zzC);
}
NodeType comarNodeAlloc(zzN)
register int zzN;
{	register NodeType zznt;
	switch(zzN) {
	    case Kp_alt: SetNPtr(zznt, Np_alt); break;
	    case Kp_comar: SetNPtr(zznt, Np_comar); break;
	    case Kp_delrep: SetNPtr(zznt, Np_delrep); break;
	    case Kp_dval: SetNPtr(zznt, Np_dval); break;
	    case Kp_elunit: SetNPtr(zznt, Np_elunit); break;
	    case Kp_lval: SetNPtr(zznt, Np_lval); break;
	    case Kp_name: SetNPtr(zznt, Np_name); break;
	    case Kp_nterm: SetNPtr(zznt, Np_nterm); break;
	    case Kp_nval: SetNPtr(zznt, Np_nval); break;
	    case Kp_opt: SetNPtr(zznt, Np_opt); break;
	    case Kp_other: SetNPtr(zznt, Np_other); break;
	    case Kp_plus: SetNPtr(zznt, Np_plus); break;
	    case Kp_prod: SetNPtr(zznt, Np_prod); break;
	    case Kp_prop: SetNPtr(zznt, Np_prop); break;
	    case Kp_prop_val: SetNPtr(zznt, Np_prop_val); break;
	    case Kp_star: SetNPtr(zznt, Np_star); break;
	    case Kp_string: SetNPtr(zznt, Np_string); break;
	    case Kp_sval: SetNPtr(zznt, Np_sval); break;
	    case Kp_term: SetNPtr(zznt, Np_term); break;
	    default: Error(ErrBadNodeType, Lex.Pos);
	             OK = 0;
	             break;	}
	return(zznt);
}
Lvalue GLvalue (R)
RepType R;
{	register SeqType S1;
	register Lvalue S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (Lvalue)GetListCell(sizeof(Cvalue));
		P->value = Gvalue(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (Lvalue)GetListCell(sizeof(Cvalue));
			S2->value = Gvalue(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
value Gvalue (R)
register RepType R;
{
	value Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case Kp_sval: Ret.Vp_sval = Gp_sval(R); break;
		case Kp_nval: Ret.Vp_nval = Gp_nval(R); break;
		case Kp_dval: Ret.Vp_dval = Gp_dval(R); break;
		case Kp_lval: Ret.Vp_lval = Gp_lval(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
Lprop_entry GLprop_entry (R)
RepType R;
{	register SeqType S1;
	register Lprop_entry S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (Lprop_entry)GetListCell(sizeof(Cprop_entry));
		P->value = Gprop_entry(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (Lprop_entry)GetListCell(sizeof(Cprop_entry));
			S2->value = Gprop_entry(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
prop_entry Gprop_entry (R)
register RepType R;
{
	prop_entry Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case Kp_prop: Ret.Vp_prop = Gp_prop(R); break;
		case Kp_prop_val: Ret.Vp_prop_val = Gp_prop_val(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
Lunit GLunit (R)
RepType R;
{	register SeqType S1;
	register Lunit S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (Lunit)GetListCell(sizeof(Cunit));
		P->value = Gunit(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (Lunit)GetListCell(sizeof(Cunit));
			S2->value = Gunit(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
unit Gunit (R)
register RepType R;
{
	unit Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case Kp_alt: Ret.Vp_alt = Gp_alt(R); break;
		case Kp_opt: Ret.Vp_opt = Gp_opt(R); break;
		case Kp_plus: Ret.Vp_plus = Gp_plus(R); break;
		case Kp_star: Ret.Vp_star = Gp_star(R); break;
		case Kp_delrep: Ret.Vp_delrep = Gp_delrep(R); break;
		case Kp_elunit: Ret.Vp_elunit = Gp_elunit(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
Ldef_entry GLdef_entry (R)
RepType R;
{	register SeqType S1;
	register Ldef_entry S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (Ldef_entry)GetListCell(sizeof(Cdef_entry));
		P->value = Gdef_entry(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (Ldef_entry)GetListCell(sizeof(Cdef_entry));
			S2->value = Gdef_entry(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
def_entry Gdef_entry (R)
register RepType R;
{
	def_entry Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case Kp_term: Ret.Vp_term = Gp_term(R); break;
		case Kp_nterm: Ret.Vp_nterm = Gp_nterm(R); break;
		case Kp_other: Ret.Vp_other = Gp_other(R); break;
		case Kp_prod: Ret.Vp_prod = Gp_prod(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
Lsymb_entry GLsymb_entry (R)
RepType R;
{	register SeqType S1;
	register Lsymb_entry S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (Lsymb_entry)GetListCell(sizeof(Csymb_entry));
		P->value = Gsymb_entry(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (Lsymb_entry)GetListCell(sizeof(Csymb_entry));
			S2->value = Gsymb_entry(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
symb_entry Gsymb_entry (R)
register RepType R;
{
	symb_entry Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case Kp_string: Ret.Vp_string = Gp_string(R); break;
		case Kp_name: Ret.Vp_name = Gp_name(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
void comarAttrStore(N,A,R)
register NodeType N;
register AttrDesc A;
register RepType R;
{	switch(N->IDLhidden.TypeID) {
		case Kp_alt: switch (A) {
			case 1: ((p_alt)(N))->rhs2 = GSEQunit(R); 
			         break;
			case 2: ((p_alt)(N))->rhs1 = GSEQunit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_comar: switch (A) {
			case 1: ((p_comar)(N))->definitions = GSEQdef_entry(R); 
			         break;
			case 2: ((p_comar)(N))->symbols = GSEQsymb_entry(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_delrep: switch (A) {
			case 1: ((p_delrep)(N))->sep = GSEQunit(R); 
			         break;
			case 2: ((p_delrep)(N))->rhs = GSEQunit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_dval: switch (A) {
			case 1: ((p_dval)(N))->did = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_elunit: switch (A) {
			case 1: ((p_elunit)(N))->did = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_lval: switch (A) {
			case 1: ((p_lval)(N))->list = GSEQvalue(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_name: switch (A) {
			case 1: ((p_name)(N))->sid = Gint(R); 
			         break;
			case 2: ((p_name)(N))->str = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_nterm: switch (A) {
			case 1: ((p_nterm)(N))->did = Gint(R); 
			         break;
			case 2: ((p_nterm)(N))->sid = Gint(R); 
			         break;
			case 3: ((p_nterm)(N))->prop = GSEQprop_entry(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_nval: switch (A) {
			case 1: ((p_nval)(N))->val = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_opt: switch (A) {
			case 1: ((p_opt)(N))->rhs = GSEQunit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_other: switch (A) {
			case 1: ((p_other)(N))->did = Gint(R); 
			         break;
			case 2: ((p_other)(N))->sid = Gint(R); 
			         break;
			case 3: ((p_other)(N))->prop = GSEQprop_entry(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_plus: switch (A) {
			case 1: ((p_plus)(N))->rhs = GSEQunit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_prod: switch (A) {
			case 1: ((p_prod)(N))->did = Gint(R); 
			         break;
			case 2: ((p_prod)(N))->sid = Gint(R); 
			         break;
			case 3: ((p_prod)(N))->prop = GSEQprop_entry(R); 
			         break;
			case 4: ((p_prod)(N))->rhs = GSEQunit(R); 
			         break;
			case 5: ((p_prod)(N))->lhsdid = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_prop: switch (A) {
			case 1: ((p_prop)(N))->did = Gint(R); 
			         break;
			case 2: ((p_prop)(N))->sid = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_prop_val: switch (A) {
			case 1: ((p_prop_val)(N))->did = Gint(R); 
			         break;
			case 2: ((p_prop_val)(N))->sid = Gint(R); 
			         break;
			case 3: ((p_prop_val)(N))->val = Gvalue(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_star: switch (A) {
			case 1: ((p_star)(N))->rhs = GSEQunit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_string: switch (A) {
			case 1: ((p_string)(N))->sid = Gint(R); 
			         break;
			case 2: ((p_string)(N))->str = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_sval: switch (A) {
			case 1: ((p_sval)(N))->sid = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case Kp_term: switch (A) {
			case 1: ((p_term)(N))->did = Gint(R); 
			         break;
			case 2: ((p_term)(N))->sid = Gint(R); 
			         break;
			case 3: ((p_term)(N))->prop = GSEQprop_entry(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		default: Error(ErrBadNodeType, Lex.Pos); break;
	}
	DelRep(R);
}
