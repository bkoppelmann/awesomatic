\input texinfo    @c -*-texinfo-*-
@comment 
@comment (C) Copyright 1997 University of Paderborn
@comment 
@comment This file is part of the Eli translator construction system.
@comment 
@comment Eli is free software; you can redistribute it and/or modify it under
@comment the terms of the GNU General Public License as published by the Free
@comment Software Foundation; either version 2, or (at your option) any later
@comment version.
@comment 
@comment Eli is distributed in the hope that it will be useful, but WITHOUT ANY
@comment WARRANTY; without even the implied warranty of MERCHANTABILITY or
@comment FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
@comment for more details.
@comment 
@comment You should have received a copy of the GNU General Public License along
@comment with Eli; see the file COPYING.  If not, write to the Free Software
@comment Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
@comment 

@comment %**start of header (This is for running Texinfo on a region.)
@setfilename comptrees
@setchapternewpage odd
@settitle LIDO -- Computations in Trees
@comment %**end of header (This is for running Texinfo on a region.)
@comment $Id: comptrees.tnf,v 4.17 2013/10/21 08:20:19 peter Exp $
@paragraphindent 0

@titlepage
@center @titlefont{LIDO - Computations in Trees}
@sp 4
@center $Revision: 4.17 $
@sp 4
@center Uwe Kastens
@sp 2
@center Compiler and Programming Language Group
@center University of Paderborn, FB 17
@center 33102 Paderborn, FRG
@sp 4
@center Copyright, 1997 University of Paderborn
@end titlepage

@iftex
@finalout
@end iftex

@comment *****************************************************************
@node Top, , , (dir)
@comment  node-name,  next,  previous,  up
@ifinfo
@unnumbered LIDO -- Computations in Trees
@end ifinfo

Language processors generated by Eli consist of a structuring phase and
a transformation phase. The first reads the input, checks whether its
structure fulfills the language requirements and builds a tree
representing that structure. The transformation phase performs any kind
of computations on such trees necessary for analysis of the input
structure and for computing some output as required by the language
processor tasks. Both phases are generated from user supplied
specifications.

This document introduces the techniques used to specify the
transformation phase. Its central concepts are computations in trees.
The subsequent sections introduce the most important techniques and
their notation in the specification language LIDO on the base of very
simple examples.

@menu
  Node                                    
  ---------------------------------------------------------------------------
* Section 1: Top.              Introduction (You're reading it).
* Section 2: Tree.             Tree Structure.
* Section 3: Depend.           Dependend Computations.
* Section 4: Remote.           Remote Dependencies.
* Section 5: Symbols.          Symbol Computations.
* Section 6: Specification.    Interactions within Eli.
* Index::
@end menu

@ref{Tree} to @ref{Bottomup} should be read in 
that order to get a complete
overview.  It should be pointed out, that this document is not intended
to define the language LIDO. The @emph{LIDO Reference Manual} should be
consulted for specific questions on language constructs.  It also
describes facilities which increase the expressive power of LIDO
far beyond the level introduced here.
@xref{top,,,lidoref,LIDO -- Reference Manual}.
Many common subtasks of the transformation phase need not be solved
by writing LIDO specifications from scratch. Reusable solutions
can be obtained from Eli's module library.
@xref{top,,,modlib, ModLib - Specification Module Library}.

@ref{Specification} of this document describes how to use 
LIDO specifications
within Eli, how they interact with other specifications and how to get
more information when errors are reported on the specification. The
first part (@ref{LIGA Files} to @ref{Implementing}) should be read 
while examples are
practically exercised. @ref{Errors} should be consulted 
initially when
errors occur that can not be immediately traced and corrected.

@comment ******************************************************************
@node Tree, Depend, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Tree Structure

@findex tree structure
@findex tree grammar
The central data structure of a specified language processor is a tree.
It usually represents the abstract structure of the particular input
text and is built by actions of the scanner and parser. The trees a
language processor operates on are specified by a context-free grammar,
the tree grammar. It is part of the specification in LIDO. Figure 1
shows a tree grammar for simple expressions that consist of numbers and
binary operators.

@example
   RULE:    Root ::= Expr               END;
   RULE:    Expr ::= Expr Opr Expr      END;
   RULE:    Expr ::= Number             END;
   RULE:    Opr  ::= '+'                END;
   RULE:    Opr  ::= '*'                END;
@end example
@center Figure 1: Expression Tree Grammar
@comment label grammar

@findex nonterminal
@findex terminal
@findex symbol
@findex production
@code{Root}, @code{Expr,} and @code{Opr} are the nonterminals of this
context-free grammar. @code{Number}, @code{'+'} and @code{'*'} are its
terminals. Trees
are built such that their nodes represent occurrences of nonterminals
of the tree grammar. Terminals are not represented in the tree. Each
production specifies that the symbol on the left-hand side has a sequence
of subtrees according to the nonterminals on the right-hand side. In
our example the first production specifies one, the second three, and the
others no subtree. @code{Expr} and @code{Opr} have two alternative productions
each.

Figure 2 shows an example for a tree specified by this grammar, which
may represent the input expression @code{1 + 2 * 3}.
(The terminals in the bottom line do not belong to the tree.)

@example                        
                           Root
                            |
                            |
                           Expr
                            |
                 -----------|-----------
                 |          |          |
               Expr         Opr      Expr
                 |          |          |
                 -          -     ------------
                                  |    |     |
                                Expr  Opr   Expr
                                  |    |     |
                                  -    -     -

               Number       +  Number  *   Number

@center Figure 2: An Expression Tree
@end example

@findex rule context
@findex adjacent context
@findex upper context
@findex lower context
A tree node together with its immediate descendent nodes represents the
application of a production, called a rule context. In Figure 2, there are
for example two instances of the rule context for the second rule of the
grammar. The two productions for @code{Opr} describe different rule contexts,
although both have no subtrees.

If we consider a node of a tree, then it connects two @emph{adjacent contexts},
an @emph{upper context} and a @emph{lower context}. For example the upper context
of an @code{Expr} node may be an application of the first or the second
rule, and the lower context may be an application of the second or third
rule.
Rule contexts and adjacent contexts are the central concepts for association
of computation, for dependencies between computations, and for the tree
walk executing them.

@findex literal terminal
@findex named terminal
Two kinds of terminals are distinguished: Literal terminals like @code{'+'} and
@code{'*'} do not carry any information. They are only used to identify the 
production and to relate it to the concrete grammar. Named terminals like
@code{Number} may carry some information usually computed from the input 
token by the scanner, e. g. the value of the number. That information
may be used in computations of the rule context where the terminal occurs.

@findex @code{LISTOF} production
When designing a tree grammar one often needs to specify
that a certain kind of nodes has an arbitrary number of subtrees. 
For example a block may consist of a sequence of definitions 
and statements. That can be expressed using @code{LISTOF} productions,
like
@example
        RULE: BLOCK ::= '@{' Sequence '@}' END;
        RULE: Sequence LISTOF Definition | statement END;
@end example
Here, a @code{Sequence} node is specified to have an arbitrary number 
(including zero) of subtrees rooted by nodes of type @code{Definition} 
or @code{Statement}.

The @code{LISTOF} productions abstract from the fine-grained tree 
structure used to compose the elements of the sequence. The
root context and the elements contexts of the sequence are not
adjacent. Hence, when we associate computations to these
contexts, they can not refer directly to each other; techniques 
of remote access have to be used instead (see @xref{Remote}).

The above @code{LISTOF} production can be considered as an abbreviation
of the following set of tree grammar productions.
@example
        RULE: Sequence ::=  S  END;
        RULE: S :: = S Definiton  END;
        RULE: S :: = S Statement  END;
        RULE: S :: = END;
@end example
This is also one of the forms of productions that could be 
specified in the concrete grammar for the paser.
Several other forms, for example right recursive productions,
would match to the @code{LISTOF} rule as well. 

@comment *****************************************************************
@node Depend, Remote, Tree, Top
@comment  node-name,  next,  previous,  up
@chapter Dependent Computations

@findex dependent domputations
Language processing requires certain computations to be executed for
each instance of a language construct. Hence the specification
associates computations to rule contexts. Usually a computation depends
on values or effects yielded by other computations. Such dependencies
are specified by @emph{attributes} associated to grammar symbols. It should
be emphasized that only the necessary dependencies are specified, rather
than a complete execution order. A tree walking algorithm that executes
the computations in a suitable order is generated automatically.

@findex computation
@findex dependency
@findex attribute
In this section we introduce the basic concepts and notations for
specification of dependent computations in trees. The examples refer to
the tree grammar of the previous section. It will be shown how
expression evaluation and a simple transformation is specified.

@menu
  Node                                    Contents
  ----------------------------------------------------------------------------
* 1: Value.                               Value Dependencies.
* 2: State.                               State Dependencies.
* 3: Accu.                               Accumulating Computations.
@end menu

@node Value, State, Depend, Depend
@comment  node-name,  next,  previous,  up
@section Value Dependencies

@findex value dependencies
Let us first describe computations that evaluate any given expression
tree and print the result:

@findex RULE
@example
   ATTR value: int;

   RULE: Root ::=  Expr  COMPUTE
      printf ("value is %d\n", Expr.value);
   END;
@end example


@findex function
The above @code{RULE} associates the @code{printf} computation to the
rule context. The notation repeats the rule as shown in
the tree grammar and adds any set of computations between @code{COMPUTE}
and @code{END}. Computations are denoted like calls of C functions.
The arguments are C literals, again function calls, or attributes.
(User defined
functions are implemented in specifications files separate from the .lido
specification, @xref{Specification}.)

The above computation uses the @code{value} attribute of the
@code{Expr} subtree of this context. In general any attribute of any
symbol that occurs in the rule context may be used in a computation of
that context.

@findex ATTR
@findex attribute type
In this case the @code{value} attribute is the integral value computed
for the expression. The @code{ATTR} construct states that its type is
@code{int}. In fact it specifies that type for any attribute 
named @code{value} that is just used with a symbol.
Any C type name may be specified.
Such a type association is valid throughout the whole specification.
It can be overridden by attribute properties specified in @code{SYMBOL}
constructs.

The above computation depends on a computation that yields
@code{Expr.value}.  Since the internal structure of the @code{Expr}
subtree determines how its value is to be computed, those computations
are associated with the two lower adjacent contexts that have @code{Expr}
on the left-hand side of their production, as shown in the computations
of Figure 3.

@example
   TERM Number: int;

   RULE: Expr ::= Number COMPUTE
     Expr.value = Number;
   END;

   RULE: Expr ::= Expr Opr Expr COMPUTE
     Expr[1].value = Opr.value;
     Opr.left  = Expr[2].value;
     Opr.right = Expr[3].value;
   END;

   SYMBOL Opr: left, right: int;

   RULE: Opr ::=  '+'  COMPUTE
     Opr.value  =  ADD(Opr.left, Opr.right);
   END;

   RULE: Opr ::=  '*'  COMPUTE
     Opr.value = MUL(Opr.left, Opr.right);
   END;
@end example
@center Figure 3: Computation of Expression Values
@comment label expression values

@findex TERM
@findex terminal
The @code{TERM} construct states that the terminal symbol @code{Number} carries
a value of type @code{int} to be used in computations like that of 
the first rule.

@findex value
@findex single assignment rule
Computations that yield a value to be used in other computations are
denoted like an assignment to an attribute. But it must be emphasized
that they have to obey the single assignment rule: There must be exactly
one computation for each attribute instance in every tree.

@findex predefined macro
The values of binary expressions are computed in each of the two 
@code{Opr} contexts and passed to the root of the binary subtree. The
@code{ADD} and @code{MUL} operations are predefined macros in LIDO.
@code{Opr} has three attributes, the values of the left and right
operands and the result of the operation. 
The attributes @code{left}
@findex SYMBOL
and @code{right} are associated to @code{Opr} by the @code{SYMBOL} construct
which states their type to be @code{int}. As only the @code{Opr} symbol
has attributes of these names thy are not introduced by an @code{ATTR}
construct.
The attribute @code{value} is
associated to @code{Opr} by just using it in a computation. Its type
is specified by the @code{ATTR} construct explained above.

@findex attribute class
@findex class
@findex SYNT
@findex INH
@findex synthesized
@findex inherited
The three attributes belong to two
conceptually different classes: @code{Opr.value} is computed in the
lower context, as @code{Expr.value} (called synthesized or @code{SYNT}
attribute), whereas @code{Opr.left} and @code{Opr.right} are computed in
the upper context (called inherited or @code{INH} attributes). Any
attribute must belong to either of the classes in order to obey
the single assignment rule.

There are three (in this case trivial) computations specified in the context
for binary expressions. It should be pointed out that their textual order
is irrelevant: The execution order is determined by their dependencies.
In this case the computation of @code{Expr[1].value} will be executed
last. The attribute notation requires indexing of symbol names, if a symbol
occurs more than once in a production, like @code{Expr}. The indices
enumerate the occurrences of a symbol in the production from left to right
beginning with 1.

@node State, Accu, Value, Depend
@comment  node-name,  next,  previous,  up
@section State Dependencies

@findex state dependencies
Our second example specifies how to print expressions in postfix
notation, e. g. @code{1 2 3 * +} for the given expression
@code{1 + 2 * 3}. It demonstrates how computations that yield an
effect rather than a value are specified to depend on each other.


We may start from a specification that just outputs each number and
operator, given in Figure 4. It causes each instance of numbers and
operators in the tree being printed.  Since no dependencies are
specified yet, they may occur in arbitrary order in the output.

@example
   RULE: Root  ::= Expr  COMPUTE
     printf ("\n");
   END;

   RULE: Expr ::= Number COMPUTE
     printf ("%d " , Number)
   END;

   RULE: Opr   ::=  '+' COMPUTE
     printf ("+ ");
   END;

   RULE: Opr   ::= '*' COMPUTE
     printf ("* ");
   END;
@end example
@center Figure 4: Output of Expression Components
@comment label components

@findex precondition
@findex postcondition
@findex state attribute
In order to achieve the desired effect we have to specify that a
computation is not executed before certain preconditions hold which are
established by a postcondition of some other computations. We specify
such conditions by attributes that do not have values, but describe a
computational state. In Figure 5 we associate attributes @code{print}
and @code{printed} to @code{Expr} and @code{Opr}.  @code{Expr.print}
describes the state where the output is produced so far such that the
text of the @code{Expr} subtree can be appended. @code{Expr.printed}
describes the state where the text of this subtree is appended
(correspondingly for @code{Opr.print} and @code{Opr.printed}).

@example
   RULE: Root ::= Expr COMPUTE
     Expr.print = "yes";
     printf ("\n") <- Expr.printed;
   END;

   RULE: Expr ::= Number COMPUTE
     Expr.printed = printf ("%d ", Number) <- Expr.print;
   END;

   RULE: Opr  ::= '+' COMPUTE
     Opr.printed = printf ("+ ") <- Opr.print;
   END;

   RULE: Opr  ::= '*' COMPUTE
     Opr.printed = printf ("* ") <- Opr.print;
   END;

   RULE: Expr  ::= Expr Opr Expr COMPUTE
     Expr[2].print = Expr[1].print;
     Expr[3].print = Expr[2].printed;
     Opr.print = Expr[3].printed;
     Expr[1].printed = Opr.printed;
   END;
@end example
@center Figure 5: Dependencies for Producing Postfix Expressions
@comment label dependencies

The general form of dependent computations as used in Figure 5 is

@display
 @i{postcondition} = @i{computation} @code{<-} @i{precondition}
@end display

If the postcondition is not used elsewhere, it (and the =) is omitted.
If the postcondition is directly established by another condition, the
computation and the @code{<-} are omitted. If a condition
initially holds it is denoted by some literal, like "yes" in
the @code{Root} context.
A computation may depend on several preconditions:

@example
 <- (X.a, Y.b).
@end example

Computations may also depend on the computation of value carrying
attributes without using their value, or computations may yield a value
and also depend on some preconditions.

@findex VOID
State attributes which do not carry a value have the type @code{VOID}. They
need not be introduced by a @code{SYMBOL} or an @code{ATTR} construct.
They may be just used in a computation. But the same consistency and
completeness requirements apply for them as for value carrying attributes.


It should be noted that the specifications of several tasks,
e. g. computing expression values and producing postfix output may be
combined in one specification for a language processor that solves all
of them. It is a good style to keep the specifications of
different tasks separate, rather than to merge the
computations for each single context.  You may specify several sets of
computations at different places. They are accumulated for each rule
context. LIDO specifications may reside in any number of @code{.lido}
files or output fragments of @code{.fw} files. Hence, modular
decomposition and combining related specifications of different
types is encouraged.

@xref{Chain,Left-to-Right Dependencies}, for an example of expressing the
above example using left-to-right depencencies.

@node Accu, , State, Depend
@comment  node-name,  next,  previous,  up
@section Accumulating Computations

@findex accumulating computations

There are situations where a @code{VOID} attribute, say
@code{Program.AnalysisDone}, represents a computational state which
is reached when several computations are executed, which conceptually belong to
different sections of the LIDO text. Instead of moving all these
computations to the only place where @code{Program.AnalysisDone} is computed,
several accumulating computations may stay in their conceptual context
and contribute dependences to that attribute.

A computation is marked to be accumulating by the @code{+=} token. 
The following example demonstrates the above mentioned use
of accumulating computations:
@example
RULE: Program ::= Statements COMPUTE
   Program.AnalysisDone += DoThis ( );
END;
  ....
RULE: Program ::= Statements COMPUTE
   Program.AnalysisDone += DoThat ( ) <- Statements.checked;
END;
@end example 
Two accumulating computations contribute both to the attribute
@code{Program.AnalysisDone}, such that it represents the state when
the calls @code{DoThis ( )} and @code{DoThat ( )} are executed after the
pre-condition @code{Statements.checked} has been reached.
The two accumulating computations above have the same effect as if there
was a single computation, as in
@example
RULE: Program ::= Statements COMPUTE
   Program.AnalysisDone = ORDER (DoThis ( ), DoThat ( )) 
                          <- Statements.checked;
END;
@end example
The order in which @code{DoThis ( )} and @code{DoThat ( )} are executed
is arbitrarily decided by the Liga system.

Accumulating computations may be formulated in rule context
or in the context of TREE or CLASS symbols. Rule attributes may
also be computed by accumulating computations.

@findex accumulating attribute
Only VOID attributes may have accumulating computations.
If an attribute has an accumulating computation, it is called an
accumulating attribute, and all its computations must be accumulating.
Attributes are not explicitly defined to be accumulating.
If an attribute is not defined explicitly, it has the type VOID by default.
Hence, accumulating attributes need not be defined explicitly, at all.

The set of accumulating computations of an attribute is combined
into a single computation, containing all dependences and
function calls of the contributing accumulating computations, as 
shown above.

Accumulating computations may be inherited from CLASS symbols.
In contrast to non-accumulating computations, there is no
hiding for accumulating computations: All accumulating computations 
that lie on an inheritance path to an accumulating attribute
in a rule context are combined. For example, add the following
specifications to the above example:

@example 
SYMBOL Program INHERITS AddOn COMPUTE
  SYNT. AnalysisDone += AllWaysDo ( );
END;
CLASS SYMBOL AddOn COMPUTE
  SYNT. AnalysisDone += AndAlsoDo ();
END;
@end example 
Then all four computations for @code{Program.AnalysisDone} 
(two in the RULE context above, one in the TREE symbol context @code{Program}, and one
inherited from the CLASS symbol @code{AddOn})
will be combined into one. It characterizes the state after execution of the 
four function calls and the computation of @code{Statements.checked}.

Another typical use of accumulating attributes occurs in the context of
specification modules: Assume that in a library of specification modules
or in a modularly decomposed LIDO specification a computational role
like the following is provided:
@example
CLASS SYMBOL FindPath COMPUTE
  SYNT.Path = SearchPath (SYNT.Graph) <- SYNT.UserDependence;
  SYNT.UserDependence += "yes";
END;
@end example 
The provider of this computational role allows the user to add a 
dependence as a user defined pre-condition for the execution of the call of
@code{SearchPath}, if necessary. It is demonstrated in the following use of the role:
@example
SYMBOL EdgeList INHERITS FindPath COMPUTE
  SYNT.UserDependence += SYNT.GotAllEdges;
END;
@end example 

@node Remote, Symbols, Depend, Top
@comment  node-name,  next,  previous,  up
@chapter Remote Dependencies in Trees

@findex remote rependencies
In the previous section we considered dependencies between computations
within one rule context and computations that are associated to pairs of
adjacent contexts. It is often necessary to specify that a precondition
of a computation is established rather far away in the tree, e. g. a
value computed in the root context is used in several computations down
in the tree. Instead of propagating it explicitly through all
intermediate contexts it may be accessed directly by notations for
remote dependencies.

@findex INCLUDING
@findex CONSTITUENTS
@findex CHAIN
In the following we introduce three constructs for remote dependency
specification:
@itemize
@item
   access to a subtree root from contexts within the subtree
   (@code{INCLUDING} construct),
@item
   access to contexts within a subtree from its root context
   (@code{CONSTITUENTS} construct),
@item
   computations at certain subtree contexts that depend in depth-first
   left-to-right order on each other (@code{CHAIN} construct).
@end itemize

These constructs can be used for value dependencies as well as for state
dependencies. Since these constructs avoid specifications in the contexts
between the remote computations, they abstract from the particular tree
structure in between: It may be designed according to other aspects or
be altered without invalidating those remote dependencies.

@menu
  Node                                   Comment
  ----------------------------------------------------------------------------
* 1: Including.                          Access to a Subtree Root
* 2: Constituents.                       Access to Contexts within a Subtree
* 3: Chain.                              Left-to-Right Dependencies
@end menu

@node Including, Constituents, Remote, Remote
@comment  node-name,  next,  previous,  up
@section Access to a Subtree Root

@findex INCLUDING
Assume that we have a language where @code{Blocks} are arbitrarily
nested. We want to compute the nesting depth of each @code{Block}, and
mark each @code{Definition} with the nesting depth of the smallest
enclosing @code{Block}.


@example
   ATTR depth: int;

   RULE: Root ::= Block COMPUTE
     Block.depth = 0;
   END;

   RULE: Block ::= '@{' Sequence '@}' END;
   RULE: Sequence ::= Sequence Statement END;
   RULE: Sequence ::= Sequence Definition END;
   RULE: Sequence ::= END;

   RULE: Statement ::= Block COMPUTE
     Block.depth = ADD (INCLUDING Block.depth, 1);
   END;

   RULE: Statement ::= Usage END;
   RULE: Usage ::= 'use' Ident END;

   TERM Ident: int;

   RULE: Definition ::= `define' Ident  COMPUTE
     printf ("%s defined on depth %d\n",
              StringTable (Ident), INCLUDING Block.depth);
   END;
@end example
@center Figure 6: Nesting Depth of Blocks
@comment label depth

@findex remote dependencies
The specification of Figure 6 solves the stated problem by remote
dependencies (@code{INCLUDING}).  The tree contexts between @code{Block}
and @code{Statement} or @code{Definition} do not need any computations. They
are only mentioned here to show a complete example. The
expression

@example
   INCLUDING Block.depth
@end example

used in two computations accesses the @code{depth}
value of the next enclosing @code{Block}.

In general, alternative subtree root symbols may be specified, e. g.

@example
   INCLUDING (Block.depth, Procedure.depth, Module.depth)
@end example

Then the root of the smallest enclosing subtree is accessed which
represents one of the given symbols.  The tree grammar must guarantee
that such a subtree root can always be found. Such an alternative
has to be used especially 
in an @code{INCLUDING} that refers to a recursive construct
like @code{Block}.

@code{INCLUDING} constructs may also be used as preconditions in
@code{<-} constructs, and they may refer to state attributes.

@node Constituents, Chain, Including, Remote
@comment  node-name,  next,  previous,  up
@section Access to Contexts within a Subtree

@findex CONSTITUENTS
Assume that we have a language for sequences of definitions and uses of
names in arbitrary order. We want to produce an output text for each
definition and each use, such that definition texts precede the use
texts in the output. No specific order is required within the two text
blocks.

@example
   RULE: Block ::= '@{' Sequence '@}' COMPUTE
     Block.DefDone = CONSTITUENTS Definition.DefDone;
   END;

   RULE: Definition ::= 'Define' Ident COMPUTE
      Definition.DefDone =
        printf ("%s defined in line %d\n",
                StringTable(Ident), LINE);
   END;

   RULE: Usage ::= 'use' Ident COMPUTE
       printf ("%s used in line %d\n",
               StringTable(Ident), LINE),
       <- INCLUDING BLOCK.DefDone;
   END;
@end example
@center Figure 7: Sequencing Classes of Computations in a Subtree
@comment label sequencing

The solution of the problem given in Figure 7 uses a state attribute
@code{Block.DefDone}. It describes the state where all definition texts
are printed. Hence in that state the condition @code{Definition.DefDone}
must hold at each @code{Definition} in the subtree below the
@code{Block} context, as stated by the @code{CONSTITUENTS} construct.
The state @code{Block.DefDone} in turn is the precondition for the print
computation in the @code{Usage} context.
Such a pair of @code{CONSTITUENTS} and @code{INCLUDING} uses
is a common depedency pattern.

The following example demonstrates the remote access to values within a
subtree. We simply want to compute the number of @code{Usage} constructs
in a program of the above language.

@example
   ATTR Count: int;

   RULE: Block ::= '@{' Sequence '@}' COMPUTE
     printf  ("%d uses occurred\n",
              CONSTITUENTS Usage.Count
              WITH (int, ADD, IDENTICAL, ZERO));
   END;

   RULE: Usage ::= 'use' Ident COMPUTE
     Usage.Count = 1;
   END;
@end example
@center Figure 8: Adding Values of Subtree Components
@comment label adding

@findex WITH clause
The @code{CONSTITUENTS} construct in Figure 8 combines the values
@code{Usage.Count} of each @code{Usage} node within the
@code{Block} subtree. The @code{WITH} clause specifies how the values
are combined, in this case they are added yielding an @code{int}-value.


The @code{WITH} clause is a scheme to combine an arbitrary number of
values by a binary function. The general form is

@example
   WITH (t, combine, single, none)
@end example

where @code{single} is a function that yields a value of type @code{t}
applied to an attribute accessed by the @code{CONSTITUENTS}. The
function @code{combine} yields a @code{t} value applied to two
@code{t} values. @code{none} is a constant function yielding a
@code{t} value applied to no argument. 
(It is applied at subtrees that do not contain the
accessed symbol, although the tree grammar would allow them to contain
it). Typical examples for @code{WITH} clauses are given in Figure 9.

@example
      WITH (int, ADD, IDENTICAL, ZERO)
      WITH (int, Maximum, IDENTICAL, ZERO)
      WITH (int, OR, IDENTICAL, ZERO)
      WITH (int, AND, IDENTICAL, ONE)
      WITH (listtype, Append, SingleList, NullList)
@end example
@center Figure 9: Typical @code{WITH} Clauses
@comment label typical

The applications of the @code{combine} functions obey the left-to-right
order of the tree nodes where their arguments stem from. The
@code{combine} function should be associative, the @code{none} function
should not affect the resulting value.  The calls of the three functions
may occur in any suitable order; hence one should not rely upon
side-effects.
Suitable implementations of the functions and the type must be made
available for the evaluator. (@pxref{Implementing})

We must be aware that in our example the @code{CONSTITUENTS} is applied
in a recursive tree structure, i. e. blocks are nested in our language.
In fact the above specification causes that @code{Usage} constructs in
inner blocks do not contribute to the @code{CONSTITUENTS} in outer
@code{Block} context: Inner @code{Block} subtrees are shielded from it.
We better make that explicit by

@example
   CONSTITUENTS Usage.Count SHIELD Block WITH (...)
@end example

In general we may shield any class of subtrees from the
@code{CONSTITUENTS}-access, e. g. by

@example
   SHIELD (Block, Procedure, Module) ...
@end example

If no subtree should be shielded an empty @code{SHIELD} clause is used:
@findex SHIELD clause

@example
   ... SHIELD () ...
@end example

In this case our example would count the @code{Usage} constructs of all
inner blocks too.

In general several attributes may be specified for being accessed by a
@code{CONSTITUENTS}:

@example
   CONSTITUENTS (X.a, Y.b)
@end example

@node Chain, , Constituents, Remote
@comment  node-name,  next,  previous,  up
@section Left-to-Right Dependencies

@findex CHAIN
As an example for a simple left-to-right dependent computation we
rewrite the translation of expressions into postfix form of Figure 4.


In Figure 10 the @code{CHAIN} @code{print} specifies a sequence of
computations that depends on each other in left-to-right depth-first
order throughout the tree. It takes over the role of the pair of state
attributes @code{print} and @code{printed} in Figure 5.  Hence the
@code{CHAIN} is introduced with type @code{VOID}.

@example
   CHAIN print: VOID;

   RULE: Root ::= Expr COMPUTE
     CHAINSTART HEAD.print = "yes";
     printf ("\n") <- TAIL.print;
   END;

   RULE: Expr ::= Number COMPUTE
     Expr.print = printf ("%d ", Number. Sym)
                 <- Expr.print;
   END;

   RULE: Opr ::= '+' COMPUTE
     Opr.post = printf ("+") <- Opr.pre;
   END;

   RULE: Expr ::= Expr Opr Expr COMPUTE
     Opr.pre = Expr[3].print;
     Expr[1].print = Opr.post;
   END;
@end example
@center Figure 10: @code{CHAIN} for Producing Postfix Expressions
@comment label chain

@findex HEAD
@findex TAIL
@findex CHAINSTART
The @code{CHAIN} computations are initiated in the @code{Root} context;
@code{HEAD.print} refers to the @code{CHAIN} at the leftmost subtree,
@code{Expr} in this case.
@code{TAIL.print} refers to the end of the @code{CHAIN} at the rightmost
subtree, again @code{Expr}. It is the precondition for printing the
final newline.

In the second context the @code{printf} computation is specified to
lie on the @code{CHAIN} by stating @code{Expr.print} to be a
precondition (@emph{incoming} @code{CHAIN}) as well as to be a postcondition
(@emph{outgoing} @code{CHAIN}).

The @code{Opr} context together with the binary operation context
specifies that operators are not
printed in @code{CHAIN} order, but are appended after the right operand
is printed. For that purpose two state attributes @code{Opr.pre} and
@code{Opr.post} are used, as in Figure 5.

If it is necessary to locally deviate from @code{CHAIN} order, like here in
case of the binary operation context, it has to be made sure, that the
chain is not cut into separate pieces which are not linked by dependencies:
If by some reason we would add another computation to the @code{Opr} context
of our example,
e. g.

@example
     Opr.print = printf("Operator encountered\n")
                 <- Opr.print;
@end example

it looks like being integrated into the print @code{CHAIN}. But the two
computations of the binary @code{Expression} context shortcut the
@code{CHAIN} across the @code{Opr} symbol. Hence, this computation may be
executed later than intended.

The above example specifies a single @code{CHAIN} of computations through the
tree. In general there may be several instances of a @code{CHAIN} in several
subtrees, which may be nested, too. For example, we may allocate variable
definitions to storage addresses relative to their smallest enclosing
@code{Block}, as shown in Figure 11. Here the @code{CHAIN} computations 
propagate values in depth-first left-to-right order.

@example
   CHAIN RelAdr: int;

   RULE: Block ::= '@{' Sequence '@}' COMPUTE
     CHAINSTART HEAD.RelAdr = 0;
   END;

   RULE: Definition ::= 'define' Ident COMPUTE
     Definition.RelAdr = ADD (Definition.RelAdr, VariableSize);
   END;
@end example
@center Figure 11: Computing Addresses of Variables
@comment label computing

An individual @code{CHAIN} is started for each @code{Block}.  In
the computation of the Definition context the two occurrences of
@code{Definition.RelAdr} refer to different values on the @code{CHAIN}:
The access in the @code{ADD} computation is the incoming current
@code{CHAIN} value (the address of this variable), the result left to
the @code{=} symbol denotes the outgoing next @code{CHAIN} value.

@node Symbols, Bottomup, Remote, Top
@comment  node-name,  next,  previous,  up
@chapter Symbol Computations

@findex symbol computation
In this section we introduce constructs that associate computations to
tree grammar symbols rather than to rule contexts. They can be used for
computations which are conceptually connected with symbols, i. e. they
have to be executed once for each such symbol node and they are not
distinguished for the contexts in which the symbol occurs.


The use of symbol computations makes specifications even more
independent of the particular tree grammar, and hence reduces the chance
to be invalidated by grammar changes. Well designed symbol computations
may be reused at different places in one specification, and even in
specifications of different language processors.

In the following we demonstrate the use of symbol computations, and
introduce a construct for their reuse.

@menu
  Node                               Comments
  ----------------------------------------------------------------------------
* 1: Basic.                          Basic Symbol Computations.
* 2: Inheritance.                    Reuse of Symbol Computations.
@end menu

@node Basic, Inheritance, Symbols, Symbols
@comment  node-name,  next,  previous,  up
@section Basic Symbol Computations

Consider the expression grammar given in the example of @ref{Value}.
@ifinfo
(@pxref{Including,Access to a Subtree Root})
@end ifinfo 
For the purpose of this
example assume that we want to trace the computation of expression
values, and print
@code{Expr.value} for each @code{Expr} node. We could associate that
computation to both lower @code{Expr} context.
But this computation does not refer to those
particular contexts, it only depends on one @code{Expr} attribute. Hence
we better associate it to the @code{Expr} symbol:

@example
   SYMBOL Expr COMPUTE
      printf ("expression value %d in line %d\n", THIS.value, LINE);
   END;
@end example

@findex SYMBOL
@findex THIS
Symbol computations may use attributes of the symbol by the notation
@code{THIS.AttributeName}.

The next example in Figure 12 shows how attributes are computed by
symbol computations. It rewrites the usage count example of Figure 8.
Both of its computations are in fact independent of the
particular rule context.

@example
   ATTR Count: int;

   SYMBOL Usage COMPUTE
     SYNT.Count = 1;
   END;

   SYMBOL Block COMPUTE
      printf ("%d uses occurred\n",
              CONSTITUENTS Usage.Count SHIELD Block
              WITH (int, ADD, IDENTICAL, ZERO));
   END;
@end example
@center Figure 12: Symbol Computations for Usage Count
@comment label symbol

@findex INH
@findex SYNT
An attribute that is defined by a symbol computation has to be
classified @code{SYNT} or @code{INH}, like @code{SYNT.Count} above (instead
of @code{THIS.Count} if the attribute were used in the computation). It
determines whether the computation is intended for the lower @code{SYNT}
or the upper @code{INH} contexts of the symbol.

@findex INCLUDING
@findex CONSTITUENTS
@findex CHAIN
The symbol computation of @code{Block} above shows that
@code{CONSTITUENTS} constructs may be used in symbol computations as
well as in rule contexts. The same applies to @code{INCLUDING} and
@code{CHAIN} as shown below.

The above example reduces the amount of key strokes only slightly
compared with that of Figure 8. But it makes this part of the
specification invariant to modifications of the contexts where
@code{Usage} and @code{Block} occur. The productions for @code{Block}
and for @code{Usage} may be modified without affecting these symbol
computations.

Now consider the computation of nesting depth of blocks in Figure 6. The
computation of @code{Block.depth} can also be
specified as a symbol computation:

@example
   SYMBOL Block COMPUTE
     INH.depth = ADD (INCLUDING Block.depth, 1);
   END;
@end example

In this case the computation is intended to go to the upper contexts of @code{Block}, indicated by @code{INH.depth}. That is correct for any context where @code{Block} is a descendant of a @code{Statement}. But in the @code{Program} context
the @code{depth} of the root @code{Block} must be computed to 0, rather than by
the above symbol computation. So we keep the computation of Figure 6:

@example
   RULE: Root ::= Block COMPUTE
     Block.depth = 0;
   END;
@end example

It overrides the above symbol computation: A rule computation overrides
a symbol computation for the same attribute.

The example demonstrates a design rule:
@quotation
   General context independent computations are specified by symbol
   computations.  They may be overridden in special cases by computations
   in rule contexts.
@end quotation

@findex overriding computations
The technique of overriding can also be used to specify default computations:
A symbol computation specifies an attribute value for most occurrences
of the symbol. In some contexts it is overridden by rule specific
computations.


Finally we demonstrate how @code{CHAINS} are used in symbol
computations.  In Figure 11 addresses are computed for variable
definitions. It is rewritten, as shown in Figure 13. In the second
computation @code{THIS.RelAdr} occurs twice with different manings: it
refers to the incoming @code{CHAIN} value in the call of @code{ADD},
whereas the outgoing @code{CHAIN} value is defined on the
lefthand-side of the computation. @code{CHAIN} accesses are distinguished
by their use or definition, rather than by @code{SYNT} and @code{INH} as
in case of attributes.

@example
   CHAIN RelAdr: int;

   SYMBOL Block COMPUTE
     CHAINSTART HEAD.RelAdr = 0;
   END;

   SYMBOL Definition COMPUTE
     THIS.RelAdr = ADD (THIS.RelAdr, VariableSize);
   END;
@end example
@center Figure 13: Symbol Computations for Addresses of Variables
@comment label symaddr

@node Inheritance, , Basic, Symbols
@comment  node-name,  next,  previous,  up
@section Reuse of Symbol Computations

@findex inheritance
@findex INHERITS
Symbol computations are a well suited base for reuse of specifications:
A computational concept is specified by a set of symbol computations.
Then it is applied by inheriting it to grammar symbols. (Here the term
inheritance is used in the sense of object oriented programming; it must
not be confused with the class of inherited attributes.)

@findex CLASS symbol
Assume we want to enumerate occurrences of non-recursive language
constructs, e. g. definitions in a block and variable uses in each
single statement. We first describe this computational concept by
computations associated to new @code{CLASS} symbols that do not occur in the
tree grammar. In Figure 14 use a @code{CHAIN} as in the examples of
@ref{Chain}.


@example
   CHAIN Occurrence: int;
   ATTR OccNo, TotalOccs: int;

   CLASS SYMBOL OccRoot COMPUTE
     CHAINSTART HEAD.Occurrence = 0;
     THIS.TotalOccs = TAIL.Occurrence;
   END;

   CLASS SYMBOL OccElem COMPUTE
     SYNT.OccNo = THIS.Occurrence;
     THIS.Occurrence = ADD (SYNT.OccNo, 1);
   END;
@end example
@center Figure 14: Computationel Concept Occurrence Count
@comment label count

The above computations correspond to those for computing addresses in
Figure 11. They are extended by computations of attributes
@code{TotalOccs} (for the total number of enumerated constructs) and
@code{OccNo} (for the current number of the enumerated element). Further
computations may use these attributes, instead of referring to the
@code{CHAIN}, which can be considered as an implementation mechanism of the
enumeration computation.

The @code{CLASS} symbols @code{OccRoot} and @code{OccElem} represent two roles
of this computational concept: The root of a subtree where elements are
counted, and the elements to be counted. They are distinguished from
symbols of the tree grammar by specifying them @code{CLASS} @code{SYMBOL}.

We now apply this count specification to symbols of our tree grammar:

@example
   SYMBOL Block INHERITS OccRoot END;
   SYMBOL Definition INHERITS OccElem END;
@end example

@code{Block} inherits the role @code{OccRoot} and @code{Definition}
inherits the role @code{OccElem}. Those constructs yield the same effect
as if the computations for @code{OccRoot} (@code{OccElem}) were
associated to @code{Block} (@code{Definition}).
As a consequence further computations may use the attributes
@code{Definition.OccNo} (the number of a definition in a block), and
@code{Block.TotalOccs} (the total number of definitions in that block).

The second enumeration application is specified in the same way:

@example
   SYMBOL Statement INHERITS OccRoot END;
   SYMBOL Usage INHERITS OccElem END;
@end example

Of course we have to make sure that different applications do not
interact.  For example a third application enumerating the variable
assignments would collide with the definition enumeration. This
computational concept is not applicable to the enumeration of blocks
which are recursive constructs. The specification module library of Eli
provides more general applicable modules, and a mechanism that avoids
such collisions. The application of those library modules is based on
the technique of inheritance of computational roles as described here.

We finally show how several computational concepts may be combined:
Assume that we want to print the total number of enumerated constructs.
We again introduce a @code{CLASS} symbol for this computation:

@example
   CLASS SYMBOL PrintTotalOccs COMPUTE
      printf ("construct in line %d has %d elements\n",
              LINE, THIS.TotalOccs);
   END;
@end example

This computation is applied by adding

@example
   SYMBOL Block INHERITS PrintTotalOccs END;
@end example

to the specification and correspondingly for @code{Definition}. The two
@code{INHERITS} constructs can also be combined to one:

@example
   SYMBOL Block INHERITS OccRoot, PrintTotalOccs END;
@end example

We alternatively could extend the role of the enumeration root
@code{OccRoot} such that the total number is always printed by

@example
   CLASS SYMBOL OccRoot INHERITS PrintTotalOccs END;
@end example

In this case each symbol that inherits the computation of @code{OccRoot}
also inherits the computation of @code{PrintTotalOccs}.

@node Bottomup, Specification, Symbols, Top
@comment  node-name,  next,  previous,  up
@chapter Early Computations During Tree Construction

@findex @code{BOTTOMUP}
In general the execution of specified computations
begins when the tree is completely build. However, certain
application tasks require that an action is performed 
immediately when an input construct is read. It may be
not acceptable to wait until the input is completely
processed. Typical examples are desktop
calculators: A formula is evaluated and the result
is output before the next formula is read. Another
example is a computation which influences the input 
processing, e.g. switch to another input source.

In such cases, these computations (the output of the
expression value or the switch of the input file)
can be marked to be executed early using the keyword
@code{BOTTOMUP}. The Liga system then tries to arrange the
computations such that they are executed 
already when their node is constructed. 

@example
   RULE: Program  ::= Sequence END;
   RULE: Sequence ::= Sequence Output NewLine END;
   RULE: Sequence ::= END;

   SYMBOL Expression: Value: int;

   RULE: Output ::= Expression COMPUTE
     printf ("%d\n", Expression.Value) BOTTOMUP;
   END;

   RULE: Expression ::= Number COMPUTE
     Expression.Value = Number;
   END;

   RULE: Expression ::= Expression BinOpr Expression COMPUTE
     Expression[1].Value =
       APPLY (BinOpr.Funct, 
              Expression[2].Value, Expression[3].Value);
   END;

   SYMBOL BinOpr: Funct: BinFunct;
   RULE:  BinOpr ::= '+' COMPUTE BinOpr.Funct = Add;  END;
   RULE:  BinOpr ::= '*' COMPUTE BinOpr.Funct = Mult; END;
@end example
@center Figure 15: @code{BOTTOMUP} Computation for a Desktop Calculator
@comment label BOTTOMUP

Figure 15 shows the LIDO specifications for a simple
desktop calculator. The @code{printf} operation in the lower
context of the @code{Output} symbol is marked to be executed
early. It prints the value of a complete expression 
before the next expression is read.
The values of subexpressions are not printed. 

Many other computations in other contexts may contribute
values to the marked one: in this case computations
of the @code{Value} attribute of subexpressions. Liga tries 
to arrange their execution early enough to contribute 
their values to the marked computation. These contributing
computations should @emph{not} be marked @code{BOTTOMUP}, in order to 
give Liga the chance to find a suitable but less 
restrictive solution. 

Arranging computations on which a @code{BOTTOMUP} computation
depends is determined by the way trees are build: left-to-right bottom-up.
The @code{BOTTOMUP} computations may not depend on computations that
belong to context which are higher or to the right in the
tree. Furthermore, at tree construction time values can only be propagated
upward out of subtrees, but not to sibling nodes or to uncle nodes. 

The following technical detail needs to be considered for
tree grammar design in the presence of @code{BOTTOMUP} computations:
Usually parsers need one token lookahead. That means,
a tree node is constructed not before the next token is 
read which is behind the subtree of that node. In our 
example the node that has the @code{BOTTOMUP} computation
is created when the @code{NewLine} token is read.
If we had chosen to specify the @code{NewLine} in the production
of @code{Output} instead, like 
@example
    RULE: Output::= Expression NewLine COMPUTE ...
@end example
Then this node would have been created and the @code{BOTTOMUP} 
computation been executed later, when the token @emph{after}
the @code{NewLine} has been read. That would not yield the desired
effect.

@node Specification, Index, Bottomup, Top
@comment  node-name,  next,  previous,  up
@chapter Interactions within Eli

@findex Eli
This section gives initial information how specifications of
computations in trees interact with other Eli facilities. It should be
sufficient for getting started. Other documents have to be consulted for
a deeper understanding of those facilities and the interaction.

@menu
  Node                              Comments
  -----------------------------------------------------------------------------
* 1: LIGA Files.                    Supplying Tree Computation Specifications 
                                    to Eli
* 2: Tree Construction.             Tree Construction.
* 3: Implementing.                  Implementing Tree Computations.
* 4: Errors.                        Common Specification Errors.
@end menu

@node LIGA Files, Tree Construction, Specification, Specification
@comment  node-name,  next,  previous,  up
@section Supplying Tree Computation Specifications to Eli

@findex .lido files
Specifications as described in this document are written in files named
@code{x.lido} where @code{x} is an arbitrary name. The specification of
larger tasks should be decomposed into single subtasks
specified in separate files each.


Further contributions to LIDO
specifications are obtained from instantiation of library modules. The
components of a LIDO specification are comprised by enumerating
their names in a @code{.specs} file or by generating them from a
@code{.fw} file. @ref{Tree Construction} describes another 
contribution to the set
of @code{.lido} files for tree grammar specification.

It should be pointed out that @code{RULE}, @code{SYMBOL}, @code{ATTR},
and @code{CHAIN} constructs for the same names may occur arbitrary often
in several or one single file as long as they do not specify
contradicting properties.  Computations specified for one @code{RULE} or
@code{SYMBOL} name are accumulated. The LIGA system processes the
concatenation of all @code{.lido} files. Hence the reference manual for
the language LIDO (@pxref{top,,,lidoref, LIDO - Reference Manual}) 
refers to that compound specification disregarding the composition of 
single files.

@findex module library
@findex inheritance
It is highly recommended to simplify the development of specifications
by the use of precoined solutions provided by the library of
specification modules. For that purpose applicable tasks can be
identified in the module library, see 
@ref{top,,,modlib, Specification Module Library}.
The inheritance mechanism as
introduced in section @ref{Inheritance} is applied, and the 
use of the module
is stated in a @code{.specs} or a @code{.fw} file as described in that document.

@node Tree Construction, Implementing, LIGA Files, Specification
@comment  node-name,  next,  previous,  up
@section Tree Construction

@findex tree grammar
@findex concrete grammar
The specification of computations in trees assume that a tree according
to the tree grammar exists. Usually it is constructed by the structuring
phase (scanner and parser) of the language processor. There are two
different starting points for the design of the tree structure
specifications: the tree grammar or the concrete grammar for the input
language.

@findex .con files
@findex .sym files
In general there may be parts of the language that need more 
attention to the concrete grammar and others where the computations in the
tree grammar should be considered first. That may give rise to a mixed
strategy: Supply the concrete grammar specification (@code{.con} and 
@code{.sym} files) for those parts of the language which are known
and fixed, specify tree grammar rules (in @code{.lido} files) where 
computations are already known to be associated to, and take care that
the whole grammar is covered by either of them. During the refinement
of the computations further tree grammar rules may be added without updating
the concrete grammar specification.

@findex Maptool
@findex mapping
An Eli tool 
(Maptool, @pxref{top,,,syntax,Syntactic Analysis Manual}) 
combines both grammar specification fragments,
completes each of them, and relates concrete productions to tree grammar
rules such that the parser builds the required tree. That relation
is usually not a 1:1 mapping: Some concrete chain productions are left
out in the tree grammar, e. g. those which describe operators precendences
in expressions. The tree grammar may have chain context which have no 
correspondence in the concrete grammar, e. g. those which distinguish different
classes of identifier occurrences. The latter may even be introduced to the
tree grammar when they are needed during the refinement of the computations
without updating the concrete grammar specification.

@findex terminal
@findex TERM
@findex scanner
@findex GLA
Both the concrete and the tree grammar distinguish literal terminals and
named terminals. If the scanner is generated by Eli no further specification
is needed for literal terminals, like @code{'begin'} or @code{':='}.
For each named terminal,
like @code{Name} or @code{Number}, a @code{.gla} specification has to 
describe its notation. The named terminals usually carry token specific
information to be used in tree computations, e. g. the encoding of an
identifier token or the value of a number. The LIDO specification should
state the type of that information using a @code{TERM} construct, e. g.

@example
  TERM Name: int;
@end example

Since GLA generated scanners pass such token information by 
values of type @code{int}, LIGA assumes that type if the @code{TERM}
construct is omitted for a named terminal. Hence, the above
@code{TERM} construct is redundant for terminals created by GLA.
It is needed for terminal created by other scanners or by
computed tree extension.

@node Implementing, Errors, Tree Construction, Specification
@comment  node-name,  next,  previous,  up
@section Implementing Tree Computations

@findex implementation of C entities
@findex predefined entities
The implementation of functions, types, constants, and variables 
used in tree computations is
not specified within the @code{.lido} specification. They have to be
made available to the generated evaluator. No further user action is
necessary if they are defined in C (like the basic C types) or in the
standard I/O library @code{stdio.h} (like @code{printf}), or if they are
predefined in LIDO (like @code{ADD}, 
see @ref{Predefined Entities,
Predefined Entities, Predefined Entities, lidoref, LIDO -- Reference Manual},
or if they are provided by Eli tools (e. g. PDL, PTG). Otherwise the user has
to supply implementations of the used entities by
C definition.

@findex .c files
@findex .h files
@findex .head files
@findex .specs files
@findex .HEAD.phi files
@findex CPP
It is recommended to apply a modular style for those implementations:
Supply C modules consisting of a @code{m.c} and a @code{m.h} file each,
where the latter describes the objects exported by the module. (It is
also possible to implement computations by CPP-macros.)

The file names @code{m.h} and @code{m.c} of all such user supplied
C-modules have to be mentioned in some @code{.specs} file. Furthermore
one or several @code{.head} files or @code{.HEAD.phi} files have to be
provided. They have to contain a line

@example
   #include "m.h"
@end example

for each module @code{m}, making it available to the generated
evaluator. It is recommended to protect each @code{m.h} file against
multiple inclusion by suitable CPP-commands.

@findex .init files
@findex .finl files
@findex .INIT.phi files
@findex .FINL.phi files
If a module needs some operations for initialization or finalization
they can be written (as function calls) into files @code{m.init} or
@code{m.finl} (or into @code{.INIT.phi} or @code{.FINL.phi} files).

@node Errors, , Implementing, Specification
@comment  node-name,  next,  previous,  up
@section Specification Errors

@findex error messages
@findex warning messages
Eli checks the whole set of specifications extensively. It generates a
language processor only if no errors are found. Error reports and
warnings are obtained by a derivation like

@example
   x.specs:exe:warning
@end example

@findex help derivation
The error reports are related to the specification file (and line and
column coordinates in it) where Eli found the error symptom, if that is
possible. In the following we give hints how to react on the most common
classes of errors.  As a general rule one can obtain more information
about an error symptom by applying the derivation


@example
   x.specs:exe:help
@end example

Violations of the LIDO specification language definition are reported
with references to the @code{.lido} files. In most cases one should be
able to deduce the correction from the report text, consulting the LIDO
reference manual if necessary. Additionally the following information
might be helpful:

@menu
  Error Message                        Info Node-name
  ---------------------------------------------------------------------------
* VOID attributes not allowed here:    Void Attributes.
* Attribute Class in Conflict:         Attribute Class Conflict.
* Cycle in ... Graphs:                 Cycles.
* Errors in generated C-files:         C-Errors.
@end menu

@node Void Attributes, Attribute Class Conflict, Errors, Errors
@comment  node-name,  next,  previous,  up

A report saying

@example
   VOID attribute not allowed here
@end example

@findex VOID attribute not allowed here
in most cases indicates that an attribute is used without specifying its
type, @code{VOID} is assumed then. The reason of such an error often is a
misspelled attribute name.


It may be helpful to derive

@example
   x.specs:showFe
@end example

@findex showFe
and look at the file @code{attr.info}. It gives an overview on all
attributes the system found so far in the @code{.lido} files. (Attributes
that stem from inheritance are not yet found in this phase.)


@node Attribute Class Conflict, Cycles, Void Attributes, Errors
@comment  node-name,  next,  previous,  up

A report saying

@example
   attribute class in conflict
@end example

@findex attribute class in conflict
indicates that computations in lower contexts and in upper contexts
define that attribute. One has to rewrite them such that only one class
is used.


If problems are reported with remote dependencies one should check the
use of those constructs within the tree grammar structure. In special
difficult cases more information can be obtained by deriving

@findex ExpInfo
@findex remote dependencies
@example
   x.specs:ExpInfo
@end example

That file describes how each remote access construct can be replaced by
a set of equivalent computations propagating the accessed values through
adjacent contexts.

@node Cycles, C-Errors, Attribute Class Conflict, Errors
@comment  node-name,  next,  previous,  up

@findex cyclic dependencies
LIGA also checks whether the dependencies between the computations are
acyclic for any tree, and reports if they are cyclic. In that
case more information can be obtained by deriving


@example
   x.specs:OrdInfo
@end example

or by using the tool @code{gorto} (@pxref{top,,,gorto, GORTO - Graphical Dependency Analyzer})
for tracing dependencies graphically.

In rather seldom cases LIGA may report that it could not find an
evaluation order, although the dependencies are acyclic. If such a
situation occurs it is usually caused by several sets of far ranging
dependencies where the computations in one set are independent of those
of the other sets. Adding additional dependencies that specify some
computation sets to depend on others often solves the problem.  More
information on the problem is obtained by using @code{gorto}. It is
highly recommended NOT to try to avoid such situations before they are
reported, since they occur rather seldom.

@node C-Errors, , Cycles, Errors
@comment  node-name,  next,  previous,  up

@findex visitprocs messages
@findex compiler messages
LIGA can not perform type checking on user functions that are
called in LIDO expressions. Hence, typing errors and errors on
undefined names may be reported when the generated evaluator
is compiled. Those reports originally refer to C file named
@code{visitprocs.c}. Eli traces them back to the line of the
computation in the LIDO text where they originate from.
In most cases that will be sufficient to identify the problem.
But, one has to keep in mind that the report text is in terms of C
rather than of LIDO, and that the line number only identifies
a computation, rather than the exact line of the problem spot
within multiple line computations.
In doubtful cases it may be necessary to look at the
C code directly.

In case of undefined type
names often avalanche errors are reported by the C compiler with respect
to several product files. They can not be traced back
to some specification file.

If functions are used in a @code{.lido} file but are not made available
for the evaluator, the error might not be reported before the whole
program is linked.

@node Index, , Specification, Top
@comment  node-name,  next,  previous,  up

@unnumbered Index
@printindex fn
@contents
@bye
