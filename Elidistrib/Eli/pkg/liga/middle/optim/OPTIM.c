/* This file is part of the Eli translator construction system.

Eli is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

Eli is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with Eli; see the file COPYING.  If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* OPTIM.c - IDL read/mark/write routines generated by idlc, version 3.2 on
 * Thu Jan 10 16:37:19 1991 */
#include "OPTIM.h"
#include <stdio.h>
Action IDLtempAction;
Vocabulary IDLtempVocabulary;
#define DynMode 0
#define TwoPassMode 1
#define FlatMode 0
#define DynFormat 0
#include "writer.h"
#include "reader.h"
void MVocabulary();
void WVocabulary();
void MLVocabulary();
void WSEQVocabulary();
void MRule();
void WRule();
void MLRule();
void WSEQRule();
void MTerminal();
void WTerminal();
void MLTerminal();
void WSEQTerminal();
void MNonterminal();
void WNonterminal();
void MLNonterminal();
void WSEQNonterminal();
void MGrammar();
void WGrammar();
void MVSL();
void WVSL();
void MLVSL();
void WSEQVSL();
void MGroup();
void WGroup();
void MLGroup();
void WSEQGroup();
void MMarked();
void WMarked();
void MLMarked();
void WSEQMarked();
void MCan_Eval();
void WCan_Eval();
void MLCan_Eval();
void WSEQCan_Eval();
void MSymbols();
void WSymbols();
void MLSymbols();
void WSEQSymbols();
void MAttributes();
void WAttributes();
void MLAttributes();
void WSEQAttributes();
void MEval();
void WEval();
void MVisits();
void WVisits();
void MAction();
void WAction();
void MLAction();
void WSEQAction();
void MVisit_Seq();
void WVisit_Seq();
void MLVisit_Seq();
void WSEQVisit_Seq();
void MVisit_Sequences();
void WVisit_Sequences();
#define Poptout 2

void 
WSEQAction(S)
   register LAction S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WAction(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WAction(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLAction(S)
   register LAction S;
{
   while (S)
   {
      MAction(S->value);
      S = S->next;
   }
}
void 
WAction(C)
   Action C;
{
   switch (typeof(C))
   {
   case KVisits:
      WVisits(C.VVisits);
      break;
   case KEval:
      WEval(C.VEval);
      break;
   default:
      WError(ErrBadClassType);
      fprintf(stderr, "\tBad class is %lu\n", typeof(C));
   }
}
void 
MAction(C)
   Action C;
{
   switch (typeof(C))
   {
   case KVisits:
      MVisits(C.VVisits);
      break;
   case KEval:
      MEval(C.VEval);
      break;
   default:
      WError(ErrBadClassType);
      fprintf(stderr, "\tBad class is %lu\n", typeof(C));
   }
}
void 
WSEQVocabulary(S)
   register LVocabulary S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WVocabulary(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WVocabulary(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLVocabulary(S)
   register LVocabulary S;
{
   while (S)
   {
      MVocabulary(S->value);
      S = S->next;
   }
}
void 
WVocabulary(C)
   Vocabulary C;
{
   switch (typeof(C))
   {
   case KTerminal:
      WTerminal(C.VTerminal);
      break;
   case KNonterminal:
      WNonterminal(C.VNonterminal);
      break;
   default:
      WError(ErrBadClassType);
      fprintf(stderr, "\tBad class is %lu\n", typeof(C));
   }
}
void 
MVocabulary(C)
   Vocabulary C;
{
   switch (typeof(C))
   {
   case KTerminal:
      MTerminal(C.VTerminal);
      break;
   case KNonterminal:
      MNonterminal(C.VNonterminal);
      break;
   default:
      WError(ErrBadClassType);
      fprintf(stderr, "\tBad class is %lu\n", typeof(C));
   }
}
void 
WSEQAttributes(S)
   register LAttributes S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WAttributes(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WAttributes(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLAttributes(S)
   register LAttributes S;
{
   while (S)
   {
      MAttributes(S->value);
      S = S->next;
   }
}
void 
MAttributes(n)
   register Attributes n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 Mint(n->symbno);
      }
      {
	 Mint(n->gen);
      }
      {
	 Mint(n->typeid);
      }
      {
	 Mint(n->part);
      }
      {
	 Mint(n->class);
      }
      {
	 Mint(n->symbid);
      }
      {
	 Mint(n->attrid);
      }
      {
	 MString(n->sname);
      }
      {
	 MString(n->aname);
      }
      {
	 Mint(n->death);
      }
      {
	 Mint(n->birth);
      }
      {
	 MBoolean(n->not_used);
      }
      {
	 MBoolean(n->BnNF);
      }
      {
	 MBoolean(n->termattr);
      }
   }
}
void 
WAttributes(zzn)
   register Attributes zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Attributes");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("symbno");
      IDLoutC(AttrSep);
      Wint(zzn->symbno);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("gen");
      IDLoutC(AttrSep);
      Wint(zzn->gen);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("typeid");
      IDLoutC(AttrSep);
      Wint(zzn->typeid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("part");
      IDLoutC(AttrSep);
      Wint(zzn->part);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("class");
      IDLoutC(AttrSep);
      Wint(zzn->class);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbid");
      IDLoutC(AttrSep);
      Wint(zzn->symbid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("attrid");
      IDLoutC(AttrSep);
      Wint(zzn->attrid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("sname");
      IDLoutC(AttrSep);
      WString(zzn->sname);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("aname");
      IDLoutC(AttrSep);
      WString(zzn->aname);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("death");
      IDLoutC(AttrSep);
      Wint(zzn->death);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("birth");
      IDLoutC(AttrSep);
      Wint(zzn->birth);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("not_used");
      IDLoutC(AttrSep);
      WBoolean(zzn->not_used);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("BnNF");
      IDLoutC(AttrSep);
      WBoolean(zzn->BnNF);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("termattr");
      IDLoutC(AttrSep);
      WBoolean(zzn->termattr);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQCan_Eval(S)
   register LCan_Eval S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WCan_Eval(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WCan_Eval(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLCan_Eval(S)
   register LCan_Eval S;
{
   while (S)
   {
      MCan_Eval(S->value);
      S = S->next;
   }
}
void 
MCan_Eval(n)
   register Can_Eval n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLMarked(n->marks);
      }
      {
	 MLAction(n->actions);
      }
      {
	 Mint(n->ord);
      }
      {
	 Mint(n->symbid);
      }
   }
}
void 
WCan_Eval(zzn)
   register Can_Eval zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Can_Eval");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("marks");
      IDLoutC(AttrSep);
      WSEQMarked(zzn->marks);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("actions");
      IDLoutC(AttrSep);
      WSEQAction(zzn->actions);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("ord");
      IDLoutC(AttrSep);
      Wint(zzn->ord);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbid");
      IDLoutC(AttrSep);
      Wint(zzn->symbid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
MEval(n)
   register Eval n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLAttributes(n->birth);
      }
      {
	 MLAttributes(n->obituary);
      }
      {
	 MLAttributes(n->params);
      }
      {
	 Mint(n->col);
      }
      {
	 Mint(n->row);
      }
      {
	 Mint(n->symbno);
      }
      {
	 Mint(n->attrid);
      }
   }
}
void 
WEval(zzn)
   register Eval zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Eval");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("birth");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->birth);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("obituary");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->obituary);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("params");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->params);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("col");
      IDLoutC(AttrSep);
      Wint(zzn->col);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("row");
      IDLoutC(AttrSep);
      Wint(zzn->row);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbno");
      IDLoutC(AttrSep);
      Wint(zzn->symbno);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("attrid");
      IDLoutC(AttrSep);
      Wint(zzn->attrid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
MGrammar(n)
   register Grammar n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MNonterminal(n->startsymb);
      }
      {
	 MLRule(n->rules);
      }
      {
	 MLTerminal(n->terms);
      }
      {
	 MLNonterminal(n->nonterms);
      }
   }
}
void 
WGrammar(zzn)
   register Grammar zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Grammar");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("startsymb");
      IDLoutC(AttrSep);
      WNonterminal(zzn->startsymb);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("rules");
      IDLoutC(AttrSep);
      WSEQRule(zzn->rules);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("terms");
      IDLoutC(AttrSep);
      WSEQTerminal(zzn->terms);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("nonterms");
      IDLoutC(AttrSep);
      WSEQNonterminal(zzn->nonterms);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQGroup(S)
   register LGroup S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WGroup(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WGroup(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLGroup(S)
   register LGroup S;
{
   while (S)
   {
      MGroup(S->value);
      S = S->next;
   }
}
void 
MGroup(n)
   register Group n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLAttributes(n->members);
      }
      {
	 Mint(n->class);
      }
      {
	 MString(n->name);
      }
      {
	 Mint(n->typeid);
      }
      {
	 Mint(n->groupid);
      }
   }
}
void 
WGroup(zzn)
   register Group zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Group");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("members");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->members);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("class");
      IDLoutC(AttrSep);
      Wint(zzn->class);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("name");
      IDLoutC(AttrSep);
      WString(zzn->name);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("typeid");
      IDLoutC(AttrSep);
      Wint(zzn->typeid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("groupid");
      IDLoutC(AttrSep);
      Wint(zzn->groupid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQMarked(S)
   register LMarked S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WMarked(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WMarked(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLMarked(S)
   register LMarked S;
{
   while (S)
   {
      MMarked(S->value);
      S = S->next;
   }
}
void 
MMarked(n)
   register Marked n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 Mint(n->ord);
      }
      {
	 Mint(n->symbid);
      }
      {
	 MBoolean(n->flag);
      }
   }
}
void 
WMarked(zzn)
   register Marked zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Marked");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("ord");
      IDLoutC(AttrSep);
      Wint(zzn->ord);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbid");
      IDLoutC(AttrSep);
      Wint(zzn->symbid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("flag");
      IDLoutC(AttrSep);
      WBoolean(zzn->flag);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQNonterminal(S)
   register LNonterminal S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WNonterminal(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WNonterminal(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLNonterminal(S)
   register LNonterminal S;
{
   while (S)
   {
      MNonterminal(S->value);
      S = S->next;
   }
}
void 
MNonterminal(n)
   register Nonterminal n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 Mint(n->follow);
      }
      {
	 Mint(n->first);
      }
      {
	 Mint(n->index);
      }
      {
	 Mint(n->symbid);
      }
   }
}
void 
WNonterminal(zzn)
   register Nonterminal zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Nonterminal");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("follow");
      IDLoutC(AttrSep);
      Wint(zzn->follow);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("first");
      IDLoutC(AttrSep);
      Wint(zzn->first);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("index");
      IDLoutC(AttrSep);
      Wint(zzn->index);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbid");
      IDLoutC(AttrSep);
      Wint(zzn->symbid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQRule(S)
   register LRule S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WRule(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WRule(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLRule(S)
   register LRule S;
{
   while (S)
   {
      MRule(S->value);
      S = S->next;
   }
}
void 
MRule(n)
   register Rule n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLVocabulary(n->rhs);
      }
      {
	 MNonterminal(n->lhs);
      }
      {
	 Mint(n->prodid);
      }
   }
}
void 
WRule(zzn)
   register Rule zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Rule");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("rhs");
      IDLoutC(AttrSep);
      WSEQVocabulary(zzn->rhs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("lhs");
      IDLoutC(AttrSep);
      WNonterminal(zzn->lhs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("prodid");
      IDLoutC(AttrSep);
      Wint(zzn->prodid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQSymbols(S)
   register LSymbols S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WSymbols(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WSymbols(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLSymbols(S)
   register LSymbols S;
{
   while (S)
   {
      MSymbols(S->value);
      S = S->next;
   }
}
void 
MSymbols(n)
   register Symbols n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 Mint(n->symbno);
      }
      {
	 Mint(n->parts);
      }
      {
	 Mint(n->symbid);
      }
      {
	 MString(n->name);
      }
   }
}
void 
WSymbols(zzn)
   register Symbols zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Symbols");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("symbno");
      IDLoutC(AttrSep);
      Wint(zzn->symbno);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("parts");
      IDLoutC(AttrSep);
      Wint(zzn->parts);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbid");
      IDLoutC(AttrSep);
      Wint(zzn->symbid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("name");
      IDLoutC(AttrSep);
      WString(zzn->name);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQTerminal(S)
   register LTerminal S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WTerminal(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WTerminal(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLTerminal(S)
   register LTerminal S;
{
   while (S)
   {
      MTerminal(S->value);
      S = S->next;
   }
}
void 
MTerminal(n)
   register Terminal n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 Mint(n->follow);
      }
      {
	 Mint(n->first);
      }
      {
	 Mint(n->occ);
      }
      {
	 Mint(n->attrid);
      }
   }
}
void 
WTerminal(zzn)
   register Terminal zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Terminal");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("follow");
      IDLoutC(AttrSep);
      Wint(zzn->follow);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("first");
      IDLoutC(AttrSep);
      Wint(zzn->first);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("occ");
      IDLoutC(AttrSep);
      Wint(zzn->occ);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("attrid");
      IDLoutC(AttrSep);
      Wint(zzn->attrid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQVSL(S)
   register LVSL S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WVSL(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WVSL(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLVSL(S)
   register LVSL S;
{
   while (S)
   {
      MVSL(S->value);
      S = S->next;
   }
}
void 
MVSL(n)
   register VSL n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLAttributes(n->def_attrs);
      }
      {
	 MLAttributes(n->app_attrs);
      }
      {
	 MLAction(n->actions);
      }
      {
	 Mint(n->prodid);
      }
   }
}
void 
WVSL(zzn)
   register VSL zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("VSL");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("def_attrs");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->def_attrs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("app_attrs");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->app_attrs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("actions");
      IDLoutC(AttrSep);
      WSEQAction(zzn->actions);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("prodid");
      IDLoutC(AttrSep);
      Wint(zzn->prodid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
WSEQVisit_Seq(S)
   register LVisit_Seq S;
{
   IDLoutC(OpenAngle);
   if (S)
   {
      WVisit_Seq(S->value);
      S = S->next;
      while (S)
      {
	 IDLoutC(ListLink);
	 WVisit_Seq(S->value);
	 S = S->next;
      }
   }
   IDLoutC(CloseAngle);
}
void 
MLVisit_Seq(S)
   register LVisit_Seq S;
{
   while (S)
   {
      MVisit_Seq(S->value);
      S = S->next;
   }
}
void 
MVisit_Seq(n)
   register Visit_Seq n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLAction(n->actions);
      }
      {
	 MLAttributes(n->attrs);
      }
      {
	 MLSymbols(n->symbs);
      }
      {
	 Mint(n->prodid);
      }
   }
}
void 
WVisit_Seq(zzn)
   register Visit_Seq zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Visit_Seq");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("actions");
      IDLoutC(AttrSep);
      WSEQAction(zzn->actions);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("attrs");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->attrs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbs");
      IDLoutC(AttrSep);
      WSEQSymbols(zzn->symbs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("prodid");
      IDLoutC(AttrSep);
      Wint(zzn->prodid);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
MVisit_Sequences(n)
   register Visit_Sequences n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MGrammar(n->lt_grammar);
      }
      {
	 MLVSL(n->vsl);
      }
      {
	 MLGroup(n->groups);
      }
      {
	 MLAttributes(n->attrs);
      }
      {
	 MLSymbols(n->symbs);
      }
      {
	 MLAttributes(n->tree_attrs);
      }
      {
	 MLAttributes(n->glob_var);
      }
      {
	 MLAttributes(n->single_visit);
      }
      {
	 MLCan_Eval(n->caneval);
      }
      {
	 MLVisit_Seq(n->vi_seq);
      }
   }
}
void 
WVisit_Sequences(zzn)
   register Visit_Sequences zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Visit_Sequences");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("lt_grammar");
      IDLoutC(AttrSep);
      WGrammar(zzn->lt_grammar);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("vsl");
      IDLoutC(AttrSep);
      WSEQVSL(zzn->vsl);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("groups");
      IDLoutC(AttrSep);
      WSEQGroup(zzn->groups);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("attrs");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->attrs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbs");
      IDLoutC(AttrSep);
      WSEQSymbols(zzn->symbs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("tree_attrs");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->tree_attrs);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("glob_var");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->glob_var);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("single_visit");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->single_visit);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("caneval");
      IDLoutC(AttrSep);
      WSEQCan_Eval(zzn->caneval);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("vi_seq");
      IDLoutC(AttrSep);
      WSEQVisit_Seq(zzn->vi_seq);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
MVisits(n)
   register Visits n;
{
   if (n == NULL)
      return;
   if (NodeTouched(n))
   {
      MarkShared(n);
      return;
   } else
   {
      MarkTouched(n);
      {
	 MLAttributes(n->birth);
      }
      {
	 MLAttributes(n->obituary);
      }
      {
	 Mint(n->symbid);
      }
      {
	 Mint(n->ord);
      }
      {
	 Mint(n->symbno);
      }
   }
}
void 
WVisits(zzn)
   register Visits zzn;
{
   register String Sep;
   if (zzn == NULL)
   {
      WError(ErrNullNode);
      return;
   }
   if (!NodeTouched(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(UpArrow);
      return;
   } else if (NodeShared(zzn))
   {
      IDLoutLabel(zzn);
      IDLoutC(Colon);
      UnmarkShared(zzn);
      UnmarkTouched(zzn);
   } else
   {
      UnmarkTouched(zzn);
   }
   IDLout("Visits");
   Sep = "[";
   {
      IDLout(Sep);
      IDLout("birth");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->birth);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("obituary");
      IDLoutC(AttrSep);
      WSEQAttributes(zzn->obituary);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbid");
      IDLoutC(AttrSep);
      Wint(zzn->symbid);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("ord");
      IDLoutC(AttrSep);
      Wint(zzn->ord);
      Sep = ";\n";
   }
   {
      IDLout(Sep);
      IDLout("symbno");
      IDLoutC(AttrSep);
      Wint(zzn->symbno);
      Sep = ";\n";
   }
   if (Sep[0] != OpenBracket)
      IDLout("]\n");
}
void 
optout(filePtr, zzN
#if DynMode
       ,mode
#endif
#if DynFormat
       ,format
#endif
)
   FILE *filePtr;
   Visit_Sequences zzN;
#if DynMode
   int mode;
#endif
#if DynFormat
   int format;
#endif
{
   IDLportState = Poptout;
   IDLcurrentFile = filePtr;
#if DynMode
   switch (mode)
   {
   case FLAT:
#endif
#if (DynMode || FlatMode)
      O_Node((int) zzN);
      while (doList != NULL)
      {
	 register struct ncell *l;
	 l = doList;
	 doList = l->next;
	 O_Node(l->value);
      }
      while (doneList != NULL)
      {
	 register struct ncell *l;
	 l = doneList;
	 UnmarkTouched(l->value);
	 UnmarkShared(l->value);
	 doneList = l->next;
      }
#endif
#if DynMode
      break;
   case TWOPASS:
#endif
#if DynMode || TwoPassMode
      fprintf(IDLcurrentFile, "-- structure OPTIM\n");
      MVisit_Sequences(zzN);
      WVisit_Sequences(zzN);

#endif
#if DynMode
      break;
   default:
      WError(ErrPortMode);
   }
#endif
   fputs("#\n", IDLcurrentFile);
   return;
}
#include "reader.h"

extern ntype *IDLAllNodeTypes;
extern natype *IDLNodeAttributes;
extern int IDLnum_nodetypes;
static ntype AllNodeTypes[] = {
   {"Attributes", KAttributes},
   {"Can_Eval", KCan_Eval},
   {"Eval", KEval},
   {"Grammar", KGrammar},
   {"Group", KGroup},
   {"Marked", KMarked},
   {"Nonterminal", KNonterminal},
   {"Rule", KRule},
   {"Symbols", KSymbols},
   {"Terminal", KTerminal},
   {"VSL", KVSL},
   {"Visit_Seq", KVisit_Seq},
   {"Visit_Sequences", KVisit_Sequences},
   {"Visits", KVisits},
   {NULL, 0}
};

static natype NodeAttributes[] = {
   {{"symbno", "gen", "typeid", "part", "class", "symbid", "attrid", "sname", "aname", "death", "birth", "not_used", "BnNF", "termattr", NULL}},
   {{"marks", "actions", "ord", "symbid", NULL}},
   {{"birth", "obituary", "params", "col", "row", "symbno", "attrid", NULL}},
   {{"startsymb", "rules", "terms", "nonterms", NULL}},
   {{"members", "class", "name", "typeid", "groupid", NULL}},
   {{"ord", "symbid", "flag", NULL}},
   {{"follow", "first", "index", "symbid", NULL}},
   {{"rhs", "lhs", "prodid", NULL}},
   {{"symbno", "parts", "symbid", "name", NULL}},
   {{"follow", "first", "occ", "attrid", NULL}},
   {{"def_attrs", "app_attrs", "actions", "prodid", NULL}},
   {{"actions", "attrs", "symbs", "prodid", NULL}},
   {{"lt_grammar", "vsl", "groups", "attrs", "symbs", "tree_attrs", "glob_var", "single_visit", "caneval", "vi_seq", NULL}},
   {{"birth", "obituary", "symbid", "ord", "symbno", NULL}},
   {{NULL}}
};
static int num_nodetypes = 14;

Vocabulary GVocabulary();
LVocabulary GLVocabulary();
#define GSEQVocabulary(R) GLVocabulary(R)

#define GRule(R) ((Rule)((R)->UnionField.NodeField))
LRule GLRule();
#define GSEQRule(R) GLRule(R)

#define GTerminal(R) ((Terminal)((R)->UnionField.NodeField))
LTerminal GLTerminal();
#define GSEQTerminal(R) GLTerminal(R)

#define GNonterminal(R) ((Nonterminal)((R)->UnionField.NodeField))
LNonterminal GLNonterminal();
#define GSEQNonterminal(R) GLNonterminal(R)

#define GGrammar(R) ((Grammar)((R)->UnionField.NodeField))

#define GVSL(R) ((VSL)((R)->UnionField.NodeField))
LVSL GLVSL();
#define GSEQVSL(R) GLVSL(R)

#define GGroup(R) ((Group)((R)->UnionField.NodeField))
LGroup GLGroup();
#define GSEQGroup(R) GLGroup(R)

#define GMarked(R) ((Marked)((R)->UnionField.NodeField))
LMarked GLMarked();
#define GSEQMarked(R) GLMarked(R)

#define GCan_Eval(R) ((Can_Eval)((R)->UnionField.NodeField))
LCan_Eval GLCan_Eval();
#define GSEQCan_Eval(R) GLCan_Eval(R)

#define GSymbols(R) ((Symbols)((R)->UnionField.NodeField))
LSymbols GLSymbols();
#define GSEQSymbols(R) GLSymbols(R)

#define GAttributes(R) ((Attributes)((R)->UnionField.NodeField))
LAttributes GLAttributes();
#define GSEQAttributes(R) GLAttributes(R)

#define GEval(R) ((Eval)((R)->UnionField.NodeField))

#define GVisits(R) ((Visits)((R)->UnionField.NodeField))

Action GAction();
LAction GLAction();
#define GSEQAction(R) GLAction(R)

#define GVisit_Seq(R) ((Visit_Seq)((R)->UnionField.NodeField))
LVisit_Seq GLVisit_Seq();
#define GSEQVisit_Seq(R) GLVisit_Seq(R)

#define GVisit_Sequences(R) ((Visit_Sequences)((R)->UnionField.NodeField))

Visit_Sequences 
optin(zzF)
   FILE *zzF;
{
   Visit_Sequences zzC;
   NodeType zzN;
   NodeType OPTIMNodeAlloc();
   void OPTIMAttrStore();
   extern PF_NodeType GenericNodeAlloc;
   extern PF_AttrStore GenericAttrStore;

   IDLAllNodeTypes = AllNodeTypes;
   IDLNodeAttributes = NodeAttributes;
   IDLnum_nodetypes = num_nodetypes;
   GenericNodeAlloc = OPTIMNodeAlloc;
   GenericAttrStore = OPTIMAttrStore;
   zzN = Reader(zzF);
   if (!OK)
   {
      zzC = NULL;
   } else if (TypeNode(zzN) == KVisit_Sequences)
   {
      zzC = (Visit_Sequences) AtNode(zzN);
   } else
   {
      Error(ErrBadRootType, Lex.Pos);
      OK = 0;
      zzC = NULL;
   }
   return (zzC);
}
NodeType 
OPTIMNodeAlloc(zzN)
   register int zzN;
{
   register NodeType zznt;
   switch (zzN)
   {
   case KAttributes:
      SetNPtr(zznt, (unsigned long) NAttributes);
      break;
   case KCan_Eval:
      SetNPtr(zznt, (unsigned long) NCan_Eval);
      break;
   case KEval:
      SetNPtr(zznt, (unsigned long) NEval);
      break;
   case KGrammar:
      SetNPtr(zznt, (unsigned long) NGrammar);
      break;
   case KGroup:
      SetNPtr(zznt, (unsigned long) NGroup);
      break;
   case KMarked:
      SetNPtr(zznt, (unsigned long) NMarked);
      break;
   case KNonterminal:
      SetNPtr(zznt, (unsigned long) NNonterminal);
      break;
   case KRule:
      SetNPtr(zznt, (unsigned long) NRule);
      break;
   case KSymbols:
      SetNPtr(zznt, (unsigned long) NSymbols);
      break;
   case KTerminal:
      SetNPtr(zznt, (unsigned long) NTerminal);
      break;
   case KVSL:
      SetNPtr(zznt, (unsigned long) NVSL);
      break;
   case KVisit_Seq:
      SetNPtr(zznt, (unsigned long) NVisit_Seq);
      break;
   case KVisit_Sequences:
      SetNPtr(zznt, (unsigned long) NVisit_Sequences);
      break;
   case KVisits:
      SetNPtr(zznt, (unsigned long) NVisits);
      break;
   default:
      Error(ErrBadNodeType, Lex.Pos);
      OK = 0;
      break;
   }
   return (zznt);
}
LVocabulary 
GLVocabulary(R)
   RepType R;
{
   register SeqType S1;
   register LVocabulary S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LVocabulary) GetListCell(sizeof(CVocabulary));
      P->value = GVocabulary(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LVocabulary) GetListCell(sizeof(CVocabulary));
	 S2->value = GVocabulary(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
Vocabulary 
GVocabulary(R)
   register RepType R;
{
   Vocabulary Ret;
   switch (R->UnionField.NodeField->IDLhidden.TypeID)
   {
   case KTerminal:
      Ret.VTerminal = GTerminal(R);
      break;
   case KNonterminal:
      Ret.VNonterminal = GNonterminal(R);
      break;
   default:
      Error(ErrBadClassNode, Lex.Pos);
   }
   return (Ret);
}
LRule 
GLRule(R)
   RepType R;
{
   register SeqType S1;
   register LRule S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LRule) GetListCell(sizeof(CRule));
      P->value = GRule(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LRule) GetListCell(sizeof(CRule));
	 S2->value = GRule(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LTerminal 
GLTerminal(R)
   RepType R;
{
   register SeqType S1;
   register LTerminal S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LTerminal) GetListCell(sizeof(CTerminal));
      P->value = GTerminal(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LTerminal) GetListCell(sizeof(CTerminal));
	 S2->value = GTerminal(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LNonterminal 
GLNonterminal(R)
   RepType R;
{
   register SeqType S1;
   register LNonterminal S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LNonterminal) GetListCell(sizeof(CNonterminal));
      P->value = GNonterminal(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LNonterminal) GetListCell(sizeof(CNonterminal));
	 S2->value = GNonterminal(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LVSL 
GLVSL(R)
   RepType R;
{
   register SeqType S1;
   register LVSL S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LVSL) GetListCell(sizeof(CVSL));
      P->value = GVSL(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LVSL) GetListCell(sizeof(CVSL));
	 S2->value = GVSL(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LGroup 
GLGroup(R)
   RepType R;
{
   register SeqType S1;
   register LGroup S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LGroup) GetListCell(sizeof(CGroup));
      P->value = GGroup(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LGroup) GetListCell(sizeof(CGroup));
	 S2->value = GGroup(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LMarked 
GLMarked(R)
   RepType R;
{
   register SeqType S1;
   register LMarked S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LMarked) GetListCell(sizeof(CMarked));
      P->value = GMarked(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LMarked) GetListCell(sizeof(CMarked));
	 S2->value = GMarked(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LCan_Eval 
GLCan_Eval(R)
   RepType R;
{
   register SeqType S1;
   register LCan_Eval S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LCan_Eval) GetListCell(sizeof(CCan_Eval));
      P->value = GCan_Eval(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LCan_Eval) GetListCell(sizeof(CCan_Eval));
	 S2->value = GCan_Eval(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LSymbols 
GLSymbols(R)
   RepType R;
{
   register SeqType S1;
   register LSymbols S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LSymbols) GetListCell(sizeof(CSymbols));
      P->value = GSymbols(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LSymbols) GetListCell(sizeof(CSymbols));
	 S2->value = GSymbols(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LAttributes 
GLAttributes(R)
   RepType R;
{
   register SeqType S1;
   register LAttributes S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LAttributes) GetListCell(sizeof(CAttributes));
      P->value = GAttributes(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LAttributes) GetListCell(sizeof(CAttributes));
	 S2->value = GAttributes(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
LAction 
GLAction(R)
   RepType R;
{
   register SeqType S1;
   register LAction S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LAction) GetListCell(sizeof(CAction));
      P->value = GAction(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LAction) GetListCell(sizeof(CAction));
	 S2->value = GAction(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
Action 
GAction(R)
   register RepType R;
{
   Action Ret;
   switch (R->UnionField.NodeField->IDLhidden.TypeID)
   {
   case KVisits:
      Ret.VVisits = GVisits(R);
      break;
   case KEval:
      Ret.VEval = GEval(R);
      break;
   default:
      Error(ErrBadClassNode, Lex.Pos);
   }
   return (Ret);
}
LVisit_Seq 
GLVisit_Seq(R)
   RepType R;
{
   register SeqType S1;
   register LVisit_Seq S2, P, retval;
   S1 = R->UnionField.seqVal;
   if (S1)
   {
      retval = P = (LVisit_Seq) GetListCell(sizeof(CVisit_Seq));
      P->value = GVisit_Seq(S1->value);
      S1 = S1->next;
      while (S1)
      {
	 S2 = (LVisit_Seq) GetListCell(sizeof(CVisit_Seq));
	 S2->value = GVisit_Seq(S1->value);
	 P->next = S2;
	 P = S2;
	 S1 = S1->next;
      }
      P->next = NULL;
   } else
      retval = NULL;
   return (retval);
}
void 
OPTIMAttrStore(N, A, R)
   register NodeType N;
   register AttrDesc A;
   register RepType R;
{
   switch (N->IDLhidden.TypeID)
   {
   case KAttributes:
      switch (A)
      {
      case 1:
	 ((Attributes) (N))->symbno = Gint(R);
	 break;
      case 2:
	 ((Attributes) (N))->gen = Gint(R);
	 break;
      case 3:
	 ((Attributes) (N))->typeid = Gint(R);
	 break;
      case 4:
	 ((Attributes) (N))->part = Gint(R);
	 break;
      case 5:
	 ((Attributes) (N))->class = Gint(R);
	 break;
      case 6:
	 ((Attributes) (N))->symbid = Gint(R);
	 break;
      case 7:
	 ((Attributes) (N))->attrid = Gint(R);
	 break;
      case 8:
	 ((Attributes) (N))->sname = GString(R);
	 break;
      case 9:
	 ((Attributes) (N))->aname = GString(R);
	 break;
      case 10:
	 ((Attributes) (N))->death = Gint(R);
	 break;
      case 11:
	 ((Attributes) (N))->birth = Gint(R);
	 break;
      case 12:
	 ((Attributes) (N))->not_used = GBoolean(R);
	 break;
      case 13:
	 ((Attributes) (N))->BnNF = GBoolean(R);
	 break;
      case 14:
	 ((Attributes) (N))->termattr = GBoolean(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KCan_Eval:
      switch (A)
      {
      case 1:
	 ((Can_Eval) (N))->marks = GSEQMarked(R);
	 break;
      case 2:
	 ((Can_Eval) (N))->actions = GSEQAction(R);
	 break;
      case 3:
	 ((Can_Eval) (N))->ord = Gint(R);
	 break;
      case 4:
	 ((Can_Eval) (N))->symbid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KEval:
      switch (A)
      {
      case 1:
	 ((Eval) (N))->birth = GSEQAttributes(R);
	 break;
      case 2:
	 ((Eval) (N))->obituary = GSEQAttributes(R);
	 break;
      case 3:
	 ((Eval) (N))->params = GSEQAttributes(R);
	 break;
      case 4:
	 ((Eval) (N))->col = Gint(R);
	 break;
      case 5:
	 ((Eval) (N))->row = Gint(R);
	 break;
      case 6:
	 ((Eval) (N))->symbno = Gint(R);
	 break;
      case 7:
	 ((Eval) (N))->attrid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KGrammar:
      switch (A)
      {
      case 1:
	 ((Grammar) (N))->startsymb = GNonterminal(R);
	 break;
      case 2:
	 ((Grammar) (N))->rules = GSEQRule(R);
	 break;
      case 3:
	 ((Grammar) (N))->terms = GSEQTerminal(R);
	 break;
      case 4:
	 ((Grammar) (N))->nonterms = GSEQNonterminal(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KGroup:
      switch (A)
      {
      case 1:
	 ((Group) (N))->members = GSEQAttributes(R);
	 break;
      case 2:
	 ((Group) (N))->class = Gint(R);
	 break;
      case 3:
	 ((Group) (N))->name = GString(R);
	 break;
      case 4:
	 ((Group) (N))->typeid = Gint(R);
	 break;
      case 5:
	 ((Group) (N))->groupid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KMarked:
      switch (A)
      {
      case 1:
	 ((Marked) (N))->ord = Gint(R);
	 break;
      case 2:
	 ((Marked) (N))->symbid = Gint(R);
	 break;
      case 3:
	 ((Marked) (N))->flag = GBoolean(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KNonterminal:
      switch (A)
      {
      case 1:
	 ((Nonterminal) (N))->follow = Gint(R);
	 break;
      case 2:
	 ((Nonterminal) (N))->first = Gint(R);
	 break;
      case 3:
	 ((Nonterminal) (N))->index = Gint(R);
	 break;
      case 4:
	 ((Nonterminal) (N))->symbid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KRule:
      switch (A)
      {
      case 1:
	 ((Rule) (N))->rhs = GSEQVocabulary(R);
	 break;
      case 2:
	 ((Rule) (N))->lhs = GNonterminal(R);
	 break;
      case 3:
	 ((Rule) (N))->prodid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KSymbols:
      switch (A)
      {
      case 1:
	 ((Symbols) (N))->symbno = Gint(R);
	 break;
      case 2:
	 ((Symbols) (N))->parts = Gint(R);
	 break;
      case 3:
	 ((Symbols) (N))->symbid = Gint(R);
	 break;
      case 4:
	 ((Symbols) (N))->name = GString(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KTerminal:
      switch (A)
      {
      case 1:
	 ((Terminal) (N))->follow = Gint(R);
	 break;
      case 2:
	 ((Terminal) (N))->first = Gint(R);
	 break;
      case 3:
	 ((Terminal) (N))->occ = Gint(R);
	 break;
      case 4:
	 ((Terminal) (N))->attrid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KVSL:
      switch (A)
      {
      case 1:
	 ((VSL) (N))->def_attrs = GSEQAttributes(R);
	 break;
      case 2:
	 ((VSL) (N))->app_attrs = GSEQAttributes(R);
	 break;
      case 3:
	 ((VSL) (N))->actions = GSEQAction(R);
	 break;
      case 4:
	 ((VSL) (N))->prodid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KVisit_Seq:
      switch (A)
      {
      case 1:
	 ((Visit_Seq) (N))->actions = GSEQAction(R);
	 break;
      case 2:
	 ((Visit_Seq) (N))->attrs = GSEQAttributes(R);
	 break;
      case 3:
	 ((Visit_Seq) (N))->symbs = GSEQSymbols(R);
	 break;
      case 4:
	 ((Visit_Seq) (N))->prodid = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KVisit_Sequences:
      switch (A)
      {
      case 1:
	 ((Visit_Sequences) (N))->lt_grammar = GGrammar(R);
	 break;
      case 2:
	 ((Visit_Sequences) (N))->vsl = GSEQVSL(R);
	 break;
      case 3:
	 ((Visit_Sequences) (N))->groups = GSEQGroup(R);
	 break;
      case 4:
	 ((Visit_Sequences) (N))->attrs = GSEQAttributes(R);
	 break;
      case 5:
	 ((Visit_Sequences) (N))->symbs = GSEQSymbols(R);
	 break;
      case 6:
	 ((Visit_Sequences) (N))->tree_attrs = GSEQAttributes(R);
	 break;
      case 7:
	 ((Visit_Sequences) (N))->glob_var = GSEQAttributes(R);
	 break;
      case 8:
	 ((Visit_Sequences) (N))->single_visit = GSEQAttributes(R);
	 break;
      case 9:
	 ((Visit_Sequences) (N))->caneval = GSEQCan_Eval(R);
	 break;
      case 10:
	 ((Visit_Sequences) (N))->vi_seq = GSEQVisit_Seq(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   case KVisits:
      switch (A)
      {
      case 1:
	 ((Visits) (N))->birth = GSEQAttributes(R);
	 break;
      case 2:
	 ((Visits) (N))->obituary = GSEQAttributes(R);
	 break;
      case 3:
	 ((Visits) (N))->symbid = Gint(R);
	 break;
      case 4:
	 ((Visits) (N))->ord = Gint(R);
	 break;
      case 5:
	 ((Visits) (N))->symbno = Gint(R);
	 break;
      default:
	 Error(ErrBadAttribute, Lex.Pos);
      } break;
   default:
      Error(ErrBadNodeType, Lex.Pos);
      break;
   }
   DelRep(R);
}
