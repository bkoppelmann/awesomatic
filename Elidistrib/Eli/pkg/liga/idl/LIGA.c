/* $Id: LIGA.c,v 4.1 1997/08/29 08:26:49 peter Exp $ */
/* LIGA.c - IDL read/mark/write routines generated by idlc, version 3.2 
    on Tue Jul  9 18:58:27 1991
*/
/* This file is part of the Eli translator construction system.

Eli is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

Eli is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with Eli; see the file COPYING.  If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

# include "LIGA.h"
# include <stdio.h>
Def IDLtempDef;
Unit IDLtempUnit;
Entity IDLtempEntity;
Attrrule IDLtempAttrrule;
Expr IDLtempExpr;
# define DynMode 0
# define TwoPassMode 1
# define FlatMode 0
# define DynFormat 0
# include "writer.h"
void MSymbattr();
void WSymbattr();
void MLSymbattr();
void WSEQSymbattr();
void MConstit();
void WConstit();
void MIncluding();
void WIncluding();
void MChainacc();
void WChainacc();
void MAttracc();
void WAttracc();
void MName();
void WName();
void MVal();
void WVal();
void MExpr();
void WExpr();
void MLExpr();
void WSEQExpr();
void MCall();
void WCall();
void MTransfer();
void WTransfer();
void MVisit();
void WVisit();
void MChainStart();
void WChainStart();
void MAttrrule();
void WAttrrule();
void MLAttrrule();
void WSEQAttrrule();
void MAttribution();
void WAttribution();
void MLAttribution();
void WSEQAttribution();
void MDelopt();
void WDelopt();
void MDelim();
void WDelim();
void MPlus();
void WPlus();
void MStar();
void WStar();
void MOpt();
void WOpt();
void MLiteral();
void WLiteral();
void MSymbol();
void WSymbol();
void MUnit();
void WUnit();
void MLUnit();
void WSEQUnit();
void MEntity();
void WEntity();
void MLEntity();
void WSEQEntity();
void MProd();
void WProd();
void MAttrdef();
void WAttrdef();
void MLAttrdef();
void WSEQAttrdef();
void MSymb();
void WSymb();
void MTypedef();
void WTypedef();
void MChain();
void WChain();
void MDef();
void WDef();
void MLDef();
void WSEQDef();
void MAttrEval();
void WAttrEval();
/* extern void MString(); */
void MLString();
void WSEQString();
/* extern void Mint(); */
void MLint();
void WSEQint();
# define Pligaout 2

void WSEQDef(S)
register LDef S;
{	IDLoutC(OpenAngle);
	if (S) {
		WDef(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WDef(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLDef(S)
register LDef S;
{
		while (S) {
		    MDef(S->value);
		    S = S->next;
		}
}
void WDef (C)
Def C;
{
	switch(typeof(C)) {
		case KChain: WChain(C.VChain); break;
		case KTypedef: WTypedef(C.VTypedef); break;
		case KSymb: WSymb(C.VSymb); break;
		case KProd: WProd(C.VProd); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void MDef (C)
Def C;
{
	switch(typeof(C)) {
		case KChain: MChain(C.VChain); break;
		case KTypedef: MTypedef(C.VTypedef); break;
		case KSymb: MSymb(C.VSymb); break;
		case KProd: MProd(C.VProd); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQUnit(S)
register LUnit S;
{	IDLoutC(OpenAngle);
	if (S) {
		WUnit(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WUnit(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLUnit(S)
register LUnit S;
{
		while (S) {
		    MUnit(S->value);
		    S = S->next;
		}
}
void WUnit (C)
Unit C;
{
	switch(typeof(C)) {
		case KSymbol: WSymbol(C.VSymbol); break;
		case KLiteral: WLiteral(C.VLiteral); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void MUnit (C)
Unit C;
{
	switch(typeof(C)) {
		case KSymbol: MSymbol(C.VSymbol); break;
		case KLiteral: MLiteral(C.VLiteral); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQEntity(S)
register LEntity S;
{	IDLoutC(OpenAngle);
	if (S) {
		WEntity(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WEntity(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLEntity(S)
register LEntity S;
{
		while (S) {
		    MEntity(S->value);
		    S = S->next;
		}
}
void WEntity (C)
Entity C;
{
	switch(typeof(C)) {
		case KLiteral: WLiteral(C.VLiteral); break;
		case KSymbol: WSymbol(C.VSymbol); break;
		case KOpt: WOpt(C.VOpt); break;
		case KStar: WStar(C.VStar); break;
		case KPlus: WPlus(C.VPlus); break;
		case KDelim: WDelim(C.VDelim); break;
		case KDelopt: WDelopt(C.VDelopt); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void MEntity (C)
Entity C;
{
	switch(typeof(C)) {
		case KLiteral: MLiteral(C.VLiteral); break;
		case KSymbol: MSymbol(C.VSymbol); break;
		case KOpt: MOpt(C.VOpt); break;
		case KStar: MStar(C.VStar); break;
		case KPlus: MPlus(C.VPlus); break;
		case KDelim: MDelim(C.VDelim); break;
		case KDelopt: MDelopt(C.VDelopt); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQAttrrule(S)
register LAttrrule S;
{	IDLoutC(OpenAngle);
	if (S) {
		WAttrrule(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WAttrrule(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLAttrrule(S)
register LAttrrule S;
{
		while (S) {
		    MAttrrule(S->value);
		    S = S->next;
		}
}
void WAttrrule (C)
Attrrule C;
{
	switch(typeof(C)) {
		case KCall: WCall(C.VCall); break;
		case KVisit: WVisit(C.VVisit); break;
		case KTransfer: WTransfer(C.VTransfer); break;
		case KChainStart: WChainStart(C.VChainStart); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void MAttrrule (C)
Attrrule C;
{
	switch(typeof(C)) {
		case KCall: MCall(C.VCall); break;
		case KVisit: MVisit(C.VVisit); break;
		case KTransfer: MTransfer(C.VTransfer); break;
		case KChainStart: MChainStart(C.VChainStart); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void WSEQExpr(S)
register LExpr S;
{	IDLoutC(OpenAngle);
	if (S) {
		WExpr(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WExpr(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLExpr(S)
register LExpr S;
{
		while (S) {
		    MExpr(S->value);
		    S = S->next;
		}
}
void WExpr (C)
Expr C;
{
	switch(typeof(C)) {
		case KCall: WCall(C.VCall); break;
		case KLiteral: WLiteral(C.VLiteral); break;
		case KVal: WVal(C.VVal); break;
		case KName: WName(C.VName); break;
		case KAttracc: WAttracc(C.VAttracc); break;
		case KChainacc: WChainacc(C.VChainacc); break;
		case KConstit: WConstit(C.VConstit); break;
		case KIncluding: WIncluding(C.VIncluding); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void MExpr (C)
Expr C;
{
	switch(typeof(C)) {
		case KCall: MCall(C.VCall); break;
		case KLiteral: MLiteral(C.VLiteral); break;
		case KVal: MVal(C.VVal); break;
		case KName: MName(C.VName); break;
		case KAttracc: MAttracc(C.VAttracc); break;
		case KChainacc: MChainacc(C.VChainacc); break;
		case KConstit: MConstit(C.VConstit); break;
		case KIncluding: MIncluding(C.VIncluding); break;
		default: WError(ErrBadClassType);
		         fprintf(stderr, "\tBad class is %lu\n",typeof(C));
	}
}
void MAttrEval(n)
register AttrEval n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLAttribution(n->attrrules);}
		{MLDef(n->defseq);}
	}
}
void WAttrEval(zzn)
register AttrEval zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("AttrEval"); Sep = "[";
	{IDLout(Sep); IDLout("attrrules"); IDLoutC(AttrSep);
	WSEQAttribution(zzn->attrrules);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("defseq"); IDLoutC(AttrSep);
	WSEQDef(zzn->defseq);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MAttracc(n)
register Attracc n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{Mint(n->attrid);}
		{Mint(n->symbno);}
	}
}
void WAttracc(zzn)
register Attracc zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Attracc"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("attrid"); IDLoutC(AttrSep);
	Wint(zzn->attrid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("symbno"); IDLoutC(AttrSep);
	Wint(zzn->symbno);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void WSEQAttrdef(S)
register LAttrdef S;
{	IDLoutC(OpenAngle);
	if (S) {
		WAttrdef(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WAttrdef(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLAttrdef(S)
register LAttrdef S;
{
		while (S) {
		    MAttrdef(S->value);
		    S = S->next;
		}
}
void MAttrdef(n)
register Attrdef n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MString(n->globname);}
		{Mint(n->part);}
		{Mint(n->gen);}
		{Mint(n->store);}
		{Mint(n->prodid);}
		{Mint(n->class);}
		{Mint(n->typeid);}
		{Mint(n->col);}
		{Mint(n->row);}
		{MString(n->name);}
		{Mint(n->did);}
	}
}
void WAttrdef(zzn)
register Attrdef zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Attrdef"); Sep = "[";
	{IDLout(Sep); IDLout("globname"); IDLoutC(AttrSep);
	WString(zzn->globname);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("part"); IDLoutC(AttrSep);
	Wint(zzn->part);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("gen"); IDLoutC(AttrSep);
	Wint(zzn->gen);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("store"); IDLoutC(AttrSep);
	Wint(zzn->store);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("prodid"); IDLoutC(AttrSep);
	Wint(zzn->prodid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("class"); IDLoutC(AttrSep);
	Wint(zzn->class);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("typeid"); IDLoutC(AttrSep);
	Wint(zzn->typeid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("name"); IDLoutC(AttrSep);
	WString(zzn->name);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void WSEQAttribution(S)
register LAttribution S;
{	IDLoutC(OpenAngle);
	if (S) {
		WAttribution(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WAttribution(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLAttribution(S)
register LAttribution S;
{
		while (S) {
		    MAttribution(S->value);
		    S = S->next;
		}
}
void MAttribution(n)
register Attribution n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLAttrrule(n->attrrules);}
		{Mint(n->prodid);}
	}
}
void WAttribution(zzn)
register Attribution zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Attribution"); Sep = "[";
	{IDLout(Sep); IDLout("attrrules"); IDLoutC(AttrSep);
	WSEQAttrrule(zzn->attrrules);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("prodid"); IDLoutC(AttrSep);
	Wint(zzn->prodid);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MCall(n)
register Call n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{MLExpr(n->params);}
		{MString(n->name);}
	}
}
void WCall(zzn)
register Call zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Call"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("params"); IDLoutC(AttrSep);
	WSEQExpr(zzn->params);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("name"); IDLoutC(AttrSep);
	WString(zzn->name);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MChain(n)
register Chain n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{MString(n->dname);}
		{Mint(n->row);}
		{Mint(n->col);}
		{Mint(n->typeid);}
	}
}
void WChain(zzn)
register Chain zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Chain"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("dname"); IDLoutC(AttrSep);
	WString(zzn->dname);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("typeid"); IDLoutC(AttrSep);
	Wint(zzn->typeid);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MChainStart(n)
register ChainStart n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{MString(n->postgenattr);}
		{MString(n->pregenattr);}
		{Mint(n->chainid);}
	}
}
void WChainStart(zzn)
register ChainStart zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("ChainStart"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("postgenattr"); IDLoutC(AttrSep);
	WString(zzn->postgenattr);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("pregenattr"); IDLoutC(AttrSep);
	WString(zzn->pregenattr);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("chainid"); IDLoutC(AttrSep);
	Wint(zzn->chainid);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MChainacc(n)
register Chainacc n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{Mint(n->chainid);}
		{Mint(n->symbno);}
	}
}
void WChainacc(zzn)
register Chainacc zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Chainacc"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("chainid"); IDLoutC(AttrSep);
	Wint(zzn->chainid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("symbno"); IDLoutC(AttrSep);
	Wint(zzn->symbno);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MConstit(n)
register Constit n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{MLSymbattr(n->constattrs);}
		{Mint(n->subtree);}
		{Mint(n->single);}
		{MString(n->genattr);}
	}
}
void WConstit(zzn)
register Constit zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Constit"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("constattrs"); IDLoutC(AttrSep);
	WSEQSymbattr(zzn->constattrs);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("subtree"); IDLoutC(AttrSep);
	Wint(zzn->subtree);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("single"); IDLoutC(AttrSep);
	Wint(zzn->single);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("genattr"); IDLoutC(AttrSep);
	WString(zzn->genattr);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MDelim(n)
register Delim n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLiteral(n->del);}
		{MLUnit(n->rhs);}
	}
}
void WDelim(zzn)
register Delim zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Delim"); Sep = "[";
	{IDLout(Sep); IDLout("del"); IDLoutC(AttrSep);
	WLiteral(zzn->del);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQUnit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MDelopt(n)
register Delopt n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLiteral(n->del);}
		{MLUnit(n->rhs);}
	}
}
void WDelopt(zzn)
register Delopt zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Delopt"); Sep = "[";
	{IDLout(Sep); IDLout("del"); IDLoutC(AttrSep);
	WLiteral(zzn->del);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQUnit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MIncluding(n)
register Including n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{MLSymbattr(n->inclattrs);}
		{Mint(n->genattrid);}
		{MString(n->genattr);}
	}
}
void WIncluding(zzn)
register Including zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Including"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("inclattrs"); IDLoutC(AttrSep);
	WSEQSymbattr(zzn->inclattrs);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("genattrid"); IDLoutC(AttrSep);
	Wint(zzn->genattrid);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("genattr"); IDLoutC(AttrSep);
	WString(zzn->genattr);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MLiteral(n)
register Literal n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->row);}
		{Mint(n->col);}
		{MString(n->str);}
	}
}
void WLiteral(zzn)
register Literal zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Literal"); Sep = "[";
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("str"); IDLoutC(AttrSep);
	WString(zzn->str);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MName(n)
register Name n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{MString(n->n);}
	}
}
void WName(zzn)
register Name zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Name"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("n"); IDLoutC(AttrSep);
	WString(zzn->n);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MOpt(n)
register Opt n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLUnit(n->rhs);}
	}
}
void WOpt(zzn)
register Opt zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Opt"); Sep = "[";
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQUnit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MPlus(n)
register Plus n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLUnit(n->rhs);}
	}
}
void WPlus(zzn)
register Plus zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Plus"); Sep = "[";
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQUnit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MProd(n)
register Prod n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{MString(n->dname);}
		{Mint(n->row);}
		{Mint(n->col);}
		{MLEntity(n->rhs);}
		{Mint(n->lhs);}
	}
}
void WProd(zzn)
register Prod zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Prod"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("dname"); IDLoutC(AttrSep);
	WString(zzn->dname);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQEntity(zzn->rhs);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("lhs"); IDLoutC(AttrSep);
	Wint(zzn->lhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MStar(n)
register Star n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{MLUnit(n->rhs);}
	}
}
void WStar(zzn)
register Star zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Star"); Sep = "[";
	{IDLout(Sep); IDLout("rhs"); IDLoutC(AttrSep);
	WSEQUnit(zzn->rhs);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MSymb(n)
register Symb n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{MString(n->dname);}
		{Mint(n->row);}
		{Mint(n->col);}
		{MLAttrdef(n->attrs);}
		{Mint(n->tornt);}
	}
}
void WSymb(zzn)
register Symb zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Symb"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("dname"); IDLoutC(AttrSep);
	WString(zzn->dname);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("attrs"); IDLoutC(AttrSep);
	WSEQAttrdef(zzn->attrs);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("tornt"); IDLoutC(AttrSep);
	Wint(zzn->tornt);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void WSEQSymbattr(S)
register LSymbattr S;
{	IDLoutC(OpenAngle);
	if (S) {
		WSymbattr(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WSymbattr(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLSymbattr(S)
register LSymbattr S;
{
		while (S) {
		    MSymbattr(S->value);
		    S = S->next;
		}
}
void MSymbattr(n)
register Symbattr n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->attrdef);}
		{Mint(n->symbdef);}
	}
}
void WSymbattr(zzn)
register Symbattr zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Symbattr"); Sep = "[";
	{IDLout(Sep); IDLout("attrdef"); IDLoutC(AttrSep);
	Wint(zzn->attrdef);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("symbdef"); IDLoutC(AttrSep);
	Wint(zzn->symbdef);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MSymbol(n)
register Symbol n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->row);}
		{Mint(n->col);}
		{Mint(n->did);}
	}
}
void WSymbol(zzn)
register Symbol zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Symbol"); Sep = "[";
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MTransfer(n)
register Transfer n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{MLString(n->attrs);}
		{MLint(n->symbno);}
	}
}
void WTransfer(zzn)
register Transfer zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Transfer"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("attrs"); IDLoutC(AttrSep);
	WSEQString(zzn->attrs);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("symbno"); IDLoutC(AttrSep);
	WSEQint(zzn->symbno);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MTypedef(n)
register Typedef n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->did);}
		{MString(n->dname);}
		{Mint(n->row);}
		{Mint(n->col);}
		{Mint(n->listedto);}
		{MString(n->extname);}
	}
}
void WTypedef(zzn)
register Typedef zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Typedef"); Sep = "[";
	{IDLout(Sep); IDLout("did"); IDLoutC(AttrSep);
	Wint(zzn->did);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("dname"); IDLoutC(AttrSep);
	WString(zzn->dname);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("listedto"); IDLoutC(AttrSep);
	Wint(zzn->listedto);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("extname"); IDLoutC(AttrSep);
	WString(zzn->extname);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MVal(n)
register Val n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->col);}
		{Mint(n->row);}
		{Mint(n->v);}
	}
}
void WVal(zzn)
register Val zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Val"); Sep = "[";
	{IDLout(Sep); IDLout("col"); IDLoutC(AttrSep);
	Wint(zzn->col);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("row"); IDLoutC(AttrSep);
	Wint(zzn->row);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("v"); IDLoutC(AttrSep);
	Wint(zzn->v);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void MVisit(n)
register Visit n;
{
	if (n==NULL) return;
	if (NodeTouched(n)) {
		MarkShared(n); return; }
	else {
		MarkTouched(n);
		{Mint(n->ord);}
		{Mint(n->symbno);}
	}
}
void WVisit(zzn)
register Visit zzn;
{
	register String Sep;
	if (zzn==NULL) {WError(ErrNullNode); return; }
	if (!NodeTouched(zzn)) {IDLoutLabel(zzn); IDLoutC(UpArrow); return; }
	else if (NodeShared(zzn)) {
		IDLoutLabel(zzn); IDLoutC(Colon);
		UnmarkShared(zzn); UnmarkTouched(zzn);
	} else {UnmarkTouched(zzn); }
	IDLout("Visit"); Sep = "[";
	{IDLout(Sep); IDLout("ord"); IDLoutC(AttrSep);
	Wint(zzn->ord);
	Sep = ";\n";
	}
	{IDLout(Sep); IDLout("symbno"); IDLoutC(AttrSep);
	Wint(zzn->symbno);
	Sep = ";\n";
	}
	if (Sep[0] != OpenBracket) IDLout("]\n");
}
void WSEQString(S)
register LString S;
{	IDLoutC(OpenAngle);
	if (S) {
		WString(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    WString(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLString(S)
register LString S;
{
		while (S) {
		    MString(S->value);
		    S = S->next;
		}
}
void WSEQint(S)
register Lint S;
{	IDLoutC(OpenAngle);
	if (S) {
		Wint(S->value);
		S = S->next;
		while (S) {
		    IDLoutC(ListLink);
		    Wint(S->value);
		    S = S->next;
		}
	}
	IDLoutC(CloseAngle);
}
void MLint(S)
register Lint S;
{
		while (S) {
		    Mint(S->value);
		    S = S->next;
		}
}
void ligaout (filePtr, zzN
# if DynMode
, mode
# endif
# if DynFormat
, format
# endif
)
FILE * filePtr;
AttrEval zzN;
# if DynMode
int mode;
# endif
# if DynFormat
int format;
# endif
{	IDLportState = Pligaout;
	IDLcurrentFile = filePtr;
# if DynMode
	switch (mode) {
	case FLAT:
# endif
# if (DynMode || FlatMode)
		O_Node((int)zzN);
		while (doList != NULL) {
		   register struct ncell *l;
		   l = doList; doList = l->next;
		   O_Node(l->value); FreeHeap(l);
		}
		while (doneList != NULL) {
		    register struct ncell *l;
		    l = doneList;
		    UnmarkTouched(l->value); 
		    UnmarkShared(l->value);
		    doneList = l->next;FreeHeap(l);
		}
# endif
# if DynMode
		break;
	case TWOPASS:
# endif
# if DynMode || TwoPassMode
		fprintf(IDLcurrentFile, "-- structure LIGA\n");
		MAttrEval(zzN);
		WAttrEval(zzN);

# endif
# if DynMode
		break;
	default:
		WError(ErrPortMode);
	}
# endif
	fputs("#\n", IDLcurrentFile);
	return;
}
# include "reader.h"
Boolean ReaderOK;
extern ntype *IDLAllNodeTypes;
extern natype *IDLNodeAttributes;
extern int IDLnum_nodetypes;
static ntype AllNodeTypes[] = {
  { "AttrEval", KAttrEval },
  { "Attracc", KAttracc },
  { "Attrdef", KAttrdef },
  { "Attribution", KAttribution },
  { "Call", KCall },
  { "Chain", KChain },
  { "ChainStart", KChainStart },
  { "Chainacc", KChainacc },
  { "Constit", KConstit },
  { "Delim", KDelim },
  { "Delopt", KDelopt },
  { "Including", KIncluding },
  { "Literal", KLiteral },
  { "Name", KName },
  { "Opt", KOpt },
  { "Plus", KPlus },
  { "Prod", KProd },
  { "Star", KStar },
  { "Symb", KSymb },
  { "Symbattr", KSymbattr },
  { "Symbol", KSymbol },
  { "Transfer", KTransfer },
  { "Typedef", KTypedef },
  { "Val", KVal },
  { "Visit", KVisit },
  { NULL, 0}
};
static natype NodeAttributes[] = {
  { "attrrules", "defseq", NULL },
  { "col", "row", "attrid", "symbno", NULL },
  { "globname", "part", "gen", "store", "prodid", "class", "typeid", "col", "row", "name", "did", NULL },
  { "attrrules", "prodid", NULL },
  { "col", "row", "params", "name", NULL },
  { "did", "dname", "row", "col", "typeid", NULL },
  { "col", "row", "postgenattr", "pregenattr", "chainid", NULL },
  { "col", "row", "chainid", "symbno", NULL },
  { "col", "row", "constattrs", "subtree", "single", "genattr", NULL },
  { "del", "rhs", NULL },
  { "del", "rhs", NULL },
  { "col", "row", "inclattrs", "genattrid", "genattr", NULL },
  { "row", "col", "str", NULL },
  { "col", "row", "n", NULL },
  { "rhs", NULL },
  { "rhs", NULL },
  { "did", "dname", "row", "col", "rhs", "lhs", NULL },
  { "rhs", NULL },
  { "did", "dname", "row", "col", "attrs", "tornt", NULL },
  { "attrdef", "symbdef", NULL },
  { "row", "col", "did", NULL },
  { "col", "row", "attrs", "symbno", NULL },
  { "did", "dname", "row", "col", "listedto", "extname", NULL },
  { "col", "row", "v", NULL },
  { "ord", "symbno", NULL },
  { NULL }
};
static int num_nodetypes  = 25;
static int max_attributes  = 12;
# define GSymbattr(R) ((Symbattr)((R)->UnionField.NodeField))
LSymbattr GLSymbattr();
#define GSEQSymbattr(R) GLSymbattr(R)

# define GConstit(R) ((Constit)((R)->UnionField.NodeField))

# define GIncluding(R) ((Including)((R)->UnionField.NodeField))

# define GChainacc(R) ((Chainacc)((R)->UnionField.NodeField))

# define GAttracc(R) ((Attracc)((R)->UnionField.NodeField))

# define GName(R) ((Name)((R)->UnionField.NodeField))

# define GVal(R) ((Val)((R)->UnionField.NodeField))

Expr GExpr();
LExpr GLExpr();
#define GSEQExpr(R) GLExpr(R)

# define GCall(R) ((Call)((R)->UnionField.NodeField))

# define GTransfer(R) ((Transfer)((R)->UnionField.NodeField))

# define GVisit(R) ((Visit)((R)->UnionField.NodeField))

# define GChainStart(R) ((ChainStart)((R)->UnionField.NodeField))

Attrrule GAttrrule();
LAttrrule GLAttrrule();
#define GSEQAttrrule(R) GLAttrrule(R)

# define GAttribution(R) ((Attribution)((R)->UnionField.NodeField))
LAttribution GLAttribution();
#define GSEQAttribution(R) GLAttribution(R)

# define GDelopt(R) ((Delopt)((R)->UnionField.NodeField))

# define GDelim(R) ((Delim)((R)->UnionField.NodeField))

# define GPlus(R) ((Plus)((R)->UnionField.NodeField))

# define GStar(R) ((Star)((R)->UnionField.NodeField))

# define GOpt(R) ((Opt)((R)->UnionField.NodeField))

# define GLiteral(R) ((Literal)((R)->UnionField.NodeField))

# define GSymbol(R) ((Symbol)((R)->UnionField.NodeField))

Unit GUnit();
LUnit GLUnit();
#define GSEQUnit(R) GLUnit(R)

Entity GEntity();
LEntity GLEntity();
#define GSEQEntity(R) GLEntity(R)

# define GProd(R) ((Prod)((R)->UnionField.NodeField))

# define GAttrdef(R) ((Attrdef)((R)->UnionField.NodeField))
LAttrdef GLAttrdef();
#define GSEQAttrdef(R) GLAttrdef(R)

# define GSymb(R) ((Symb)((R)->UnionField.NodeField))

# define GTypedef(R) ((Typedef)((R)->UnionField.NodeField))

# define GChain(R) ((Chain)((R)->UnionField.NodeField))

Def GDef();
LDef GLDef();
#define GSEQDef(R) GLDef(R)

# define GAttrEval(R) ((AttrEval)((R)->UnionField.NodeField))

LString GLString();
#define GSEQString(R) GLString(R)
Lint GLint();
#define GSEQint(R) GLint(R)
AttrEval ligain(zzF)
FILE *zzF;
{	AttrEval zzC;
	NodeType zzN;
	NodeType LIGANodeAlloc();
	void LIGAAttrStore();
	extern PF_NodeType GenericNodeAlloc;
	extern PF_AttrStore GenericAttrStore;

	IDLAllNodeTypes = AllNodeTypes;
	IDLNodeAttributes = NodeAttributes;
	IDLnum_nodetypes = num_nodetypes;
	GenericNodeAlloc = LIGANodeAlloc;
	GenericAttrStore = LIGAAttrStore;
	zzN = Reader(zzF);
	if (!OK) {
		zzC = NULL;
	}
	else if (TypeNode(zzN) == KAttrEval) {
		zzC = (AttrEval)AtNode(zzN);}
	else {
		Error(ErrBadRootType, Lex.Pos);
		OK = 0;
		zzC = NULL; }
	ReaderOK = OK;
	return(zzC);
}
NodeType LIGANodeAlloc(zzN)
register int zzN;
{	register NodeType zznt;
	switch(zzN) {
	    case KAttrEval: SetNPtr(zznt, NAttrEval); break;
	    case KAttracc: SetNPtr(zznt, NAttracc); break;
	    case KAttrdef: SetNPtr(zznt, NAttrdef); break;
	    case KAttribution: SetNPtr(zznt, NAttribution); break;
	    case KCall: SetNPtr(zznt, NCall); break;
	    case KChain: SetNPtr(zznt, NChain); break;
	    case KChainStart: SetNPtr(zznt, NChainStart); break;
	    case KChainacc: SetNPtr(zznt, NChainacc); break;
	    case KConstit: SetNPtr(zznt, NConstit); break;
	    case KDelim: SetNPtr(zznt, NDelim); break;
	    case KDelopt: SetNPtr(zznt, NDelopt); break;
	    case KIncluding: SetNPtr(zznt, NIncluding); break;
	    case KLiteral: SetNPtr(zznt, NLiteral); break;
	    case KName: SetNPtr(zznt, NName); break;
	    case KOpt: SetNPtr(zznt, NOpt); break;
	    case KPlus: SetNPtr(zznt, NPlus); break;
	    case KProd: SetNPtr(zznt, NProd); break;
	    case KStar: SetNPtr(zznt, NStar); break;
	    case KSymb: SetNPtr(zznt, NSymb); break;
	    case KSymbattr: SetNPtr(zznt, NSymbattr); break;
	    case KSymbol: SetNPtr(zznt, NSymbol); break;
	    case KTransfer: SetNPtr(zznt, NTransfer); break;
	    case KTypedef: SetNPtr(zznt, NTypedef); break;
	    case KVal: SetNPtr(zznt, NVal); break;
	    case KVisit: SetNPtr(zznt, NVisit); break;
	    default: Error(ErrBadNodeType, Lex.Pos);
	             OK = 0;
	             break;	}
	return(zznt);
}
LSymbattr GLSymbattr (R)
RepType R;
{	register SeqType S1;
	register LSymbattr S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LSymbattr)GetListCell(sizeof(CSymbattr));
		P->value = GSymbattr(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LSymbattr)GetListCell(sizeof(CSymbattr));
			S2->value = GSymbattr(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
LExpr GLExpr (R)
RepType R;
{	register SeqType S1;
	register LExpr S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LExpr)GetListCell(sizeof(CExpr));
		P->value = GExpr(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LExpr)GetListCell(sizeof(CExpr));
			S2->value = GExpr(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
Expr GExpr (R)
register RepType R;
{
	Expr Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case KCall: Ret.VCall = GCall(R); break;
		case KLiteral: Ret.VLiteral = GLiteral(R); break;
		case KVal: Ret.VVal = GVal(R); break;
		case KName: Ret.VName = GName(R); break;
		case KAttracc: Ret.VAttracc = GAttracc(R); break;
		case KChainacc: Ret.VChainacc = GChainacc(R); break;
		case KConstit: Ret.VConstit = GConstit(R); break;
		case KIncluding: Ret.VIncluding = GIncluding(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
LAttrrule GLAttrrule (R)
RepType R;
{	register SeqType S1;
	register LAttrrule S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LAttrrule)GetListCell(sizeof(CAttrrule));
		P->value = GAttrrule(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LAttrrule)GetListCell(sizeof(CAttrrule));
			S2->value = GAttrrule(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
Attrrule GAttrrule (R)
register RepType R;
{
	Attrrule Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case KCall: Ret.VCall = GCall(R); break;
		case KVisit: Ret.VVisit = GVisit(R); break;
		case KTransfer: Ret.VTransfer = GTransfer(R); break;
		case KChainStart: Ret.VChainStart = GChainStart(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
LAttribution GLAttribution (R)
RepType R;
{	register SeqType S1;
	register LAttribution S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LAttribution)GetListCell(sizeof(CAttribution));
		P->value = GAttribution(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LAttribution)GetListCell(sizeof(CAttribution));
			S2->value = GAttribution(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
LUnit GLUnit (R)
RepType R;
{	register SeqType S1;
	register LUnit S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LUnit)GetListCell(sizeof(CUnit));
		P->value = GUnit(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LUnit)GetListCell(sizeof(CUnit));
			S2->value = GUnit(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
Unit GUnit (R)
register RepType R;
{
	Unit Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case KSymbol: Ret.VSymbol = GSymbol(R); break;
		case KLiteral: Ret.VLiteral = GLiteral(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
LEntity GLEntity (R)
RepType R;
{	register SeqType S1;
	register LEntity S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LEntity)GetListCell(sizeof(CEntity));
		P->value = GEntity(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LEntity)GetListCell(sizeof(CEntity));
			S2->value = GEntity(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
Entity GEntity (R)
register RepType R;
{
	Entity Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case KLiteral: Ret.VLiteral = GLiteral(R); break;
		case KSymbol: Ret.VSymbol = GSymbol(R); break;
		case KOpt: Ret.VOpt = GOpt(R); break;
		case KStar: Ret.VStar = GStar(R); break;
		case KPlus: Ret.VPlus = GPlus(R); break;
		case KDelim: Ret.VDelim = GDelim(R); break;
		case KDelopt: Ret.VDelopt = GDelopt(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
LAttrdef GLAttrdef (R)
RepType R;
{	register SeqType S1;
	register LAttrdef S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LAttrdef)GetListCell(sizeof(CAttrdef));
		P->value = GAttrdef(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LAttrdef)GetListCell(sizeof(CAttrdef));
			S2->value = GAttrdef(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
LDef GLDef (R)
RepType R;
{	register SeqType S1;
	register LDef S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LDef)GetListCell(sizeof(CDef));
		P->value = GDef(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LDef)GetListCell(sizeof(CDef));
			S2->value = GDef(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
Def GDef (R)
register RepType R;
{
	Def Ret;
	switch(R->UnionField.NodeField->IDLhidden.TypeID) {
		case KChain: Ret.VChain = GChain(R); break;
		case KTypedef: Ret.VTypedef = GTypedef(R); break;
		case KSymb: Ret.VSymb = GSymb(R); break;
		case KProd: Ret.VProd = GProd(R); break;
		default: Error(ErrBadClassNode, Lex.Pos);
	}
	return(Ret);
}
Lint GLint (R)
RepType R;
{	register SeqType S1;
	register Lint S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (Lint)GetListCell(sizeof(Cint));
		P->value = Gint(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (Lint)GetListCell(sizeof(Cint));
			S2->value = Gint(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
LString GLString (R)
RepType R;
{	register SeqType S1;
	register LString S2, P, retval;
	S1 = R->UnionField.seqVal;
	if (S1){
		retval = P = (LString)GetListCell(sizeof(CString));
		P->value = GString(S1->value); 
		S1 = S1->next;
		while (S1) {
			S2 = (LString)GetListCell(sizeof(CString));
			S2->value = GString(S1->value);
			P->next = S2; P = S2; S1 = S1->next;
		}
		P->next = NULL;
	}
	else retval = NULL;
	return(retval);
}
void LIGAAttrStore(N,A,R)
register NodeType N;
register AttrDesc A;
register RepType R;
{	switch(N->IDLhidden.TypeID) {
		case KAttrEval: switch (A) {
			case 1: ((AttrEval)(N))->attrrules = GSEQAttribution(R); 
			         break;
			case 2: ((AttrEval)(N))->defseq = GSEQDef(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KAttracc: switch (A) {
			case 1: ((Attracc)(N))->col = Gint(R); 
			         break;
			case 2: ((Attracc)(N))->row = Gint(R); 
			         break;
			case 3: ((Attracc)(N))->attrid = Gint(R); 
			         break;
			case 4: ((Attracc)(N))->symbno = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KAttrdef: switch (A) {
			case 1: ((Attrdef)(N))->globname = GString(R); 
			         break;
			case 2: ((Attrdef)(N))->part = Gint(R); 
			         break;
			case 3: ((Attrdef)(N))->gen = Gint(R); 
			         break;
			case 4: ((Attrdef)(N))->store = Gint(R); 
			         break;
			case 5: ((Attrdef)(N))->prodid = Gint(R); 
			         break;
			case 6: ((Attrdef)(N))->class = Gint(R); 
			         break;
			case 7: ((Attrdef)(N))->typeid = Gint(R); 
			         break;
			case 8: ((Attrdef)(N))->col = Gint(R); 
			         break;
			case 9: ((Attrdef)(N))->row = Gint(R); 
			         break;
			case 10: ((Attrdef)(N))->name = GString(R); 
			         break;
			case 11: ((Attrdef)(N))->did = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KAttribution: switch (A) {
			case 1: ((Attribution)(N))->attrrules = GSEQAttrrule(R); 
			         break;
			case 2: ((Attribution)(N))->prodid = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KCall: switch (A) {
			case 1: ((Call)(N))->col = Gint(R); 
			         break;
			case 2: ((Call)(N))->row = Gint(R); 
			         break;
			case 3: ((Call)(N))->params = GSEQExpr(R); 
			         break;
			case 4: ((Call)(N))->name = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KChain: switch (A) {
			case 1: ((Chain)(N))->did = Gint(R); 
			         break;
			case 2: ((Chain)(N))->dname = GString(R); 
			         break;
			case 3: ((Chain)(N))->row = Gint(R); 
			         break;
			case 4: ((Chain)(N))->col = Gint(R); 
			         break;
			case 5: ((Chain)(N))->typeid = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KChainStart: switch (A) {
			case 1: ((ChainStart)(N))->col = Gint(R); 
			         break;
			case 2: ((ChainStart)(N))->row = Gint(R); 
			         break;
			case 3: ((ChainStart)(N))->postgenattr = GString(R); 
			         break;
			case 4: ((ChainStart)(N))->pregenattr = GString(R); 
			         break;
			case 5: ((ChainStart)(N))->chainid = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KChainacc: switch (A) {
			case 1: ((Chainacc)(N))->col = Gint(R); 
			         break;
			case 2: ((Chainacc)(N))->row = Gint(R); 
			         break;
			case 3: ((Chainacc)(N))->chainid = Gint(R); 
			         break;
			case 4: ((Chainacc)(N))->symbno = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KConstit: switch (A) {
			case 1: ((Constit)(N))->col = Gint(R); 
			         break;
			case 2: ((Constit)(N))->row = Gint(R); 
			         break;
			case 3: ((Constit)(N))->constattrs = GSEQSymbattr(R); 
			         break;
			case 4: ((Constit)(N))->subtree = Gint(R); 
			         break;
			case 5: ((Constit)(N))->single = Gint(R); 
			         break;
			case 6: ((Constit)(N))->genattr = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KDelim: switch (A) {
			case 1: ((Delim)(N))->del = GLiteral(R); 
			         break;
			case 2: ((Delim)(N))->rhs = GSEQUnit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KDelopt: switch (A) {
			case 1: ((Delopt)(N))->del = GLiteral(R); 
			         break;
			case 2: ((Delopt)(N))->rhs = GSEQUnit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KIncluding: switch (A) {
			case 1: ((Including)(N))->col = Gint(R); 
			         break;
			case 2: ((Including)(N))->row = Gint(R); 
			         break;
			case 3: ((Including)(N))->inclattrs = GSEQSymbattr(R); 
			         break;
			case 4: ((Including)(N))->genattrid = Gint(R); 
			         break;
			case 5: ((Including)(N))->genattr = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KLiteral: switch (A) {
			case 1: ((Literal)(N))->row = Gint(R); 
			         break;
			case 2: ((Literal)(N))->col = Gint(R); 
			         break;
			case 3: ((Literal)(N))->str = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KName: switch (A) {
			case 1: ((Name)(N))->col = Gint(R); 
			         break;
			case 2: ((Name)(N))->row = Gint(R); 
			         break;
			case 3: ((Name)(N))->n = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KOpt: switch (A) {
			case 1: ((Opt)(N))->rhs = GSEQUnit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KPlus: switch (A) {
			case 1: ((Plus)(N))->rhs = GSEQUnit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KProd: switch (A) {
			case 1: ((Prod)(N))->did = Gint(R); 
			         break;
			case 2: ((Prod)(N))->dname = GString(R); 
			         break;
			case 3: ((Prod)(N))->row = Gint(R); 
			         break;
			case 4: ((Prod)(N))->col = Gint(R); 
			         break;
			case 5: ((Prod)(N))->rhs = GSEQEntity(R); 
			         break;
			case 6: ((Prod)(N))->lhs = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KStar: switch (A) {
			case 1: ((Star)(N))->rhs = GSEQUnit(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KSymb: switch (A) {
			case 1: ((Symb)(N))->did = Gint(R); 
			         break;
			case 2: ((Symb)(N))->dname = GString(R); 
			         break;
			case 3: ((Symb)(N))->row = Gint(R); 
			         break;
			case 4: ((Symb)(N))->col = Gint(R); 
			         break;
			case 5: ((Symb)(N))->attrs = GSEQAttrdef(R); 
			         break;
			case 6: ((Symb)(N))->tornt = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KSymbattr: switch (A) {
			case 1: ((Symbattr)(N))->attrdef = Gint(R); 
			         break;
			case 2: ((Symbattr)(N))->symbdef = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KSymbol: switch (A) {
			case 1: ((Symbol)(N))->row = Gint(R); 
			         break;
			case 2: ((Symbol)(N))->col = Gint(R); 
			         break;
			case 3: ((Symbol)(N))->did = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KTransfer: switch (A) {
			case 1: ((Transfer)(N))->col = Gint(R); 
			         break;
			case 2: ((Transfer)(N))->row = Gint(R); 
			         break;
			case 3: ((Transfer)(N))->attrs = GSEQString(R); 
			         break;
			case 4: ((Transfer)(N))->symbno = GSEQint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KTypedef: switch (A) {
			case 1: ((Typedef)(N))->did = Gint(R); 
			         break;
			case 2: ((Typedef)(N))->dname = GString(R); 
			         break;
			case 3: ((Typedef)(N))->row = Gint(R); 
			         break;
			case 4: ((Typedef)(N))->col = Gint(R); 
			         break;
			case 5: ((Typedef)(N))->listedto = Gint(R); 
			         break;
			case 6: ((Typedef)(N))->extname = GString(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KVal: switch (A) {
			case 1: ((Val)(N))->col = Gint(R); 
			         break;
			case 2: ((Val)(N))->row = Gint(R); 
			         break;
			case 3: ((Val)(N))->v = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		case KVisit: switch (A) {
			case 1: ((Visit)(N))->ord = Gint(R); 
			         break;
			case 2: ((Visit)(N))->symbno = Gint(R); 
			         break;
			default: Error(ErrBadAttribute,Lex.Pos); 
		} break;
		default: Error(ErrBadNodeType, Lex.Pos); break;
	}
	DelRep(R);
}
